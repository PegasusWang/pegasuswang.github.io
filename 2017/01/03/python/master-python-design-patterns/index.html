<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mastering Python Design Patterns | Pegasus&#39; Blog</title>
  <meta name="author" content="PegasusWang">
  
  <meta name="description" content="PegasusWang 的日常记录">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Mastering Python Design Patterns"/>
  <meta property="og:site_name" content="Pegasus&#39; Blog"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Pegasus&#39; Blog" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
      <li><a href="https://github.com/pegasuswang/vim-config">Neovim</a></li>
    
      <li><a href="https://www.zhihu.com/people/pegasus-wang/activities">知乎</a></li>
    
      <li><a href="http://python-web-guide.readthedocs.io/zh/latest/">Python入坑指南</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2017-01-02T16:08:27.000Z"><a href="/2017/01/03/python/master-python-design-patterns/">周二, 1月 3 2017, 12:08:27 凌晨</a></time>

  
    <h1 class="title">Mastering Python Design Patterns</h1>
  


  
  <div class="categories">
  	<i class="fa fa-folder-open"></i>
    <a href="/categories/python/">python</a>
  </div>


  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/python/">python</a>, <a href="/tags/design-pattern/">design-pattern</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <blockquote>
<p>Patterns mean “I have run out of language.” - Rich Hickey</p>
</blockquote>
<p>之前学习设计模式的时候总是没有什么感觉，因为记性不好一直没记住多少。python不像java中比较强调设计模式(编程套路)，动态语言也内置了像是装饰器、迭代器等模式，另外python中的『一切皆对象』、鸭子类型等也导致python中实现的设计模式和其他语言有些差别。根据YAGNI(you aren’t gonna need it)和KISS(Keep it simple sutpid)原则，如果能用简单易懂的方式实现，最好不要滥用设计模式以免增加复杂度和维护难度。本博客是《Mastering Python Design Patterns》的读书笔记，涵盖大部分设计模式(力求pythonic实现)，有兴趣可以参考下，代码示例版本为python3.5.2。（3.6都发布了，已经被时代遗弃😢……)</p>
<a id="more"></a>
<hr>
<h2 id="1-The-Fctory-Pattern-工厂模式-解决对象创建问题"><a href="#1-The-Fctory-Pattern-工厂模式-解决对象创建问题" class="headerlink" title="1: The Fctory Pattern(工厂模式: 解决对象创建问题)"></a>1: The Fctory Pattern(工厂模式: 解决对象创建问题)</h2><p>先来看三种创建模式中的第一种工厂模式。<br>解释：处理对象创建，客户端可以申请一个对象而不用知道对象被哪个class创建。可以方便地解耦对象的使用和创建。有两种实现，工厂方法和抽象工厂.</p>
<h3 id="Factory-Method-工厂方法-：执行单独的函数，通过传参提供需要的对象的信息。通过一个demo看看例子"><a href="#Factory-Method-工厂方法-：执行单独的函数，通过传参提供需要的对象的信息。通过一个demo看看例子" class="headerlink" title="Factory Method(工厂方法)：执行单独的函数，通过传参提供需要的对象的信息。通过一个demo看看例子:"></a>Factory Method(工厂方法)：执行单独的函数，通过传参提供需要的对象的信息。通过一个demo看看例子:</h3><pre><code>import json
import xml.etree.ElementTree as etree

class JSONConnector:
    def __init__(self, filepath):
        self.data = dict()
        with open(filepath, mode=&apos;r&apos;, encoding=&apos;utf8&apos;) as f:
            self.data = json.load(f)

    @property
    def parsed_data(self):
        return self.data


class XMLConnector:
    def __init__(self, filepath):
        self.tree = etree.parse(filepath)

    @property
    def parsed_data(self):
        return self.tree


def connection_factory(filepath):
    &quot;&quot;&quot; 工厂方法 &quot;&quot;&quot;
    if filepath.endswith(&apos;json&apos;):
        connector = JSONConnector
    elif filepath.endswith(&apos;xml&apos;):
        connector = XMLConnector
    else:
        raise ValueError(&apos;Cannot connect to {}&apos;.format(filepath))
    return connector(filepath)
</code></pre><h3 id="Abstract-Factory-抽象工厂-解决复杂对象创建问题"><a href="#Abstract-Factory-抽象工厂-解决复杂对象创建问题" class="headerlink" title="Abstract Factory(抽象工厂: 解决复杂对象创建问题)"></a>Abstract Factory(抽象工厂: 解决复杂对象创建问题)</h3><p>工厂方法适合对象种类较少的情况，如果有多种不同类型对象需要创建，使用抽象工厂模式。以实现一个游戏的例子说明，在一个抽象工厂类里实现多个关联对象的创建：</p>
<pre><code>class Frog:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def interact_with(self, obstacle):
        &quot;&quot;&quot; 不同类型玩家遇到的障碍不同 &quot;&quot;&quot;
        print(&apos;{} the Frog encounters {} and {}!&apos;.format(
            self, obstacle, obstacle.action()))


class Bug:
    def __str__(self):
        return &apos;a bug&apos;

    def action(self):
        return &apos;eats it&apos;


class FrogWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name

    def __str__(self):
        return &apos;\n\n\t----Frog World -----&apos;

    def make_character(self):
        return Frog(self.player_name)

    def make_obstacle(self):
        return Bug()


class Wizard:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def interact_with(self, obstacle):
        print(&apos;{} the Wizard battles against {} and {}!&apos;.format(
            self, obstacle, obstacle.action()))


class Ork:
    def __str__(self):
        return &apos;an evil ork&apos;

    def action(self):
        return &apos;kill it&apos;


class WizardWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name

    def __str__(self):
        return &apos;\n\n\t------ Wizard World -------&apos;

    def make_character(self):
        return Wizard(self.player_name)

    def make_obstacle(self):
        return Ork()


class GameEnvironment:
    &quot;&quot;&quot; 抽象工厂，根据不同的玩家类型创建不同的角色和障碍 (游戏环境)
    这里可以根据年龄判断，成年人返回『巫师』游戏，小孩返回『青蛙过河』游戏&quot;&quot;&quot;
    def __init__(self, factory):
        self.hero = factory.make_character()
        self.obstacle = factory.make_obstacle()

    def play(self):
        self.hero.interact_with(self.obstacle)
</code></pre><hr>
<h2 id="2-The-Builder-Pattern-构造模式-控制复杂对象的构造"><a href="#2-The-Builder-Pattern-构造模式-控制复杂对象的构造" class="headerlink" title="2: The Builder Pattern(构造模式: 控制复杂对象的构造)"></a>2: The Builder Pattern(构造模式: 控制复杂对象的构造)</h2><p>当对象需要多个部分组合起来一步步创建，并且创建和表示分离的时候。可以这么理解，你要买电脑，工厂模式直接返回一个你需要型号的电脑，但是构造模式允许你自定义电脑各种配置类型，组装完成后给你。这个过程你可以传入builder从而自定义创建的方式。</p>
<pre><code># factory pattern
MINI14 = &apos;1.4GHz Mac mini&apos;


class AppleFactory:

    class MacMini14:
        def __init__(self):
            self.memory = 4  # in gigabytes
            self.hdd = 500  # in gigabytes
            self.gpu = &apos;Intel HD Graphics 5000&apos;

        def __str__(self):
            info = (&apos;Model: {}&apos;.format(MINI14),
                    &apos;Memory: {}GB&apos;.format(self.memory),
                    &apos;Hard Disk: {}GB&apos;.format(self.hdd),
                    &apos;Graphics Card: {}&apos;.format(self.gpu))
            return &apos;\n&apos;.join(info)

    def build_computer(self, model):
        if model == MINI14:
            return self.MacMini14()
        else:
            print(&quot;I don&apos;t know how to build {}&quot;.format(model))


# 使用工厂
afac = AppleFactory()
mac_mini = afac.build_computer(MINI14)
print(mac_mini)


# builder模式


class Computer:
    def __init__(self, serial_number):
        self.serial = serial_number
        self.memory = None      # in gigabytes
        self.hdd = None         # in gigabytes
        self.gpu = None

    def __str__(self):
        info = (&apos;Memory: {}GB&apos;.format(self.memory),
                &apos;Hard Disk: {}GB&apos;.format(self.hdd),
                &apos;Graphics Card: {}&apos;.format(self.gpu))
        return &apos;\n&apos;.join(info)


class ComputerBuilder:
    def __init__(self):
        self.computer = Computer(&apos;AG23385193&apos;)

    def configure_memory(self, amount):
        self.computer.memory = amount

    def configure_hdd(self, amount):
        self.computer.hdd = amount

    def configure_gpu(self, gpu_model):
        self.computer.gpu = gpu_model


class HardwareEngineer:
    def __init__(self):
        self.builder = None

    def construct_computer(self, memory, hdd, gpu):
        self.builder = ComputerBuilder()
        [step for step in (self.builder.configure_memory(memory),
                        self.builder.configure_hdd(hdd),
                        self.builder.configure_gpu(gpu))]

    @property
    def computer(self):
        return self.builder.computer

# 使用buidler，可以创建多个builder类实现不同的组装方式
engineer = HardwareEngineer()
engineer.construct_computer(hdd=500, memory=8, gpu=&apos;GeForce GTX 650 Ti&apos;)
computer = engineer.computer
print(computer)
</code></pre><hr>
<h2 id="3-The-Prototype-Pattern-原型模式-解决对象拷贝问题"><a href="#3-The-Prototype-Pattern-原型模式-解决对象拷贝问题" class="headerlink" title="3:The Prototype Pattern(原型模式:解决对象拷贝问题)"></a>3:The Prototype Pattern(原型模式:解决对象拷贝问题)</h2><p>这是创建模式中的最后一个，用来克隆一个对象，有点像生物学中的有丝分裂。我们可以使用python内置的copy模块实现。拷贝分为深拷贝和浅拷贝，深拷贝会递归复制并创建新对象，而浅拷贝会利用引用指向同一个对象.深拷贝的优点是对象之间互不影响，但是会耗费资源，创建比较耗时；如果不会修改对象可以使用浅拷贝，更加节省资源和创建时间。</p>
<ul>
<li>“A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.</li>
<li>A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.”</li>
</ul>
<pre><code>import copy
from collections import OrderedDict

class Book:
    def __init__(self, name, authors, price, **rest):
        &apos;&apos;&apos;Examples of rest: publisher, length, tags, publication
        date&apos;&apos;&apos;
        self.name = name
        self.authors = authors
        self.price = price      # in US dollars
        self.__dict__.update(rest)

    def __str__(self):
        mylist = []
        ordered = OrderedDict(sorted(self.__dict__.items()))
        for i in ordered.keys():
            mylist.append(&apos;{}: {}&apos;.format(i, ordered[i]))
            if i == &apos;price&apos;:
                mylist.append(&apos;$&apos;)
            mylist.append(&apos;\n&apos;)
        return &apos;&apos;.join(mylist)


class Prototype:
    def __init__(self):
        self.objects = {}

    def register(self, identifier, obj):
        self.objects[identifier] = obj

    def unregister(self, identifier):
        del self.objects[identifier]

    def clone(self, identifier, **attr):
        &quot;&quot;&quot; 实现对象拷贝 &quot;&quot;&quot;
        found = self.objects.get(identifier)
        if not found:
            raise ValueError(&apos;Incorrect object identifier: {}&apos;.format(identifier))
        obj = copy.deepcopy(found)
        obj.__dict__.update(attr)    # 实现拷贝时自定义更新
        return obj


def main():
    b1 = Book(&apos;The C Programming Language&apos;, (&apos;Brian W. Kernighan&apos;, &apos;Dennis M.Ritchie&apos;),
            price=118, publisher=&apos;Prentice Hall&apos;, length=228, publication_date=&apos;1978-02-22&apos;,
            tags=(&apos;C&apos;, &apos;programming&apos;, &apos;algorithms&apos;, &apos;data structures&apos;))

    prototype = Prototype()
    cid = &apos;k&amp;r-first&apos;
    prototype.register(cid, b1)
    b2 = prototype.clone(cid, name=&apos;The C Programming Language (ANSI)&apos;, price=48.99, length=274,
                        publication_date=&apos;1988-04-01&apos;, edition=2)
    for i in (b1, b2):
        print(i)
        print(&quot;ID b1 : {} != ID b2 : {}&quot;.format(id(b1), id(b2)))
</code></pre><hr>
<h2 id="4-The-Adapter-Pattern-适配器模式-解决接口不兼容问题"><a href="#4-The-Adapter-Pattern-适配器模式-解决接口不兼容问题" class="headerlink" title="4: The Adapter Pattern(适配器模式: 解决接口不兼容问题)"></a>4: The Adapter Pattern(适配器模式: 解决接口不兼容问题)</h2><p>开始介绍结构型设计模式，结构型设计模式通过组合对象来实现新功能。适配器模式通过引入间接层来实现不兼容接口之间的适配。现实中最好的例子就是手机充电口，不同型号安卓手机都可以用同样的充电线充电。在python中可以通过继承实现适配，也可以通过使用class的<strong>dict</strong>属性。<br>开闭原则：适配器模式和OOP中的开闭原则关系密切，开闭原则强调对扩展开放，对修改关闭。通过适配器模式我们可以通过创建适配器模式在不修改原有类代码的情况下实现新的功能。</p>
<pre><code>class Computer:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return &apos;the {} computer&apos;.format(self.name)

    def execute(self):
        &quot;&quot;&quot; call by client code &quot;&quot;&quot;
        return &apos;execute a program&apos;


class Synthesizer:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return &apos;the {} synthesizer&apos;.format(self.name)

    def play(self):
        return &apos;is playing an electroinc song&apos;


class Human:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return &apos;the {} human&apos;.format(self.name)

    def speak(self):
        return &apos;says hello&apos;


class Adapter:
    def __init__(self, obj, adapted_methods):
        &quot;&quot;&quot; 不使用继承，使用__dict__属性实现适配器模式 &quot;&quot;&quot;
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __str__(self):
        return str(self.obj)


# 适配器使用示例
def main():
    objs = [Computer(&apos;Asus&apos;)]
    synth = Synthesizer(&apos;moog&apos;)
    objs.append(Adapter(synth, dict(execute=synth.play)))
    human = Human(&apos;Wnn&apos;)
    objs.append(Adapter(human, dict(execute=human.speak)))

    for o in objs:
        # 用统一的execute适配不同对象的方法，这样在无需修改源对象的情况下就实现了不同对象方法的适配
        print(&apos;{} {}&apos;.format(str(o), o.execute()))


if __name__ == &quot;__main__&quot;:
    main()
</code></pre><hr>
<h2 id="5-The-Decorator-Pattern-装饰器模式：-无需子类化实现扩展对象功能问题"><a href="#5-The-Decorator-Pattern-装饰器模式：-无需子类化实现扩展对象功能问题" class="headerlink" title="5: The Decorator Pattern(装饰器模式： 无需子类化实现扩展对象功能问题)"></a>5: The Decorator Pattern(装饰器模式： 无需子类化实现扩展对象功能问题)</h2><p>通常给一个对象添加新功能有三种方式：</p>
<ul>
<li>直接给对象所属的类添加方法。</li>
<li>使用『组合』</li>
<li>使用『继承』，优先使用组合而非继承。<br>装饰器模式提供了第四种选择，通过动态改变对象扩展对象功能。其他编程语言通常使用继承实现装饰器装饰器模式，而python内置了装饰器。装饰器有很多用途，比如数据校验，事务处理，缓存，日志等。比如用装饰器实现一个简单的缓存，python3.5自带了functools.lru_cache</li>
</ul>
<pre><code>from functools import wraps

def memoize(fn):
    known = dict()

    @wraps(fn)
    def memoizer(*args):
        if args not in known:
            known[args] = fn(*args)
        return known[args]
    return memoizer


@memoize
def fibonacci(n):
    assert(n &gt;= 0), &apos;n must be &gt;= 0&apos;
    return n if n in (0, 1) else fibonacci(n-1) + fibonacci(n-2)
</code></pre><hr>
<h2 id="6-The-Facade-Pattern-外观模式-简化复杂对象的访问问题"><a href="#6-The-Facade-Pattern-外观模式-简化复杂对象的访问问题" class="headerlink" title="6: The Facade Pattern(外观模式: 简化复杂对象的访问问题)"></a>6: The Facade Pattern(外观模式: 简化复杂对象的访问问题)</h2><p>外观模式用来简化复杂系统的访问。通过简化的接口只访问需要的部分，隐藏系统复杂性。想象一下公司接线员，虽然公司内部运行机制比较复杂，但是接线员可以迅速帮你解决特定问题。 我们以实现个简单的操作系统示例说明外观模式：</p>
<pre><code>from abc import ABCMeta, abstractmethod
from enum import Enum

State = Enum(&apos;State&apos;, &apos;new running sleeping restart zombie&apos;)


class Server(metaclass=ABCMeta):
    &quot;&quot;&quot; 抽象基类 &quot;&quot;&quot;
    @abstractmethod
    def __init__(self):
        pass

    def __str__(self):
        return self.name

    @abstractmethod
    def boot(self):
        pass

    @abstractmethod
    def kill(self, restart=True):
        pass


class FileServer(Server):
    def __init__(self):
        &apos;&apos;&apos;actions required for initializing the file server&apos;&apos;&apos;
        self.name = &apos;FileServer&apos;
        self.state = State.new

    def boot(self):
        print(&apos;booting the {}&apos;.format(self))
        &apos;&apos;&apos;actions required for booting the file server&apos;&apos;&apos;
        self.state = State.running

    def kill(self, restart=True):
        print(&apos;Killing {}&apos;.format(self))
        &apos;&apos;&apos;actions required for killing the file server&apos;&apos;&apos;
        self.state = State.restart if restart else State.zombie

    def create_file(self, user, name, permissions):
        &apos;&apos;&apos;check validity of permissions, user rights, etc.&apos;&apos;&apos;
        print(&quot;trying to create the file &apos;{}&apos; for user &apos;{}&apos; with permissions {}&quot;.format(name, user, permissions))

class ProcessServer(Server):
    def __init__(self):
        &apos;&apos;&apos;actions required for initializing the process server&apos;&apos;&apos;
        self.name = &apos;ProcessServer&apos;
        self.state = State.new

    def boot(self):
        print(&apos;booting the {}&apos;.format(self))
        &apos;&apos;&apos;actions required for booting the process server&apos;&apos;&apos;
        self.state = State.running

    def kill(self, restart=True):
        print(&apos;Killing {}&apos;.format(self))
        &apos;&apos;&apos;actions required for killing the process server&apos;&apos;&apos;
        self.state = State.restart if restart else State.zombie

    def create_process(self, user, name):
        &apos;&apos;&apos;check user rights, generate PID, etc.&apos;&apos;&apos;
        print(&quot;trying to create the process &apos;{}&apos; for user &apos;{}&apos;&quot;.format(name, user))


class OperatingSystem:
    &apos;&apos;&apos; 实现外观模式，外部使用的代码不必知道 FileServer 和 ProcessServer的
    内部机制，只需要通过 OperatingSystem类调用&apos;&apos;&apos;
    def __init__(self):
        self.fs = FileServer()
        self.ps = ProcessServer()

    def start(self):
        &quot;&quot;&quot; 被客户端代码使用 &quot;&quot;&quot;
        [i.boot() for i in (self.fs, self.ps)]

    def create_file(self, user, name, permissions):
        return self.fs.create_file(user, name, permissions)

    def create_process(self, user, name):
        return self.ps.create_process(user, name)

def main():
    os = OperatingSystem()
    os.start()
    os.create_file(&apos;foo&apos;, &apos;hello&apos;, &apos;-rw-r-r&apos;)
    os.create_process(&apos;bar&apos;, &apos;ls /tmp&apos;)

main()
</code></pre><hr>
<p>7: The Flyweight Pattern(享元模式: 实现对象复用从而改善资源使用）</p>
<blockquote>
<p>Flyweight design pattern is a technique used to minimize memory usage and improve performance by introducing data sharing between similar objects.</p>
</blockquote>
<p>OOP编程中容易出现对象创建带来的性能和内存占用问题，需要满足以下条件：</p>
<ul>
<li>需要使用大量对象(python里我们可以用<strong>slots</strong>节省内存占用)</li>
<li>对象太多难以存储或解析大量对象。</li>
<li>对象识别不是特别重要，共享对象中对象比较会失败。</li>
</ul>
<pre><code># 使用对象池技术实现享元模式
import random
from enum import Enum
TreeType = Enum(&apos;TreeType&apos;, &apos;apple_tree cherry_tree peach_tree&apos;)


class Tree:
    pool = dict()

    def __new__(cls, tree_type):
        obj = cls.pool.get(tree_type, None)
        if obj is None:
            obj = object.__new__(cls)
            cls.pool[tree_type] = obj
            obj.tree_type = tree_type
        return obj

    def render(self, age, x, y):
        print(&apos;render a tree of type {} and age {} at ({}, {})&apos;.format(self.tree_type, age, x, y))


def main():
    rnd = random.Random()
    age_min, age_max = 1, 30    # in years
    min_point, max_point = 0, 100
    tree_counter = 0

    for _ in range(10):
        t1 = Tree(TreeType.apple_tree)
        t1.render(rnd.randint(age_min, age_max),
                rnd.randint(min_point, max_point),
                rnd.randint(min_point, max_point))
        tree_counter += 1

    for _ in range(3):
        t2 = Tree(TreeType.cherry_tree)
        t2.render(rnd.randint(age_min, age_max),
                rnd.randint(min_point, max_point),
                rnd.randint(min_point, max_point))
        tree_counter += 1

    for _ in range(5):
        t3 = Tree(TreeType.peach_tree)
        t3.render(rnd.randint(age_min, age_max),
                rnd.randint(min_point, max_point),
                rnd.randint(min_point, max_point))
        tree_counter += 1
    print(&apos;trees rendered: {}&apos;.format(tree_counter))
    print(&apos;trees actually created: {}&apos;.format(len(Tree.pool)))
    t4 = Tree(TreeType.cherry_tree)
    t5 = Tree(TreeType.cherry_tree)
    t6 = Tree(TreeType.apple_tree)
    print(&apos;{} == {}? {}&apos;.format(id(t4), id(t5), id(t4) == id(t5)))
    print(&apos;{} == {}? {}&apos;.format(id(t5), id(t6), id(t5) == id(t6)))


if __name__ == &apos;__main__&apos;:
    main()
</code></pre><hr>
<h2 id="8-The-Model-View-Controller-Pattern-mvc模式：解耦展示逻辑和业务逻辑"><a href="#8-The-Model-View-Controller-Pattern-mvc模式：解耦展示逻辑和业务逻辑" class="headerlink" title="8: The Model-View-Controller Pattern(mvc模式：解耦展示逻辑和业务逻辑)"></a>8: The Model-View-Controller Pattern(mvc模式：解耦展示逻辑和业务逻辑)</h2><blockquote>
<p>When using MVC, make sure that you creating smart models (core functionality), thin controllers (functionality required for the communication between the view and the controller), and dumb views (representation and minimal processing).</p>
</blockquote>
<p>MVC模式既是一种设计模式，也是软件架构模式。比如流行的django框架就是mvc(MTV)模式。Model层负责和数据库交互，View层负责展现逻辑，Controller层负责粘合Model和View层，将各个部分解耦，使代码更易扩展和维护。</p>
<pre><code>quotes = (&apos;A man is not complete until he is married. Then he is finished.&apos;,
        &apos;As I said before, I never repeat myself.&apos;,
        &apos;Behind a successful man is an exhausted woman.&apos;,
        &apos;Black holes really suck...&apos;, &apos;Facts are stubborn things.&apos;)


class QuoteModel:
    def get_quote(self, n):
        try:
            return quotes[n]
        except IndexError:
            return &apos;Not found&apos;


class QuoteTerminalView:

    def show(self, quote):
        print(&apos;And the quote is: &quot;{}&quot;&apos;.format(quote))

    def error(self, msg):
        print(&apos;Error: {}&apos;.format(msg))

    def select_quote(self):
        return input(&apos;Which quote number would you like to see? &apos;)



class QuoteTerminalController:
    def __init__(self):
        self.model = QuoteModel()
        self.view = QuoteTerminalView()

    def run(self):
        valid_input = False
        while not valid_input:
            n = self.view.select_quote()
            try:
                n = int(n)
            except ValueError:
                self.view.error(&quot;Incorrect index &apos;{}&apos;&quot;.format(n))
            else:
                valid_input = True
                quote = self.model.get_quote(n)
                self.view.show(quote)


def main():
    controller = QuoteTerminalController()
    while True:
        controller.run()
</code></pre><hr>
<h2 id="9-The-Proxy-Pattern-代理模式：通过一层间接保护层实现更安全的接口访问）"><a href="#9-The-Proxy-Pattern-代理模式：通过一层间接保护层实现更安全的接口访问）" class="headerlink" title="9: The Proxy Pattern(代理模式：通过一层间接保护层实现更安全的接口访问）"></a>9: The Proxy Pattern(代理模式：通过一层间接保护层实现更安全的接口访问）</h2><p>在访问真正的对象之前做一些操作。有四种常用的代理类型:</p>
<ul>
<li>A remote proxy.使得访问远程对象就像本地访问一样，例如网络服务器。隐藏复杂性，使得访问本地远程统一。比如ORM</li>
<li>A virtual proxy。用来实现延迟访问，比如一些需要复杂计算的对象，python里可以实现lazy_property，性能改善</li>
<li>A protection/protective proxy. 控制敏感对象的访问，加上一层保护层，实现安全控制</li>
<li>A smart(reference) proxy. 访问对象时加上一层额外操作，例如引用计数和线程安全检查。weakref.proxy()</li>
</ul>
<p>代理模式的功能还是很强大的，先来看看使用描述符实现LazyProperty，在对象创建以后第一次访问才会真正生成</p>
<pre><code>class LazyProperty:
    &quot;&quot;&quot; 用描述符实现延迟加载的属性 &quot;&quot;&quot;
    def __init__(self, method):
        self.method = method
        self.method_name = method.__name__

    def __get__(self, obj, cls):
        if not obj:
            return None
        value = self.method(obj)
        print(&apos;value {}&apos;.format(value))
        setattr(obj, self.method_name, value)
        return value


class Test:
    def __init__(self):
        self.x = &apos;foo&apos;
        self.y = &apos;bar&apos;
        self._resource = None

    @LazyProperty
    def resource(self):    # 构造函数里没有初始化，第一次访问才会被调用
        print(&apos;initializing self._resource which is: {}&apos;.format(self._resource))
        self._resource = tuple(range(5))    # 模拟一个耗时计算
        return self._resource


def main():
    t = Test()
    print(t.x)
    print(t.y)
    # 访问LazyProperty, resource里的print语句只执行一次，实现了延迟加载和一次执行
    print(t.resource)
    print(t.resource)


main()
</code></pre><p>再看那个用代理实现安全控制的例子，我们给SensitiveInfo里的add操作加上密钥验证，例子也很简单</p>
<pre><code>class SensitiveInfo:
    def __init__(self):
        self.users = [&apos;nick&apos;, &apos;tom&apos;, &apos;ben&apos;, &apos;mike&apos;]

    def read(self):
        print(&apos;There are {} users: {}&apos;.format(len(self.users), &apos; &apos;.join(self.users)))

    def add(self, user):
        self.users.append(user)
        print(&apos;Added user {}&apos;.format(user))


class Info:
    &apos;&apos;&apos;protection proxy to SensitiveInfo&apos;&apos;&apos;
    def __init__(self):
        self.protected = SensitiveInfo()
        # 为了方便示例这里直接写死在代码里，为了安全不应该这么做
        self.secret = &apos;0xdeadbeef&apos;

    def read(self):
        self.protected.read()

    def add(self, user):
        &quot;&quot;&quot; 给add操作加上密钥验证，保护add操作&quot;&quot;&quot;
        sec = input(&apos;what is the secret? &apos;)
        self.protected.add(user) if sec == self.secret else print(&quot;That&apos;s wrong!&quot;)


def main():
    info = Info()
    while True:
        print(&apos;1. read list |==| 2. add user |==| 3. quit&apos;)
        key = input(&apos;choose option: &apos;)
        if key == &apos;1&apos;:
            info.read()
        elif key == &apos;2&apos;:
            name = input(&apos;choose username: &apos;)
            info.add(name)
        elif key == &apos;3&apos;:
            exit()
        else:
            print(&apos;unknown option: {}&apos;.format(key))
main()
</code></pre><p>上面这个示例有几个缺点</p>
<ol>
<li>SensitiveInfo可以被直接实例化使用，绕过Info类，可以考虑使用abc模块避免SensitiveInfo被直接实例化</li>
<li>密钥直接写死在代码里，应该用安全性较高密钥写到配置或者环境变量里</li>
</ol>
<p>我们使用抽象基类来修正第一个缺陷，只需要修正类代码而不用改main函数里的使用代码</p>
<pre><code>from abc import ABCMeta, abstractmethod


class SensitiveInfo(metaclass=ABCMeta):
    def __init__(self):
        self.users = [&apos;nick&apos;, &apos;tom&apos;, &apos;ben&apos;, &apos;mike&apos;]

    @abstractmethod
    def read(self):
        pass

    @abstractmethod
    def add(self, user):
        pass


class Info(SensitiveInfo):
    &apos;&apos;&apos;protection proxy to SensitiveInfo&apos;&apos;&apos;
    def __init__(self):
        # self.protected = SensitiveInfo()
        super().__init__()
        self.secret = &apos;0xdeadbeef&apos;    # 为了方便示例这里直接写死在代码里

    def read(self):
        print(&apos;There are {} users: {}&apos;.format(len(self.users), &apos; &apos;.join(self.users)))

    def add(self, user):
        &quot;&quot;&quot; 给add操作加上密钥验证，保护add操作&quot;&quot;&quot;
        sec = input(&apos;what is the secret? &apos;)
        self.users.append(user) if sec == self.secret else print(&quot;That&apos;s wrong!&quot;)
</code></pre><hr>
<h2 id="10-The-Chain-of-Responsibility-Pattern-责任链模式-创建链式对象用来接收广播消息"><a href="#10-The-Chain-of-Responsibility-Pattern-责任链模式-创建链式对象用来接收广播消息" class="headerlink" title="10: The Chain of Responsibility Pattern (责任链模式:创建链式对象用来接收广播消息)"></a>10: The Chain of Responsibility Pattern (责任链模式:创建链式对象用来接收广播消息)</h2><blockquote>
<p>The Chain of Responsibility pattern is used when we want to give a chance to multiple objects to satisfy a single request, or when we don’t know which object (from a chain of objects) should process a specific request in advance.</p>
</blockquote>
<p>开始介绍行为型设计模式，行为型设计模式处理对象之间的交互和算法问题。在责任连模式中，我们把消息发送给一系列对象的首个节点，对象可以选择处理消息或者向下一个对象传递,只有对消息感兴趣的节点处理。用来解耦发送者和接收者。在python里通过dynamic dispatching来实现，以一个事件驱动系统来说明：</p>
<pre><code>class Event:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name


class Widget:

    &quot;&quot;&quot;Docstring for Widget. &quot;&quot;&quot;

    def __init__(self, parent=None):
        self.parent = parent

    def handle(self, event):
        handler = &apos;handle_{}&apos;.format(event)
        if hasattr(self, handler):
            method = getattr(self, handler)
            method(event)
        elif self.parent:
            self.parent.handle(event)
        elif hasattr(self, &apos;handle_default&apos;):
            self.handle_default(event)


class MainWindow(Widget):
    def handle_close(self, event):
        print(&apos;MainWindow: {}&apos;.format(event))

    def handle_default(self, event):
        print(&apos;MainWindow: Default {}&apos;.format(event))


class SendDialog(Widget):
    def handle_paint(self, event):
        print(&apos;SendDialog: {}&apos;.format(event))


class MsgText(Widget):
    def handle_down(self, event):
        print(&apos;MsgText: {}&apos;.format(event))


def main():
    mw = MainWindow()
    sd = SendDialog(mw)    # parent是mw
    msg = MsgText(sd)

    for e in (&apos;down&apos;, &apos;paint&apos;, &apos;unhandled&apos;, &apos;close&apos;):
        evt = Event(e)
        print(&apos;\nSending event -{}- to MainWindow&apos;.format(evt))
        mw.handle(evt)
        print(&apos;Sending event -{}- to SendDialog&apos;.format(evt))
        sd.handle(evt)
        print(&apos;Sending event -{}- to MsgText&apos;.format(evt))
        msg.handle(evt)

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><hr>
<h2 id="11-The-Command-Pattern-命令模式：用来给应用添加Undo操作"><a href="#11-The-Command-Pattern-命令模式：用来给应用添加Undo操作" class="headerlink" title="11: The Command Pattern(命令模式：用来给应用添加Undo操作)"></a>11: The Command Pattern(命令模式：用来给应用添加Undo操作)</h2><p>命令模式帮助我们把一个操作(undo,redo,copy,paste等)封装成一个对象，通常是创建一个包含Operation所有逻辑和方法的类。<br>通过命令模式可以控制命令的执行时间和过程，还可以用来组织事务。 用一些文件操作类来说明命令模式的使用</p>
<pre><code>import os

class RenameFile:

    def __init__(self, path_src, path_dest):
        &quot;&quot;&quot; 在init里保存一些必要信息，比如undo需要的老的和新的文件名 &quot;&quot;&quot;
        self.src, self.dest = path_src, path_dest

    def execute(self, verbose=False):
        if verbose:
            print(&quot;[renaming &apos;{}&apos; to &apos;{}&apos;]&quot;.format(self.src, self.dest))
        os.rename(self.src, self.dest)

    def undo(self, verbose=False):
        if verbose:
            print(&quot;[renaming &apos;{}&apos; back to &apos;{}&apos;]&quot;.format(self.dest, self.src))
        os.rename(self.dest, self.src)


def delete_file(path, verbose=False):
    if verbose:
        print(&quot;deleting file &apos;{}&quot;.format(path))
    os.remove(path)


class CreateFile:
    def __init__(self, path, txt=&apos;hello world\n&apos;):
        self.path, self.txt = path, txt

    def execute(self, verbose=False):
        if verbose:
            print(&quot;[creating file &apos;{}&apos;]&quot;.format(self.path))
        with open(self.path, mode=&apos;w&apos;, encoding=&apos;utf-8&apos;) as out_file:
            out_file.write(self.txt)

    def undo(self):
        delete_file(self.path)


class ReadFile:
    def __init__(self, path):
        self.path = path

    def execute(self, verbose=False):
        if verbose:
            print(&quot;[reading file &apos;{}&apos;]&quot;.format(self.path))
        with open(self.path, mode=&apos;r&apos;, encoding=&apos;utf-8&apos;) as in_file:
            print(in_file.read(), end=&apos;&apos;)


def main():
    orig_name, new_name = &apos;file1&apos;, &apos;file2&apos;
    commands = []
    for cmd in CreateFile(orig_name), ReadFile(orig_name), RenameFile(orig_name, new_name):
        commands.append(cmd)
    [c.execute() for c in commands]

    answer = input(&apos;reverse the executed commands? [y/n] &apos;)
    if answer not in &apos;yY&apos;:
        print(&quot;the result is {}&quot;.format(new_name))
        exit()
    for c in reversed(commands):
        try:
            c.undo()   # 执行undo
        except AttributeError:
            pass

main()
</code></pre><hr>
<h2 id="12-The-Interpreter-Pattern-解释器模式：用来实现Domain-Specific-Language-DSL"><a href="#12-The-Interpreter-Pattern-解释器模式：用来实现Domain-Specific-Language-DSL" class="headerlink" title="12: The Interpreter Pattern(解释器模式：用来实现Domain Specific Language(DSL))"></a>12: The Interpreter Pattern(解释器模式：用来实现Domain Specific Language(DSL))</h2><p>本章我们实现一个简单的控制大门Gate类的DSL。使用<a href="http://infohost.nmt.edu/tcc/help/pubs/pyparsing/web/index.html" target="_blank" rel="noopener">pyparsing</a>来解析我们定义的控制大门的语法命令。<br>pyparsing自带了很多有用的函数和类帮助我们从文本中抽取需要的信息，比如我们方便地处理c++源文件中的注释:(<code>pip install pyparsing</code>)</p>
<pre><code>&gt;&gt;&gt; text = &apos;// Look out of the yard? What will we see?&apos;
&gt;&gt;&gt; print pp.cppStyleComment.parseString(text)
[&apos;// Look out of the yard? What will we see?&apos;]
&gt;&gt;&gt; print pp.cppStyleComment.parseString(&apos;/* Author: R. J. Gumby */&apos;)
[&apos;/* Author: R. J. Gumby */&apos;]
</code></pre><p>再比如我们一句话就可以去除C++源码中的注释:</p>
<pre><code>from pyparsing import cppStyleComment
code = &quot;&quot;&quot;
/* Hello World program */

#include&lt;stdio.h&gt;

main()
{
    printf(&quot;Hello World&quot;);    // print hello

}
&quot;&quot;&quot;
print(cppStyleComment.suppress().transformString(code))
</code></pre><p>下面实现我们的控制Gate的DSL</p>
<pre><code>from pyparsing import Word, OneOrMore, Optional, Group, Suppress, alphanums

class Gate:
    def __init__(self):
        self.is_open = False

    def __str__(self):
        return &apos;open&apos; if self.is_open else &apos;closed&apos;

    def open(self):
        print(&apos;opening the gate&apos;)
        self.is_open = True

    def close(self):
        print(&apos;closing the gate&apos;)
        self.is_open = False


def main():
    # 首先定义我们的DSL格式，我们这里最简单的控制语法就是   &quot;open -&gt; gate&quot;
    word = Word(alphanums)
    command = Group(OneOrMore(word))
    token = Suppress(&quot;-&gt;&quot;)
    device = Group(OneOrMore(word))
    argument = Group(OneOrMore(word))
    event = command + token + device + Optional(token + argument)

    gate = Gate()
    cmds = [&apos;open -&gt; gate&apos;, &apos;close -&gt; gate&apos;]    # 两个自定义的命令
    open_actions = {&apos;gate&apos;: gate.open}
    close_actions = {&apos;gate&apos;: gate.close}

    for cmd in cmds:
        print(event.parseString(cmd))    # [[&apos;open&apos;], [&apos;gate&apos;]]
        cmd, dev = event.parseString(cmd)
        cmd_str, dev_str = &apos; &apos;.join(cmd), &apos; &apos;.join(dev)
        print(cmd_str, dev_str)
        if &apos;open&apos; in cmd_str:
            open_actions[dev_str]()
        elif &apos;close&apos; in cmd_str:
            close_actions[dev_str]()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><p>这样就实现了一个简单的大门控制语言，不过功能很弱。</p>
<hr>
<h2 id="13-The-Observer-Pattern-发布订阅模式：用来处理多个对象之间的发布订阅问题"><a href="#13-The-Observer-Pattern-发布订阅模式：用来处理多个对象之间的发布订阅问题" class="headerlink" title="13: The Observer Pattern(发布订阅模式：用来处理多个对象之间的发布订阅问题)"></a>13: The Observer Pattern(发布订阅模式：用来处理多个对象之间的发布订阅问题)</h2><p>如果用过blinker库或者redis的pub，sub，对发布订阅应该会比较熟悉。该模式用在当一个对象的状态变更需要通知其他很多对象的时候，比如rss订阅或者在社交网站上订阅某个频道的更新。事件驱动系统也是一种发布订阅模式，事件作为发布者，监听器作为订阅者，只不过这里多个事件监听器可以监听同一个事件。<br>我们这里实现一个”Data Formatter”来解释发布订阅模式，一种数据可以有多个格式化Formatter，当数据更新的时候，会通知所有的Formatter格式化新的数据。使用继承来实现。</p>
<pre><code>class Publisher:
    def __init__(self):
        self.observers = []

    def add(self, observer):
        if observer not in self.observers:
            self.observers.append(observer)
        else:
            print(&apos;Failed to add : {}&apos;).format(observer)

    def remove(self, observer):
        try:
            self.observers.remove(observer)
        except ValueError:
            print(&apos;Failed to remove : {}&apos;).format(observer)

    def notify(self):
        [o.notify_by(self) for o in self.observers]


class DefaultFormatter(Publisher):
    def __init__(self, name):
        super().__init__()
        self.name = name
        self._data = 0

    def __str__(self):
        return &quot;{}: &apos;{}&apos; has data = {}&quot;.format(
            type(self).__name__, self.name, self._data)

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new_value):
        try:
            self._data = int(new_value)
        except ValueError as e:
            print(&apos;Error: {}&apos;.format(e))
        else:
            self.notify()    # data 在被合法赋值以后会执行notify


class HexFormatter:
    &quot;&quot;&quot; 订阅者 &quot;&quot;&quot;
    def notify_by(self, publisher):
        print(&quot;{}: &apos;{}&apos; has now hex data = {}&quot;.format(
            type(self).__name__, publisher.name, hex(publisher.data)))


class BinaryFormatter:
    &quot;&quot;&quot; 订阅者 &quot;&quot;&quot;
    def notify_by(self, publisher):
        print(&quot;{}: &apos;{}&apos; has now bin data = {}&quot;.format(
            type(self).__name__, publisher.name, bin(publisher.data)))


if __name__ == &quot;__main__&quot;:
    df = DefaultFormatter(&apos;test1&apos;)
    print(df)
    print()
    hf = HexFormatter()
    df.add(hf)
    df.data = 3
    print(df)

    print()
    bf = BinaryFormatter()
    df.add(bf)
    df.data = 21
    print(df)
</code></pre><hr>
<h2 id="14-The-State-Pattern-状态模式：实现有限状态机"><a href="#14-The-State-Pattern-状态模式：实现有限状态机" class="headerlink" title="14: The State Pattern(状态模式：实现有限状态机)"></a>14: The State Pattern(状态模式：实现有限状态机)</h2><blockquote>
<p>A state machine is an abstract machine that has two key components: states and transitions. A state is the current (active) status of a system. A transition is the switch from one state to another. A state meachine has only one active state at a specific point in the time.<br>我们通过实现操作系统中进程的生命周期来演示状态模式的使用：</p>
</blockquote>
<pre><code># 先装下pip3 install state_machine
from state_machine import (
acts_as_state_machine, State, Event, before, after, InvalidStateTransition
)


@acts_as_state_machine
class Process:
    # 先来定义状态机的状态 states
    created = State(initial=True)    # 初始状态
    waiting = State()
    running = State()
    terminated = State()
    blocked = State()
    swapped_out_waiting = State()
    swapped_out_blocked = State()

    # 再定义状态机的转移 transitions
    wait = Event(from_states=(created, running, blocked,
                            swapped_out_waiting), to_state=waiting)
    run = Event(from_states=waiting, to_state=running)
    terminate = Event(from_states=running, to_state=terminated)
    block = Event(from_states=(running, swapped_out_blocked),
                to_state=blocked)
    swap_wait = Event(from_states=waiting, to_state=swapped_out_waiting)
    swap_block = Event(from_states=blocked, to_state=swapped_out_blocked)

    def __init__(self, name):
        self.name = name

    # The state_machine module provides us with the @before and @after
    # decorators that can be used to execute actions before or after a
    # transition occurs, respectfully.
    @after(&apos;wait&apos;)
    def wait_info(self):
        print(&apos;{} entered waiting mode&apos;.format(self.name))

    @after(&apos;run&apos;)
    def run_info(self):
        print(&apos;{} is running&apos;.format(self.name))

    @before(&apos;terminate&apos;)
    def terminate_info(self):
        print(&apos;{} terminated&apos;.format(self.name))

    @after(&apos;block&apos;)
    def block_info(self):
        print(&apos;{} is blocked&apos;.format(self.name))

    @after(&apos;swap_wait&apos;)
    def swap_wait_info(self):
        print(&apos;{} is swapped out and waiting&apos;.format(self.name))

    @after(&apos;swap_block&apos;)
    def swap_block_info(self):
        print(&apos;{} is swapped out and blocked&apos;.format(self.name))


def transition(process, event, event_name):
    &quot;&quot;&quot;
    Args:
        process (Process obj):
        event (Event obj): wait, run, terminate...
        event_name (str): name of event
    &quot;&quot;&quot;
    try:
        event()
    except InvalidStateTransition:
        print(&apos;Error: transition of {} from {} to {} failed&apos;.format(
            process.name, process.current_state, event_name))


def state_info(process):
    &quot;&quot;&quot; 当前状态机的状态 &quot;&quot;&quot;
    print(&apos;state of {}: {}&apos;.format(process.name, process.current_state))

if __name__ == &quot;__main__&quot;:
    RUNNING = &apos;running&apos;
    WAITING = &apos;waiting&apos;
    BLOCKED = &apos;blocked&apos;
    TERMINATED = &apos;terminated&apos;
    p1, p2 = Process(&apos;process1&apos;), Process(&apos;process2&apos;)
    [state_info(p) for p in (p1, p2)]

    print()
    transition(p1, p1.wait, WAITING)
    transition(p2, p2.terminate, TERMINATED)
    [state_info(p) for p in (p1, p2)]
    print()
    transition(p1, p1.run, RUNNING)
    transition(p2, p2.wait, WAITING)
    [state_info(p) for p in (p1, p2)]
    print()
    transition(p2, p2.run, RUNNING)
    [state_info(p) for p in (p1, p2)]
    print()
    [transition(p, p.block, BLOCKED) for p in (p1, p2)]
    [state_info(p) for p in (p1, p2)]
    print()
    [transition(p, p.terminate, TERMINATED) for p in (p1, p2)]
    [state_info(p) for p in (p1, p2)]
</code></pre><hr>
<h2 id="15-The-Strategy-Pattern-策略模式：动态选择算法策略"><a href="#15-The-Strategy-Pattern-策略模式：动态选择算法策略" class="headerlink" title="15: The Strategy Pattern(策略模式：动态选择算法策略)"></a>15: The Strategy Pattern(策略模式：动态选择算法策略)</h2><p>现实中往往解决问题的方式不止一种，我们可能需要根据问题的特征选择最优的实现策略，以排序算法为例子，挑选一个合适的排序算法的时候，需要考虑待排序数组的以下特征：</p>
<ul>
<li>元素个数。算法输入规模，大部分排序算法在输入规模很小的时候效率相差不大，只有一部分nlogn平均时间复杂度的适合排序大规模。</li>
<li>最好/平均/最坏时间复杂度.这个往往是挑选排序算法时候优先考虑的。</li>
<li>空间复杂度。是不是原地排序(inplace),需要额外的空间吗？在内存限制苛刻的时候就需要考虑</li>
<li>稳定性。排序算法是稳定的吗？稳定是指相同大小的值排序后保持相对顺序。</li>
<li>实现复杂度。算法是否容易实现，其他大致相同的情况下，优先考虑易维护的代码。</li>
</ul>
<p>策略模式允许我们根据待处理数据的特征灵活选用当前特征下最优的实现，比如常见库的排序算法一般都是混合了多种排序算法的实现，python使用的是Tim Peters在2002年设计的结合了合并排序和插入排序的<a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener">Timsort</a>.<br>函数在python里是一等公民，可以简化策略模式的实现。</p>
<pre><code>def f1(seq):
    pass

def f2(seq):
    pass

def f(seq):
    if len(seq) &gt;= threshold_value:    # 大于某个阈值
        f1(seq)    # 在数量较多时候具有良好的效率
    else:
        f2(seq)
</code></pre><hr>
<h2 id="16-The-Template-Pattern-模板模式：抽象出算法公共部分从而实现代码复用"><a href="#16-The-Template-Pattern-模板模式：抽象出算法公共部分从而实现代码复用" class="headerlink" title="16: The Template Pattern(模板模式：抽象出算法公共部分从而实现代码复用)"></a>16: The Template Pattern(模板模式：抽象出算法公共部分从而实现代码复用)</h2><blockquote>
<p>Don’t repeat yourself.<br>模板模式中，我们可以把代码中重复的部分抽出来作为一个新的函数，把可变的部分作为函数参数，从而消除代码冗余。实际上这种模式在代码重构的时候是经常使用的 ，使用一个有意思的例子来说明下，请安装<code>pip install cowpy</code>，真有人闲的*疼写这个玩意</p>
</blockquote>
<pre><code>from cowpy import cow


def dots_style(msg):
    msg = msg.capitalize()
    msg = &apos;.&apos; * 10 + msg + &apos;.&apos; * 10
    return msg


def admire_style(msg):
    msg = msg.upper()
    return &apos;!&apos;.join(msg)


def cow_style(msg):
    msg = cow.milk_random_cow(msg)
    return msg


def generate_banner(msg, style=dots_style):
    print(&apos;-- start of banner --&apos;)
    print(style(msg))
    print(&apos;-- end of banner --\n\n&apos;)


def main():
    msg = &apos;happy coding&apos;
    [generate_banner(msg, style) for style in (dots_style, admire_style,
                                            cow_style)]

if __name__ == &quot;__main__&quot;:
    main()


&quot;&quot;&quot;
-- start of banner --
..........Happy coding..........
-- end of banner --


-- start of banner --
H!A!P!P!Y! !C!O!D!I!N!G
-- end of banner --


-- start of banner --
______________
&lt; happy coding &gt;
--------------
    o
    o
    ^__^         /
    (**)\_______/  _________
    (__)\       )=(  ____|_ \_____
U    ||----w |  \ \     \_____ |
        ||     ||   ||           ||
-- end of banner --
&quot;&quot;&quot;
</code></pre><hr>
<h2 id="单例模式-使得一个类最多生成一个实例。"><a href="#单例模式-使得一个类最多生成一个实例。" class="headerlink" title="单例模式: 使得一个类最多生成一个实例。"></a>单例模式: 使得一个类最多生成一个实例。</h2><blockquote>
<p>Design ptterns are discoverd, not invented. - Alex Martelli</p>
</blockquote>
<p>很奇怪，本书讲完了都没有讲到单例模式。python的单例模式有各种实现，元类、装饰器等，但是还有一种说法：</p>
<blockquote>
<p>I don’t really see the need, as a module with functions (and not a class) would serve well as a singleton. All its variables would be bound to the module, which could not be instantiated repeatedly anyway.  If you do wish to use a class, there is no way of creating private classes or private constructors in Python, so you can’t protect against multiple instantiations, other than just via convention in use of your API. I would still just put methods in a module, and consider the module as the singleton.</p>
</blockquote>
<p>也就是说，实际上，python中，如果我们只用一个实例，直接这么写就行</p>
<pre><code># some module.py
class SingletonClass:
    pass

# 在别处我们想用这个实例都直接使用 module.single_instance 这个实例就好。
# 这是最简单也是最直观的一种方式,嗯，直接导入这个实例用，而不是导入class，简单粗暴
single_instance = SingletonClass()
</code></pre><p><a href="http://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons-in-python" target="_blank" rel="noopener">Is there a simple, elegant way to define singletons in Python? [closed]</a></p>
<p>其他实现：</p>
<pre><code># http://stackoverflow.com/questions/6760685/creating-a-singleton-in-python
class BaseClass:
    pass


# 装饰器实现
def singleton(class_):
    instances = {}
    def getinstance(*args, **kwargs):
        if class_ not in instances:
            instances[class_] = class_(*args, **kwargs)
        return instances[class_]
    return getinstance


@singleton
class MyClass(BaseClass):
    pass


class Singleton(object):
    _instance = None
    def __new__(class_, *args, **kwargs):
        if not isinstance(class_._instance, class_):
            class_._instance = object.__new__(class_, *args, **kwargs)
        return class_._instance


class MyClass(Singleton, BaseClass):
pass


# 元类实现
class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


# Python2
class MyClass(BaseClass):
    __metaclass__ = Singleton

# Python3
class MyClass(BaseClass, metaclass=Singleton):
    pass
</code></pre><hr>
<h2 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h2><p>设计模式讲完了，来看看python中OOP的相关东西。笔者在经历过的两家公司见到过各种python程序员，之前的公司有python高手习惯写OOP风格的(给我很深影响)，目前所在公司大部分人对python的面向对象不是很熟，写出来的基本都是过程式的。</p>
<ul>
<li>过程式: 基本都是一个个函数(function)来实现功能，你给我一些参数，我对参数做出各种操作，返回需要的结果。</li>
<li>面向对象：把资源抽象成一个类，数据(data)和方法(method)的集合。在构造函数中进行数据属性的初始化，在方法中进行对象数据的各种操作。</li>
</ul>
<p>哪种方式更好这个我暂时没有定论，编程规范也不会说强制你使用哪种风格。编码中往往没有绝对正确的，只有相对更优的，如果不好定论，那就一致，易读，易用，易维护的风格优先。一般来说，能用函数实现的优先使用函数，相比类更简单易维护。如果多个过程共享一些状态（操作+数据），这时候使用类就比较适合。使用类的时候尽量保持继承层级简单，如果同样可以完成功能，优先使用组合而非继承。</p>
<hr>
<h2 id="python中的抽象基类"><a href="#python中的抽象基类" class="headerlink" title="python中的抽象基类"></a>python中的抽象基类</h2><p>在python中我们可以使用内置的abc(abstract base class)模块来实现抽象基类。什么时候需要一个抽象基类呢？</p>
<ul>
<li>抽象基类是没法被实例化的。</li>
<li>抽象基类中定义抽象方法强制子类去实现。</li>
</ul>
<pre><code># 为了实现这两个特性，我们可以这么写
class Base:
    def foo(self):
        raise NotImplementedError()

    def bar(self):
        raise NotImplementedError()

class Concrete(Base):
    def foo(self):
        return &apos;foo() called&apos;

    # Oh no, we forgot to override bar()...
    # def bar(self):
    #     return &quot;bar() called&quot;
</code></pre><p>但是这么写依然可以实例化Base，python2.6以后引入了abc模块帮助我们实现这个功能。</p>
<pre><code>from abc import ABCMeta, abstractmethod

class Base(metaclass=ABCMeta):
    @abstractmethod
    def foo(self):
        pass

    @abstractmethod
    def bar(self):
        pass

class Concrete(Base):
    def foo(self):
        pass
    # We forget to declare bar() again...
</code></pre><p>使用这种方式如果没有在子类里实现bar方法你是没有办法实例化子类的。</p>
<p><a href="https://dbader.org/blog/abstract-base-classes-in-python" target="_blank" rel="noopener">《Abstract Base Classes in Python》</a></p>
<p><a href="http://stackoverflow.com/questions/3570796/why-use-abstract-base-classes-in-python" target="_blank" rel="noopener">《http://stackoverflow.com/questions/3570796/why-use-abstract-base-classes-in-python》</a></p>
<p><a href="https://docs.python.org/2/library/abc.html" target="_blank" rel="noopener">《https://docs.python.org/2/library/abc.html》</a></p>
<hr>
<h2 id="python中的Mixin"><a href="#python中的Mixin" class="headerlink" title="python中的Mixin"></a>python中的Mixin</h2><p>Mixin是为了给一个类扩充功能用的，它也没法被实例化。我们可以在Mixin类里实现一些方法给类扩充功能。你可能会问了，那为啥不直接写在类里头，比如用@staticmethod方法？我的理解是这样的，为了『高内聚』。如果你用过pylint检测代码，你会发现你在写类的一个方法时，如果在写一个method时没有使用到任何self里的东西，pylint会给提示『R0201 Method could be a function [pylint]』，意思是这个方法可以可以单独写成一个函数，不必要写在类里。也就是说，只有一个类里实现的方法都是使用了self里的数据时才能成为高内聚的（我不知道我这样理解对不对）。例子：flask_login插件有个UserMixin给定义的用户类实现登录功能。</p>

      
    </div>
    <footer>
      
          
          <div class="clearfix"></div>
          <nav id="pagination">
  
    <a href="/2017/01/06/python/getting-started-with-pyparsing/" class="alignleft prev"><i class="fa fa-long-arrow-left"></i>Next</a>
  
  
    <a href="/2016/12/30/python/write-maintainable-python-project/" class="alignright next">Prev<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
</section>



    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2018 PegasusWang
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="noopener">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="noopener">GitHub Pages</a>

<div class="clearfix"></div>


<!--
<span id="busuanzi_container_site_pv">
    您是第<span id="busuanzi_value_site_pv"></span>次访问滴童鞋
</span>

<script async
src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
-->
</footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>




<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>