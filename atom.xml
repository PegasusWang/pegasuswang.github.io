<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pegasus&#39; Blog</title>
  
  <subtitle>保持一颗好奇心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ningning.today/"/>
  <updated>2018-07-25T01:14:46.000Z</updated>
  <id>http://ningning.today/</id>
  
  <author>
    <name>PegasusWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开了俩 vim 和 Python 的知乎专栏</title>
    <link href="http://ningning.today/2018/07/25/web/%E5%BC%80%E4%BA%86%E4%BF%A9%E7%9F%A5%E4%B9%8E%E4%B8%93%E6%A0%8F/"/>
    <id>http://ningning.today/2018/07/25/web/开了俩知乎专栏/</id>
    <published>2018-07-25T00:51:09.000Z</published>
    <updated>2018-07-25T01:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>First, solve the problem. Then, write the code. - John Johnson</p></blockquote><p>很久没有更新自己的博客了，最近编写和录制了一些 vim 和 python 的视频教程，感兴趣的可以看看，奉上链接。</p><a id="more"></a><p>以下是我的一些博客链接，还有写的一些小书，自己记性不太好，习惯用 mkdos+readthedocs<br>工具来记录，好处就是可以直接发表在网上成为电子书，方便自己查看和别人参考，文档都是基于<br>markdown，可以使用自己喜欢的编辑器编写，同时也能用 git 进行版本管理。（缺点是不如笔记软件功能那么丰富）</p><ul><li><p><a href="https://zhuanlan.zhihu.com/python-web" target="_blank" rel="noopener">Python学习之路(视频)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/vim-video" target="_blank" rel="noopener">玩转 vim 与 Terminal (视频)</a></p></li><li><p><a href="http://python-web-guide.readthedocs.io/zh/latest/" target="_blank" rel="noopener">Python Web 入坑指南</a></p></li><li><p><a href="http://study.163.com/course/courseMain.htm?courseId=1005526003&amp;share=2&amp;shareId=400000000496051" target="_blank" rel="noopener">Python数据结构与算法教程</a></p></li><li><p><a href="https://github.com/PegasusWang/python_data_structures_and_algorithms&lt;Paste" target="_blank" rel="noopener">python_data_structures_and_algorithms github课件</a></p></li><li><p><a href="https://pegasuswang.readthedocs.io/en/latest/" target="_blank" rel="noopener">读书笔记</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;First, solve the problem. Then, write the code. - John Johnson&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很久没有更新自己的博客了，最近编写和录制了一些 vim 和 python 的视频教程，感兴趣的可以看看，奉上链接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim, python" scheme="http://ningning.today/tags/vim-python/"/>
    
  </entry>
  
  <entry>
    <title>职场小白指数基金懒人定投指南</title>
    <link href="http://ningning.today/2018/01/14/%E7%90%86%E8%B4%A2/%E8%81%8C%E5%9C%BA%E5%B0%8F%E7%99%BD%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%87%92%E4%BA%BA%E5%AE%9A%E6%8A%95%E6%8C%87%E5%8D%97/"/>
    <id>http://ningning.today/2018/01/14/理财/职场小白指数基金懒人定投指南/</id>
    <published>2018-01-14T09:33:58.000Z</published>
    <updated>2018-01-21T02:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>复利是世界第八大奇迹 - 爱因斯坦</p></blockquote><p>如果你和我一样是个职场小白，没什么存款，也不想费心研究基金啦、股票这些东西，又感觉钱放银行或者余额宝没啥收益，可以试试低估指数基金定投的方式，简单易学亲测有效。</p><a id="more"></a><hr><h1 id="实战效果"><a href="#实战效果" class="headerlink" title="实战效果"></a>实战效果</h1><p>基金说白了就是咱不会炒股，就把钱给人家专业的基金经理，让他们玩，当然得叫手续费。 笔者有幸在实习的时候跟着一位很懂金额的工程师，了解到一些投资理财的东西，自己的风险承受能力偏低，也不敢碰比特币这玩意。所以选择了风险比较小的指数基金定投的方式，话不多说上实战结果：<br>有些基金收益好的有 20% 多，远远超过银行储蓄和余额宝。</p><p><img src="http://7ktuty.com1.z0.glb.clouddn.com/jijin1.png" alt=""><br><img src="http://7ktuty.com1.z0.glb.clouddn.com/jijin2.png" alt=""></p><hr><h1 id="傻瓜操作方式"><a href="#傻瓜操作方式" class="headerlink" title="傻瓜操作方式"></a>傻瓜操作方式</h1><ul><li>下载蚂蚁财富，可以直接在里边买基金。有绑定银行卡或者支付宝就行。</li><li>关注公众号『银行螺丝钉』，这个雪球大v每天更新指数基金估值，在绿色地区的是低估值基金，可以直接选择其中几个定投，直接去蚂蚁财富搜对应的基金代号就可以。他还写过一本书《指数基金投资指南》，可以看看。</li><li>每周或者每月操作一次，把闲钱买入基金就行。实测有效。可以根据涨跌适当调整金额。</li></ul><hr><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul><li>为什么不炒股？</li></ul><p>职场新人提升职业技能比较重要，没时间研究股票，主要是也没啥兴趣</p><ul><li>为什么不买股票基金？</li></ul><p>不好选，指数基金比较好评估。低估值买入，高估卖出。一开始学习基金的时候买过股票基金亏了不少，还是老老实实买指数基金。股票基金比较依赖基金经理的操作水平，选股能力，等有一定基础了可以这么玩。</p><ul><li>投资心理？</li></ul><p>都说了懒人定投，不要经常看是涨是跌，更不要追涨杀跌。老实定投就行，适当根据估值来调整每次定投的金额。</p><ul><li>何时买入和卖出？</li></ul><p>看估值，低估值买入或者持有，正常估值持有，高估了就卖。银行螺丝钉的图里有对应的绿色、黄色、红色区间。记住千万不要看到跌了就心慌，定投就是为了分摊成本，跌了一样的钱就能买入更多份额。</p><ul><li>一定能挣钱吗？</li></ul><p>大概率。不过怂恿一些家人买，但是他们心理状态不好(承受不了损失)、要不就是无法遵守纪律(三天打鱼两天晒网)，最终可能还是会亏。 现在笔者心态也已经练出来了，哪怕一天少个几千块也没啥感觉了。主要就是调整心态，遵守纪律。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>祝大家早日攒够老婆本。当然你挣钱了我捞不到一毛，损失了我可能还要挨骂，如果你姿势不对，不要来找我就行。<br>再此感谢雪球大V 银行螺丝钉，挣了点小钱就当给人软广吧，反正人也不认识我。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;复利是世界第八大奇迹 - 爱因斯坦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你和我一样是个职场小白，没什么存款，也不想费心研究基金啦、股票这些东西，又感觉钱放银行或者余额宝没啥收益，可以试试低估指数基金定投的方式，简单易学亲测有效。&lt;/p&gt;
    
    </summary>
    
      <category term="理财" scheme="http://ningning.today/categories/%E7%90%86%E8%B4%A2/"/>
    
    
      <category term="基金" scheme="http://ningning.today/tags/%E5%9F%BA%E9%87%91/"/>
    
  </entry>
  
  <entry>
    <title>Python 项目工程实践</title>
    <link href="http://ningning.today/2018/01/13/python/python-engineering/"/>
    <id>http://ningning.today/2018/01/13/python/python-engineering/</id>
    <published>2018-01-13T01:50:04.000Z</published>
    <updated>2018-01-13T04:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态语言一时爽，代码重构火葬场</p></blockquote><p>随着公司产品周期迭代和业务发展，使用 python 这种动态语言开发慢慢也暴露出一些问题，比如性能低、易出错、难重构、难维护等。 网上大部分是技术相关文章，工程相关的比较少。笔者就之前几年写 python 和维护 python 后端项目的经验简单介绍下如何提升 python 项目工程质量。</p><a id="more"></a><hr><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>很多创业公司初期为了市场竞争，产品快速迭代，使用了 python，ruby 之类的动态语言开发，动态语言的优势在于表达能力强，比较灵活，初期开发的时候速度比较快。如果公司顺利活下来，之后产品会更加注重性能、稳定性等，这个时候动态语言的缺点也开始慢慢暴露起来。有时候换语言和架构的成本是巨大的，而且很多场景也没必要更换（比如 Instagram 一直用的 python，都优化到了解释器级别，当然国内大部分公司没这个能力），我们尽量通过工程手段来控制项目质量，对动态语言扬长避短，更愉快地做项目。</p><hr><h1 id="知乎为什么继续用-python"><a href="#知乎为什么继续用-python" class="headerlink" title="知乎为什么继续用 python"></a>知乎为什么继续用 python</h1><p>出于以下几点原因吧：</p><ul><li>历史遗留问题，大量 python 项目</li><li>写起来爽，做业务初期开发速度快</li><li>基础设施支持比较完善</li><li>有不少懂 python 的程序员</li><li>大部分项目 IO 密集，初期使用 python 不会遇到性能问题</li></ul><p>目前来看只有少数非常吃性能的项目用 golang 重写(golang 在并发和工程上非常不错)，大部分场景 Python 够用，而且有时候新项目老板给的时间太短，换个技术栈还真不一定快速把业务做出来（少加班）</p><hr><h1 id="为什么要重视代码和工程质量"><a href="#为什么要重视代码和工程质量" class="headerlink" title="为什么要重视代码和工程质量"></a>为什么要重视代码和工程质量</h1><p>笔者这几年经历过各种 python 项目，见识过很多 python 程序员。之前维护过一些比较难以上手的代码仓库（无文档、无注释、无规范、风格混乱）等，深知一个恶心的代码仓库多么要人命。 实际上当初写 <a href="http://python-web-guide.readthedocs.io/zh/latest/index.html" target="_blank" rel="noopener">python web 入坑指南</a> 并不是出于什么高尚的目的，只是实在受不了难以维护的 python 项目，把很多问题都总结了一下。</p><ul><li>方便新手和团队其他成员快速熟悉代码</li><li>减少 bug，降低在修 bug 上的时间浪费</li><li>方便业务快速迭代，兼顾开发效率（减少无意义加班吧）</li></ul><p>很多时候一开始写代码只是很小一块，后来维护、修改 bug、增加新需求等，如果代码写得糙，后期修改成本就会很高。</p><hr><h1 id="动态语言做工程的缺点"><a href="#动态语言做工程的缺点" class="headerlink" title="动态语言做工程的缺点"></a>动态语言做工程的缺点</h1><p>主要有以下一些问题：</p><ul><li>解释性语言执行效率低，大部分时间用在 IO 密集场景，比如 web 后端</li><li>开发工具支持不够完善，不如 java 有那么完善的 IDE</li><li>难以重构。基本上重构只能依据字符串匹配，老实说每次重构有稍微大一些的改动都会有点担心</li><li>滥用动态特性导致代码不好维护。这是个双刃剑，但是对工程来说还是不要滥用</li><li>没有类型声明，看不出一些复杂类型的数据结构（Python、php 都在不遗余力地加上 type hint）</li><li>缺少一些最佳实践（技术、小白文章偏多，工程实践文章比较少）</li></ul><p>笔者当时选择去做 python 后端也是因为比较喜欢 python 语言，轮子多、生产力高、写起来爽等，但是一旦开始真正项目协作的时候，很多问题也必须要重视（不仅仅是技术问题）。 下面从开发环境、工具、流程、规范等问题上总结下如何提升工程质量吧。</p><hr><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>最好统一每个开发人员的开发环境，当然我们不能强制要求所有人都用一样的操作系统和编辑器、IDE 等，但是有些小问题还是比较麻烦的，比如不同系统的编码、编辑器的 tab 空格、自动换行等。笔者当初实习的时候团队里所有人都是登录到服务器上用 vim 写代码的，环境比较统一，现在基本大家都是 mac，一致的环境。当团队每个人用不同的工具的时候，可以采用以下一些工具来构建统一开发和编辑环境。</p><ul><li><a href="http://editorconfig.org/" target="_blank" rel="noopener">EditorConfig</a>: 用来统一编辑器配置。如果成员用不同的操作系统和编辑器，建议使用。尤其是对于<br>python 这种使用缩进的语言。需要编辑器安装相应的插件，并且配置一个共同的配置文件加入到版本库（可以配置编码、缩进等）</li><li>Vagrant: 一款用于构建及配置虚拟开发环境的软件，基于Ruby, 主要以命令行的方式运行(没实战过)</li><li>buildout: 知乎在用，把依赖包等安装到当前项目下。这样可以不用 virtualenv 之类的环境</li><li>pienv/virtualenv: 构建 python 虚拟环境，之前没用 buildout 之前都是使用 virtualenv 构建本地开发环境</li><li><a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="noopener">cookiecutter</a>: 项目模板生成工具，每个项目最好用统一的模板生成，防止各个项目都是不同的风格，同时也能快速启动新项目。（知乎内部有自己的生成模板）</li></ul><hr><h1 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h1><p>一般来说都是遵守 pep8，适当放宽下行长度限制，比如 120 列。如果有成员不使用 IDE，应当在其编辑器里加上对应的 pep8<br>检测插件。</p><ul><li>autopep8: 可以集成在很多开发工具里，尽量都用工具来格式化，避免风格不一致的问题。</li><li>isort: 整理 python 包导入顺序，支持自定义配置，不用每次都费劲想着如何按照 pep8 顺序导入</li><li>pylint: 静态检测，能检测出很多代码缺陷和不合规范的地方，笔者强烈推荐。最好集成到 CI 构建工具里。默认的 pylint<br>检测过于严格，我们可以自定义忽略一些提示，可以参考这个 <a href="https://github.com/PegasusWang/linux_config/blob/master/pylintrc" target="_blank" rel="noopener">pylintrc</a> 文件</li></ul><p>我个人的想法就是尽量能用工具做的就不要让人去做，工具能保证风格统一，减少出错可能，让我们把更多精力放在业务逻辑而不是调整格式上。项目大了以后代码的格式和排版等是很能影响开发心情的。笔者个人用的是 vim 的 python-mode 插件，基本上这些工具都支持，笔者写代码的时候格式也比较随意，只是改完文件后执行下 autopep8 和 isort，一切就又整洁了(类似于 golang 的 gofmt)。感兴趣的可以自己试试。</p><hr><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>这个之前总结过很多用过的工具，感兴趣的看看 <a href="http://python-web-guide.readthedocs.io/zh/latest/codingtools/codingtools.html" target="_blank" rel="noopener">开发和编程工具</a></p><hr><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>很多公司慢慢把版本控制迁移到了 git，使用 gitlab 管理代码项目。一般我们的 git 开发流程是这样的：</p><ul><li>fork 一份代码仓库</li><li>本地新建代码分支开发新功能、修 bug 等</li><li>开发完成后提交 merge request，有其他成员进行 code review。注意 commit 信息不能太随意，一般我们有一些提交模板</li><li>确认代码没问题合并到主干，每次构建都会执行单测、pylint 检测等</li></ul><p>基本上这套 git 工作流程比较简单，目前也出过什么大问题。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每种语言都有自己的优势劣势，适用场景，通过规范、流程、工具等尽量提升我们的开发、协作效率、工程质量，争取更愉快地开发，减少无意义的加班。</p><blockquote><p>Life is short, You need Python</p></blockquote><hr><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h1><p><a href="http://python-web-guide.readthedocs.io/zh/latest/codingstyle/codingstyle.html" target="_blank" rel="noopener">编码之前碎碎念(工程实践)</a></p><p><a href="http://python.jobbole.com/87814/" target="_blank" rel="noopener">Python + Django 如何支撑了 7 亿月活用户的 Instagram？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;动态语言一时爽，代码重构火葬场&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着公司产品周期迭代和业务发展，使用 python 这种动态语言开发慢慢也暴露出一些问题，比如性能低、易出错、难重构、难维护等。 网上大部分是技术相关文章，工程相关的比较少。笔者就之前几年写 python 和维护 python 后端项目的经验简单介绍下如何提升 python 项目工程质量。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://ningning.today/categories/python/"/>
    
    
      <category term="python, 软件工程" scheme="http://ningning.today/tags/python-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>《Fluent Python》杂记</title>
    <link href="http://ningning.today/2017/12/10/python/fluent-python-note/"/>
    <id>http://ningning.today/2017/12/10/python/fluent-python-note/</id>
    <published>2017-12-10T13:45:32.000Z</published>
    <updated>2017-12-10T13:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python is a language for consenting adults. —Alan Runyan</p></blockquote><p>重新看了下 《Fluent Python》，依旧还是很多东西没能消化完。简单记录下吧</p><a id="more"></a><h1 id="1-Python-数据模型"><a href="#1-Python-数据模型" class="headerlink" title="1.Python 数据模型"></a>1.Python 数据模型</h1><p>Python data model<br>可以看下 python 文档关于 data model 的讨论</p><h1 id="2-序列构成的数组"><a href="#2-序列构成的数组" class="headerlink" title="2. 序列构成的数组"></a>2. 序列构成的数组</h1><p>容器序列(存放引用)：list、tuple、collections.deque<br>扁平序列（存放值）：str、bytes、bytearray、memoryview、array.array</p><p>python2.7 列表推导有变量泄露问题，所以推导的临时变量不要和外部重名</p><p>python运行原理可视化: <a href="http://www.pythontutor.com" target="_blank" rel="noopener">www.pythontutor.com</a></p><pre><code>t = (1, 2, [1,2])t[2] += [1,2]    # t 变成 (1, 2, [1,2,1,2]) 同时抛出异常，用dis模块查看# t[2].extend([1,2]) 没问题</code></pre><p>尽量不要把可变类型放在 tuple 里;增量赋值不是原子的；<br><code>+= *=</code> 对于可变和不可变对象区分对待，不可变对象会生成新对象（str除外,cpython优化过）</p><p>python 使用的排序算法 Timsort 是稳定的<br>内存视图：memoryview:让用户在不复制内容的情况下操作同一个数组的不同切片。</p><p>collections.deque 线程安全</p><h1 id="3-字典和集合"><a href="#3-字典和集合" class="headerlink" title="3 字典和集合"></a>3 字典和集合</h1><p>可散列：如果一个对象是可散列的，在这个对象的生命周期中， 它的散列值是不变的。而且需要实现<code>__hash__</code>,<code>__eq__</code></p><pre><code>class StrKeyDict0(dict):    &quot;&quot;&quot;如果一个类继承了dict，然后这个集成类提供了__missing__方法，    那么__getitem__找不到键的时候，会自动调用它，而不是抛出Keyerror    &quot;&quot;&quot;    def __missing__(self, key):        if isinstance(key, str):    # 如果 str 的 key 还找不到就抛出 KeyError，没有这句会无限递归            raise KeyError(key)        return self[str(key)]    def get(self, key, default):        try:            return self[key]        except KeyError:    # 说明 __missing__ 也失败了            return default    def __contains__(self, key):        &quot;&quot;&quot;这个方法也是必须的，因为继承来的  __contains__ 没有找到也会去掉用__missing__&quot;&quot;&quot;        return key in self.keys() or str(key) in self.keys()</code></pre><p>dict 变种：</p><ul><li>collections.OrderedDict: 保持 key 的顺序</li><li>collections.ChainMap: 容纳多个不同的映射对象</li><li>collections.Counter: 计数器</li><li>collections.UserDict : 其实就是把标准 dict 用纯 python 实习一遍</li></ul><pre><code>import UserDictclass StrKeyDict(UserDict):    def __missing__(self, key):        if isinstance(key, str):    # 如果 str 的 key 还找不到就抛出 KeyError，没有这句会无限递归            raise KeyError(key)        return self[str(key)]    def __setitem__(self, key, item):        self.data[str(key)] = item    def __contains__(self, key):        return str(key) in self.data</code></pre><p>不可变映射类型： types.MappingProxyType  (&gt;=python3.3)</p><p>不要在迭代字段和set 的同时修改它。可以先迭代获取需要的内容后放到一个新的dict里。<br>dict 实现是稀疏列表。</p><p>dict特点：</p><ul><li>元素可散列</li><li>内存开销大</li><li>键查询很快</li><li>键次序取决于添加顺序</li><li>往字典里添加新键可能会改变已有键的顺序</li></ul><p>set特点：</p><ul><li>元素必须可散列</li><li>消耗内存</li><li>高效判断是否存在一个元素</li><li>元素次序取决于添加顺序</li><li>往字典里添加新元素可能会改变已有元素的次序</li></ul><h1 id="4-文本和字节序列"><a href="#4-文本和字节序列" class="headerlink" title="4 文本和字节序列"></a>4 文本和字节序列</h1><blockquote><p>人类使用文本，计算机使用字节序列</p></blockquote><p>字符的标识（码位），十进制数字，在unicode 中以4-6个十六进制数字表示<br>字符的具体表示取决于使用的编码，编码是在码位和字节序列之间转换时使用的算法<br>编码：码位-&gt; 字节序列<br>解码：字节序列 -&gt; 码位</p><p>Unicode 三明治：我们可以用一个简单的原则处理编码问题： 字节序列-&gt;字符串-&gt;字节序列。就是说程序中应当仅处理字符串，当需要保存到文件系统或者传输的时候，编码为字节序列</p><p>BOM：用来标记字节序</p><p>UnicodeEncodeError：字符串转成二进制序列。文本转成字节序列时，如果目标编码没有定义某个字符就会抛异常</p><p>UnicodeDecodeError: 二进制转成字符串。遇到无法转换的字节序列</p><p>chardet 检测文件编码</p><p>处理文本：在多系统中运行的代码需要指定打开和写入的编码，不要依赖默认的编码。除非想判断编码，否则不要在二进制模式中打开文本文件。</p><p>使用 unicodedata.normalize 函数对 unicode 规范化（标准等价物）。保存文本之前用 normalize(‘NFC’, user_text) 清洗字符串</p><p>Unicode 排序：unicode collation algorith, UCA  使用 PyUCA 库。</p><p>双模式 API：根据接受的参数是字节序列或字符串自动处理。re 和 os 模块</p><p>cpython 16 位窄构建(narrow build)  32 位宽构建 (wild build) sys.maxunicode。窄构建无法处理 U+FFFF 以上码位</p><h1 id="5-一等函数"><a href="#5-一等函数" class="headerlink" title="5 一等函数"></a>5 一等函数</h1><p>高阶函数（higher-order function): 接受函数作为参数，或者把函数作为结果返回的函数。比如 map,filter,reduce 等（大部分可以被列表推导替代）</p><p>匿名函数：lambda 用于创建匿名函数。不过 lambda 定义体中无法赋值，也无法使用 while, try 等python 语句</p><p>可调用对象：内置的 callable() 函数判断是否可以调用</p><p>用户定义的可调用类型：任何 python 对象只要是先了 <code>__call__</code> 方法都可以表现得像函数</p><p>函数内省：使用 inspect 模块提取函数的签名、参数等</p><p>python3 函数注解： <code>def clip(text:str, max_len:&#39;int &gt; 0&#39;=80) -&gt; str:</code> 注解会存储在 函数的 <code>__annotations__</code>(一个dict) 属性中。注解对 python 解释器没有任何意义，只是给 IDE、框架、装饰器等工具使用。</p><p>支持函数式编程：</p><ul><li>operator 模块：常用的有 attrgetter、itemgetter、methodcaller</li><li>functools 模块：reduce、partial（基于一个函数创建一个新的可调用对象，把原函数的某些参数固定）、dispatch、wraps</li></ul><h1 id="6-使用一等函数实现设计模式"><a href="#6-使用一等函数实现设计模式" class="headerlink" title="6 使用一等函数实现设计模式"></a>6 使用一等函数实现设计模式</h1><p>程序设计语言会影响人们理解问题的出发点。</p><p>本章举了两个例子说明动态语言是如何简化设计模式的。（我个人感觉举的例子不是很好吧，有点过度设计的感觉）<br>之前曾经总结过使用 Python 实现设计模式，感兴趣的可以参考：</p><p><a href="http://python-web-guide.readthedocs.io/zh/latest/" target="_blank" rel="noopener">http://python-web-guide.readthedocs.io/zh/latest/</a></p><h1 id="7-函数装饰器和闭包"><a href="#7-函数装饰器和闭包" class="headerlink" title="7 函数装饰器和闭包"></a>7 函数装饰器和闭包</h1><h4 id="装饰器：可调用的对象，其参数是另一个函数。（说白了就是以函数作为参数的函数）两个特性："><a href="#装饰器：可调用的对象，其参数是另一个函数。（说白了就是以函数作为参数的函数）两个特性：" class="headerlink" title="装饰器：可调用的对象，其参数是另一个函数。（说白了就是以函数作为参数的函数）两个特性："></a>装饰器：可调用的对象，其参数是另一个函数。（说白了就是以函数作为参数的函数）两个特性：</h4><ul><li>能把被装饰的函数替换为其他函数</li><li>装饰器在加载模块时立即执行，通常是在导入时（即python加载模块时）。被装饰的函数只有在明确调用时运行</li></ul><p>装饰器语法糖:</p><pre><code># 等价于 target = decorate(target)@decoratedef target():    print(&apos;hehe&apos;)</code></pre><h4 id="闭包-闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。比如被装饰的函数能访问装饰器函数中定义的变量（非全局的）"><a href="#闭包-闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。比如被装饰的函数能访问装饰器函数中定义的变量（非全局的）" class="headerlink" title="闭包:闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。比如被装饰的函数能访问装饰器函数中定义的变量（非全局的）"></a>闭包:闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。比如被装饰的函数能访问装饰器函数中定义的变量（非全局的）</h4><h4 id="自由变量："><a href="#自由变量：" class="headerlink" title="自由变量："></a>自由变量：</h4><pre><code>def make_averager():    series = []    def averager(new_value):        # series 在 averager 中叫做自由变量(free variable)，指未在本地作用域中绑定的变量        series.append(new_value)        total = sum(series)        return total / len(series)</code></pre><h4 id="nonlocal-声明：先来看个例子："><a href="#nonlocal-声明：先来看个例子：" class="headerlink" title="nonlocal 声明：先来看个例子："></a>nonlocal 声明：先来看个例子：</h4><pre><code>def make_averager():    count = 0    total = 0    def averager(new_value):        # 直接运行到这里会报错，UnboundLocalError，因为对于非可变类型，会隐式创建局部变量 count，count 不是自由变量了        count += 1        total += new_value        return total</code></pre><p>使用 python3 引入的 nonlocal 刻意把变量标记为自由变量。</p><pre><code>def make_averager():    count = 0    total = 0    def averager(new_value):        nonlocal count, total   # python2 可以用 [count] 把需要修改的变量存储为可变对象        count += 1        total += new_value        return total</code></pre><h4 id="functools-wraps-装饰器：把相关属性从被装饰函数复制到装饰器函数中"><a href="#functools-wraps-装饰器：把相关属性从被装饰函数复制到装饰器函数中" class="headerlink" title="functools.wraps 装饰器：把相关属性从被装饰函数复制到装饰器函数中"></a>functools.wraps 装饰器：把相关属性从被装饰函数复制到装饰器函数中</h4><h4 id="标准库中的装饰器：property、classmethod、staticmehtod、functools-lru-cache、functools-singledispatch"><a href="#标准库中的装饰器：property、classmethod、staticmehtod、functools-lru-cache、functools-singledispatch" class="headerlink" title="标准库中的装饰器：property、classmethod、staticmehtod、functools.lru_cache、functools.singledispatch"></a>标准库中的装饰器：property、classmethod、staticmehtod、functools.lru_cache、functools.singledispatch</h4><pre><code>- lru_cache: 采用 least recent used 算法实现的缓存装饰器- singledispatch: 为函数提供重载功能。被其装饰的函数会成为泛函数(generic function):根据第一个参数的类型，用不同的方式执行相同操作的一组函数。替代多个 if/else isinstance 判断类型执行不同分之</code></pre><h4 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器:"></a>叠放装饰器:</h4><pre><code># 下边等价于 f = d1(d2(f))@d1@d2def f():    print(&apos;f&apos;)</code></pre><h4 id="参数化装饰器-创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。"><a href="#参数化装饰器-创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。" class="headerlink" title="参数化装饰器: 创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。"></a>参数化装饰器: 创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后再把它应用到要装饰的函数上。</h4><pre><code>registry = set()  # &lt;1&gt;def register(active=True):  # &lt;2&gt;    工厂函数    def decorate(func):  # &lt;3&gt;        print(&apos;running register(active=%s)-&gt;decorate(%s)&apos;              % (active, func))        else:            registry.discard(func)  # &lt;5&gt;        return func  # &lt;6&gt;    return decorate  # &lt;7&gt;@register(active=False)  # &lt;8&gt;def f1():    print(&apos;running f1()&apos;)@register()  # &lt;9&gt;    # 即使没有参数，工厂函数必须写成调用的形式def f2():    print(&apos;running f2()&apos;)</code></pre><h4 id="使用-class-实现装饰器：看上边多重嵌套的装饰器是不是有点不太优雅，-其实复杂的装饰器笔者更喜欢用-class-实现。还记得-call-方法吗，改写下上边这个例子"><a href="#使用-class-实现装饰器：看上边多重嵌套的装饰器是不是有点不太优雅，-其实复杂的装饰器笔者更喜欢用-class-实现。还记得-call-方法吗，改写下上边这个例子" class="headerlink" title="使用 class 实现装饰器：看上边多重嵌套的装饰器是不是有点不太优雅， 其实复杂的装饰器笔者更喜欢用 class 实现。还记得 __call__ 方法吗，改写下上边这个例子"></a>使用 class 实现装饰器：看上边多重嵌套的装饰器是不是有点不太优雅， 其实复杂的装饰器笔者更喜欢用 class 实现。还记得 <code>__call__</code> 方法吗，改写下上边这个例子</h4><pre><code>class register(object):    registry = set()    def __init__(self, active=True):        self.active = active    def __call__(self, func):        print(&apos;running register(active=%s)-&gt;decorate(%s)&apos;            % (self.active, func))        if self.active:            self.registry.add(func)        else:            self.registry.discard(func)        return func</code></pre><h1 id="8-对象引用、可变性和垃圾回收"><a href="#8-对象引用、可变性和垃圾回收" class="headerlink" title="8 对象引用、可变性和垃圾回收"></a>8 对象引用、可变性和垃圾回收</h1><h4 id="变量：我们可以把变量理解为对象的标注（便利贴），多个标注就是别名。变量保存的是对象的引用"><a href="#变量：我们可以把变量理解为对象的标注（便利贴），多个标注就是别名。变量保存的是对象的引用" class="headerlink" title="变量：我们可以把变量理解为对象的标注（便利贴），多个标注就是别名。变量保存的是对象的引用"></a>变量：我们可以把变量理解为对象的标注（便利贴），多个标注就是别名。变量保存的是对象的引用</h4><h4 id="比较对象：-判断是同一个对象-id-obj1-id-obj2-或者-obj1-is-obj2。比较两个对象的值用-obj1-obj2-obj1-eq-obj2-。你会发现一般我们用-some-obj-is-None-来判断一个对象是否是-None，说明-None-是个单例对象"><a href="#比较对象：-判断是同一个对象-id-obj1-id-obj2-或者-obj1-is-obj2。比较两个对象的值用-obj1-obj2-obj1-eq-obj2-。你会发现一般我们用-some-obj-is-None-来判断一个对象是否是-None，说明-None-是个单例对象" class="headerlink" title="比较对象： 判断是同一个对象: id(obj1) == id(obj2)  或者 obj1 is obj2。比较两个对象的值用 obj1 == obj2 (obj1.eq(obj2))。你会发现一般我们用 some_obj is None 来判断一个对象是否是 None，说明 None 是个单例对象"></a>比较对象： 判断是同一个对象: id(obj1) == id(obj2)  或者 obj1 is obj2。比较两个对象的值用 obj1 == obj2 (obj1.<strong>eq</strong>(obj2))。你会发现一般我们用 <code>some_obj is None</code> 来判断一个对象是否是 None，说明 None 是个单例对象</h4><h4 id="元祖的相对不可变性：元祖的不可变指的是保存的引用不可变，与引用的对象无关。比如如果元祖的元素是个-list，我们是可以修改这个-list-的。这也会导致有些元祖无法散列"><a href="#元祖的相对不可变性：元祖的不可变指的是保存的引用不可变，与引用的对象无关。比如如果元祖的元素是个-list，我们是可以修改这个-list-的。这也会导致有些元祖无法散列" class="headerlink" title="元祖的相对不可变性：元祖的不可变指的是保存的引用不可变，与引用的对象无关。比如如果元祖的元素是个 list，我们是可以修改这个 list 的。这也会导致有些元祖无法散列"></a>元祖的相对不可变性：元祖的不可变指的是保存的引用不可变，与引用的对象无关。比如如果元祖的元素是个 list，我们是可以修改这个 list 的。这也会导致有些元祖无法散列</h4><h4 id="默认做浅复制：构造函数或者-方法默认是浅复制。如果元素都是不可变的，浅复制没有问题。"><a href="#默认做浅复制：构造函数或者-方法默认是浅复制。如果元素都是不可变的，浅复制没有问题。" class="headerlink" title="默认做浅复制：构造函数或者 [:] 方法默认是浅复制。如果元素都是不可变的，浅复制没有问题。"></a>默认做浅复制：构造函数或者 [:] 方法默认是浅复制。如果元素都是不可变的，浅复制没有问题。</h4><h4 id="深拷贝-copy-deepcopy-和-copy-copy-能为任意对象做深复制和浅复制。我们可以自定义-copy-和-deepcopy-控制拷贝行为"><a href="#深拷贝-copy-deepcopy-和-copy-copy-能为任意对象做深复制和浅复制。我们可以自定义-copy-和-deepcopy-控制拷贝行为" class="headerlink" title="深拷贝: copy.deepcopy 和 copy.copy 能为任意对象做深复制和浅复制。我们可以自定义 __copy__() 和 __deepcopy__() 控制拷贝行为"></a>深拷贝: copy.deepcopy 和 copy.copy 能为任意对象做深复制和浅复制。我们可以自定义 <code>__copy__()</code> 和 <code>__deepcopy__()</code> 控制拷贝行为</h4><h4 id="函数的参数作为引用时：python-唯一支持的传参模式是共享传参（call-by-sharing），指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这个方案的结果就是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）。（笔者觉得这章解释非常好，之前网上一大堆讨论python究竟是值传递还是引用传递的都是不准确的）"><a href="#函数的参数作为引用时：python-唯一支持的传参模式是共享传参（call-by-sharing），指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这个方案的结果就是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）。（笔者觉得这章解释非常好，之前网上一大堆讨论python究竟是值传递还是引用传递的都是不准确的）" class="headerlink" title="函数的参数作为引用时：python 唯一支持的传参模式是共享传参（call by sharing），指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这个方案的结果就是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）。（笔者觉得这章解释非常好，之前网上一大堆讨论python究竟是值传递还是引用传递的都是不准确的）"></a>函数的参数作为引用时：python 唯一支持的传参模式是共享传参（call by sharing），指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。这个方案的结果就是，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）。（笔者觉得这章解释非常好，之前网上一大堆讨论python究竟是值传递还是引用传递的都是不准确的）</h4><h4 id="不要使用可变类型作为参数的默认值：这个坑写-py-写多的人应该都碰到过。函数默认值在定义函数时计算（通常是加载模块时），因此默认值变成了函数对象的属性。如果默认值是可变对象，而且修改了它的值，后续的函数调用就会受影响。一般我们用-None-作为占位符。"><a href="#不要使用可变类型作为参数的默认值：这个坑写-py-写多的人应该都碰到过。函数默认值在定义函数时计算（通常是加载模块时），因此默认值变成了函数对象的属性。如果默认值是可变对象，而且修改了它的值，后续的函数调用就会受影响。一般我们用-None-作为占位符。" class="headerlink" title="不要使用可变类型作为参数的默认值：这个坑写 py 写多的人应该都碰到过。函数默认值在定义函数时计算（通常是加载模块时），因此默认值变成了函数对象的属性。如果默认值是可变对象，而且修改了它的值，后续的函数调用就会受影响。一般我们用 None 作为占位符。"></a>不要使用可变类型作为参数的默认值：这个坑写 py 写多的人应该都碰到过。函数默认值在定义函数时计算（通常是加载模块时），因此默认值变成了函数对象的属性。如果默认值是可变对象，而且修改了它的值，后续的函数调用就会受影响。一般我们用 None 作为占位符。</h4><pre><code>def func(l=None):    # 不要写 def func(l=[]):    # 使用 None 作为占位符（pylint 默认会提示可变类型参数作为默认值，所以俺经常安利用 pylint 检测代码，防范风险）    l = None or []</code></pre><p>所以，一般对于一个函数，要么确认是要修改可变参数，要么返回新的值（使用参数的拷贝），请不要两者同时做。(笔者在小书 web guide 中明确提醒过)</p><h4 id="del-和-垃圾回收-del-语句删除名称，而不是对象-删除引用而不是对象）。只有对象变量保存的是对象的最后一个引用的时候，才会被回收。Cpython-中垃圾回收主要使用的是引用计数。不要轻易自定义-del-方法，很难用对。"><a href="#del-和-垃圾回收-del-语句删除名称，而不是对象-删除引用而不是对象）。只有对象变量保存的是对象的最后一个引用的时候，才会被回收。Cpython-中垃圾回收主要使用的是引用计数。不要轻易自定义-del-方法，很难用对。" class="headerlink" title="del 和 垃圾回收: del 语句删除名称，而不是对象(删除引用而不是对象）。只有对象变量保存的是对象的最后一个引用的时候，才会被回收。Cpython 中垃圾回收主要使用的是引用计数。不要轻易自定义 __del__ 方法，很难用对。"></a>del 和 垃圾回收: del 语句删除名称，而不是对象(删除引用而不是对象）。只有对象变量保存的是对象的最后一个引用的时候，才会被回收。Cpython 中垃圾回收主要使用的是引用计数。不要轻易自定义 <code>__del__</code> 方法，很难用对。</h4><h4 id="弱引用-weakref-：有时候需要引用对象，而又不让对象存在的时间超过所需时间，经常用在缓存中。弱引用不会增加对象的引用数量，不会妨碍所指的对象被当做垃圾回收"><a href="#弱引用-weakref-：有时候需要引用对象，而又不让对象存在的时间超过所需时间，经常用在缓存中。弱引用不会增加对象的引用数量，不会妨碍所指的对象被当做垃圾回收" class="headerlink" title="弱引用(weakref)：有时候需要引用对象，而又不让对象存在的时间超过所需时间，经常用在缓存中。弱引用不会增加对象的引用数量，不会妨碍所指的对象被当做垃圾回收"></a>弱引用(weakref)：有时候需要引用对象，而又不让对象存在的时间超过所需时间，经常用在缓存中。弱引用不会增加对象的引用数量，不会妨碍所指的对象被当做垃圾回收</h4><ul><li>WeakValueDictionary: 一种可变映射，值是对象的弱引用。还有 WeakKeyDictionary、WeakSet、finalize。</li></ul><h4 id="Python-对不可变类型施加的把戏（CPython-实现细节）"><a href="#Python-对不可变类型施加的把戏（CPython-实现细节）" class="headerlink" title="Python 对不可变类型施加的把戏（CPython 实现细节）"></a>Python 对不可变类型施加的把戏（CPython 实现细节）</h4><ul><li>对于元祖 t, t[:] 和 tuple(t) 不会创建副本，返回的是引用（这点和list 不同）。str, bytes 和 frozenset 也有这种行为</li></ul><h1 id="9-符合-Python-风格的对象"><a href="#9-符合-Python-风格的对象" class="headerlink" title="9 符合 Python 风格的对象"></a>9 符合 Python 风格的对象</h1><p>鸭子类型(duck typing): 只需按照预定行为实现对象所需的方法即可。</p><h4 id="对象的表示形式-repr-让开发者理解的方式返回对象的字符串表示。str-用户理解的方式返回对象的字符串表示"><a href="#对象的表示形式-repr-让开发者理解的方式返回对象的字符串表示。str-用户理解的方式返回对象的字符串表示" class="headerlink" title="对象的表示形式: repr() 让开发者理解的方式返回对象的字符串表示。str() 用户理解的方式返回对象的字符串表示"></a>对象的表示形式: repr() 让开发者理解的方式返回对象的字符串表示。str() 用户理解的方式返回对象的字符串表示</h4><h4 id="classmethod-和-staticmehtod-classmethod-定义操作类而不是操作实例的方法，第一个参数是类本身，最常见的用途是定义定义备选构造方法-返回-cls-。staticmehtod-方法就是普通函数，只是碰巧在类的定义体中。"><a href="#classmethod-和-staticmehtod-classmethod-定义操作类而不是操作实例的方法，第一个参数是类本身，最常见的用途是定义定义备选构造方法-返回-cls-。staticmehtod-方法就是普通函数，只是碰巧在类的定义体中。" class="headerlink" title="classmethod 和 staticmehtod: classmethod 定义操作类而不是操作实例的方法，第一个参数是类本身，最常见的用途是定义定义备选构造方法(返回 cls(*))。staticmehtod 方法就是普通函数，只是碰巧在类的定义体中。"></a>classmethod 和 staticmehtod: classmethod 定义操作类而不是操作实例的方法，第一个参数是类本身，最常见的用途是定义定义备选构造方法(返回 cls(*))。staticmehtod 方法就是普通函数，只是碰巧在类的定义体中。</h4><h4 id="Python的私有属性和『受保护』属性：python没有-private修饰符，可以通过双下划线-attr-的形式定义，python-的子类会在存储属性名的时候在前面加上一个下划线和类名。这个语言特性成为名称改写（name-mangling）。通常受保护的属性使用一个下划线作为前缀，算是一种命名约定，调用者不应该在类外部访问这种属性。"><a href="#Python的私有属性和『受保护』属性：python没有-private修饰符，可以通过双下划线-attr-的形式定义，python-的子类会在存储属性名的时候在前面加上一个下划线和类名。这个语言特性成为名称改写（name-mangling）。通常受保护的属性使用一个下划线作为前缀，算是一种命名约定，调用者不应该在类外部访问这种属性。" class="headerlink" title="Python的私有属性和『受保护』属性：python没有 private修饰符，可以通过双下划线  __attr 的形式定义，python 的子类会在存储属性名的时候在前面加上一个下划线和类名。这个语言特性成为名称改写（name mangling）。通常受保护的属性使用一个下划线作为前缀，算是一种命名约定，调用者不应该在类外部访问这种属性。"></a>Python的私有属性和『受保护』属性：python没有 private修饰符，可以通过双下划线  <code>__attr</code> 的形式定义，python 的子类会在存储属性名的时候在前面加上一个下划线和类名。这个语言特性成为名称改写（name mangling）。通常受保护的属性使用一个下划线作为前缀，算是一种命名约定，调用者不应该在类外部访问这种属性。</h4><p>python 没有访问控制和 java 设计迥然不同，本章最后的杂谈讨论了这两种设计。在 python 中，我们可以先使用公开属性，等需要时再变成特性。</p><h4 id="使用-slots-类属性节省空间：默认情况下，python在各个中名为-dict-的字典存储实力属性，当生成大量对象时字典会消耗大量内存（底层是稀疏数组），通过-slots-类属性，让解释器在元祖而不是字典中存储实例属性，能大大节省内存。-不支持继承"><a href="#使用-slots-类属性节省空间：默认情况下，python在各个中名为-dict-的字典存储实力属性，当生成大量对象时字典会消耗大量内存（底层是稀疏数组），通过-slots-类属性，让解释器在元祖而不是字典中存储实例属性，能大大节省内存。-不支持继承" class="headerlink" title="使用__slots__类属性节省空间：默认情况下，python在各个中名为__dict__的字典存储实力属性，当生成大量对象时字典会消耗大量内存（底层是稀疏数组），通过__slots__类属性，让解释器在元祖而不是字典中存储实例属性，能大大节省内存。(不支持继承)"></a>使用<code>__slots__</code>类属性节省空间：默认情况下，python在各个中名为<code>__dict__</code>的字典存储实力属性，当生成大量对象时字典会消耗大量内存（底层是稀疏数组），通过<code>__slots__</code>类属性，让解释器在元祖而不是字典中存储实例属性，能大大节省内存。(不支持继承)</h4><ul><li>每个子类都需要定义 <code>__slots__</code>，解释器会忽略继承的 <code>__slots__</code>属性</li><li>实例只能拥有 <code>__slots__</code> 属性，除非把 <code>__dict__</code> 也加到 <code>__slots__</code> 里（这样就失去了节省内存的功效）</li></ul><h4 id="覆盖类属性：python有个独特的特性，类属性可以为实例属性提供默认值"><a href="#覆盖类属性：python有个独特的特性，类属性可以为实例属性提供默认值" class="headerlink" title="覆盖类属性：python有个独特的特性，类属性可以为实例属性提供默认值"></a>覆盖类属性：python有个独特的特性，类属性可以为实例属性提供默认值</h4><h1 id="10-序列的修改、散列和切片"><a href="#10-序列的修改、散列和切片" class="headerlink" title="10 序列的修改、散列和切片"></a>10 序列的修改、散列和切片</h1><h4 id="协议和鸭子类型-python中我们刻意创建序列类型而无需使用继承，只需实现符合序列协议的方法。"><a href="#协议和鸭子类型-python中我们刻意创建序列类型而无需使用继承，只需实现符合序列协议的方法。" class="headerlink" title="协议和鸭子类型: python中我们刻意创建序列类型而无需使用继承，只需实现符合序列协议的方法。"></a>协议和鸭子类型: python中我们刻意创建序列类型而无需使用继承，只需实现符合序列协议的方法。</h4><p>鸭子类型： 在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。例如 python 序列协议只需要实现 <code>__lens__</code>  和 <code>__getitem__</code> 两个方法。只关心行为而不关心类型。</p><p>我们可以模仿 python 对象的内置方法来编写符合 python 风格的类。（具体的大家还是看下书中的代码示例吧，这一章举得例子不错）</p><h1 id="11-接口：从协议到抽象基类"><a href="#11-接口：从协议到抽象基类" class="headerlink" title="11 接口：从协议到抽象基类"></a>11 接口：从协议到抽象基类</h1><h4 id="使用猴子补丁在运行时实现协议："><a href="#使用猴子补丁在运行时实现协议：" class="headerlink" title="使用猴子补丁在运行时实现协议："></a>使用猴子补丁在运行时实现协议：</h4><p>运行时修改类或者模块，而不改动源码。可以在运行时让类实现协议</p><h4 id="抽象基类：collections-abc-模块"><a href="#抽象基类：collections-abc-模块" class="headerlink" title="抽象基类：collections.abc 模块"></a>抽象基类：collections.abc 模块</h4><ul><li>Iterable，Container 和 Sized:：Iterable 通过 <code>__iter__</code> 支持迭代，Container 通过  <code>__contains__</code> 支持 in 操作符, Sized 通过 <code>__len__</code> 支持 len() 函数</li><li>Sequence， Mapping and Set ：不可变集合类型</li><li>MappingView: 映射方法 .items()，.kesy()，.values() 返回的对象分别是 ItemsView,KeysView 和 ValuesView 实例</li><li>Callable 和 Hashable: 主要作用市委内置 isinstance 提供支持，以一种安全的方式判断对象能不能调用或散列。python 提供了callable 内置函数却没有提供 hashable() ，用 isinstance(obj, Hashable) 判断</li><li>Iterator</li><li>numbers包：Number, Complex，Real，Rational，Integral</li></ul><h4 id="定义并使用抽象基类"><a href="#定义并使用抽象基类" class="headerlink" title="定义并使用抽象基类"></a>定义并使用抽象基类</h4><pre><code>import abcclass Base(abc.ABC):    # py3， py2 中使用  __metaclass__ = abc.ABCMeta    @abc.abstractmethod    # 该装饰器应该放在最里层    def some_method(self):  # 这里可以只有 docstring 省略函数体        &quot;&quot;&quot;抽象方法，在抽象基类出现之前抽象方法用 Raise NotImplementedError 语句表明由子类实现&quot;&quot;&quot;</code></pre><h4 id="使用-register-方法注册虚拟子类"><a href="#使用-register-方法注册虚拟子类" class="headerlink" title="使用 register 方法注册虚拟子类:"></a>使用 register 方法注册虚拟子类:</h4><p>在抽象基类上调用 register 方法注册其虚拟子类，issubclass 和 isinstance 都能识别，但是注册的的类不会从抽象基类中继承任何方法和属性。查看虚拟子类的 <code>__mro__</code> 会发现抽象基类不在其中(没继承其属性和方法) </p><h4 id="subclasshook-即使不注册，抽象基类也能把一个类识别为虚拟子类。定义-subclasshook-方法动态识别子类。参考-abc-Sized-源码"><a href="#subclasshook-即使不注册，抽象基类也能把一个类识别为虚拟子类。定义-subclasshook-方法动态识别子类。参考-abc-Sized-源码" class="headerlink" title="__subclasshook__ : 即使不注册，抽象基类也能把一个类识别为虚拟子类。定义 __subclasshook__ 方法动态识别子类。参考 abc.Sized 源码"></a><code>__subclasshook__</code> : 即使不注册，抽象基类也能把一个类识别为虚拟子类。定义 <code>__subclasshook__</code> 方法动态识别子类。参考 abc.Sized 源码</h4><h4 id="强类型和弱类型："><a href="#强类型和弱类型：" class="headerlink" title="强类型和弱类型："></a>强类型和弱类型：</h4><p>如果一门语言很少隐式转换类型，说明它是强类型语言(java/c++/python)。如果经常这么做，是弱类型语言(php,javascript,perl)。强类型能及早发现缺陷</p><h4 id="静态和动态类型："><a href="#静态和动态类型：" class="headerlink" title="静态和动态类型："></a>静态和动态类型：</h4><p>在编译时期检查类型的语言是静态语言，运行时检查类型的语言是动态语言。静态类型需要类型声明（有些现代语言使用类型推导避免部分类型声明）。静态类型便于编译器和 IDE<br>及早分析代码、找出错误和提供其他服务（优化、重构等）。动态类型便于代码重用，代码行数更少，而且能让接口自然成为协议而不提早实行。</p><h1 id="12-继承的优缺点"><a href="#12-继承的优缺点" class="headerlink" title="12 继承的优缺点"></a>12 继承的优缺点</h1><h4 id="子类化内置类型："><a href="#子类化内置类型：" class="headerlink" title="子类化内置类型："></a>子类化内置类型：</h4><p>内置类型的方法不会调用子类覆盖的方法。不要子类化C语言实现的内置类型（list,dict等），用户自定义的类应该继承自 collections<br>模块。collections.UserDict, UserList and UserString</p><h4 id="多重继承和方法解析顺序"><a href="#多重继承和方法解析顺序" class="headerlink" title="多重继承和方法解析顺序"></a>多重继承和方法解析顺序</h4><p>任何支持多重继承的语言都要处理潜在的明明冲突问题，菱形继承问题。python  会按照 方法解析顺序MRO(method resolution order)<br>遍历继承图。类都有一个  <code>__mro__</code> 属性，它的值是一个tuple，按照顺序列出各个超类，直到 object 类。MRO 根据 C3 算法计算</p><h4 id="处理多重继承"><a href="#处理多重继承" class="headerlink" title="处理多重继承"></a>处理多重继承</h4><p>多重继承增加了可选方案和复杂度</p><ul><li>把接口继承和实现继承区分开。明确一开始为什么创建子类。1.继承接口，创建子类型，实现『是什么』关系。2.继承实现，重用代码。通过继承重用代码是实现细节，通常可换成组合和委托。接口继承是框架的支柱</li><li>使用抽象基类显示表示接口</li><li>通过 mixin 重用代码。mixin 不定义新类型, 只是打包方法，便于重用。mixin 类绝对不能实例化，应该提供某方面的特定行为，只是实现少量关系非常紧密的方法</li><li>明确指名 mixin。类应该以 mixin 后缀</li><li>抽象基类可以作为 mixin，但是反过来不成立</li><li>不要子类化多个具体类。具体类的超类中除了一个具体类，其他都应该是抽象基类或者 mixin</li></ul><pre><code>class MyConcreteClass(Alpha, Beta, Gamma):    &quot;&quot;&quot; 如果 Alpha 是具体类，Beta 和 Gamma 必须是抽象基类或者 mixin&quot;&quot;&quot;    pass</code></pre><ul><li>创建聚合类。django 中的 ListView，tinker中的 Widget</li></ul><pre><code>class Widget(BaseWidget, Pack, Place, Grid):    pass</code></pre><ul><li>优先使用组合而非继承。子类化是一种紧耦合，不要过度使用</li></ul><h1 id="13-正确重载运算符"><a href="#13-正确重载运算符" class="headerlink" title="13  正确重载运算符"></a>13  正确重载运算符</h1><p>python 不允许用户随意创建运算符，禁止重载内置类型的运算符。python支持运算符重载是其在科学计算领域使用广泛的原因。</p><ul><li>一元运算符：始终返回一个新对象。</li><li><p>NotImplemented 是个特殊的单例值，如果中缀运算符特殊方法不能处理给定的操作数，要把它返回给解释器。NotImplementedError 是一种异常，抽象类中的方法把它 raise 出，提醒子类必须覆盖。</p><pre><code>def __add__(self, other):    try:        pairs = itertools.zip_longest(self, other, fillvalue=0.0)        return Vector(a + b for a, b in pairs)    except TypeError:        # 返回 NotImplemented 解释器会尝试调用 反向运算符方法 __radd__        return NotImplementeddef __radd__(self, other):    return self + other</code></pre></li><li><p>增量赋值运算符不会修改不可变目标，而是新建实例，然后重新绑定。</p></li></ul><h1 id="14-可迭代对象、迭代器和生成器"><a href="#14-可迭代对象、迭代器和生成器" class="headerlink" title="14 可迭代对象、迭代器和生成器"></a>14 可迭代对象、迭代器和生成器</h1><p>解释器需要迭代对象 x 时，会自动调用 iter(x)。内置的 iter 有以下作用：</p><ul><li>检查对象是否实现了 <code>__iter__</code> ，如果实现了就调用它获取一个迭代器</li><li>如果没有实现 <code>__iter__</code> 方法，但是实现了 <code>__getitem__</code> 方法，python 会创建一个迭代器，尝试按照顺序（从索引0）获取元素</li><li>如果尝试失败，抛出 TypeError 异常</li></ul><h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象:"></a>可迭代对象:</h4><p>如果对象实现了能返回迭代器的 <code>__iter__</code> 方法，就是可迭代的。序列都可以迭代；实现了  <code>__getitem__</code> 方法，而且其参数是从 0 开始的索引，这种对象也可以迭代。</p><h4 id="标准迭代器接口有两个方法："><a href="#标准迭代器接口有两个方法：" class="headerlink" title="标准迭代器接口有两个方法："></a>标准迭代器接口有两个方法：</h4><ul><li><code>__next__</code>: 返回下一个可用的元素，没有元素抛出 StopIteration</li><li><code>__iter__</code>: 返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如 for 循环中</li></ul><p>检查对象是否是迭代器的最好方法是调用 isinstance(x, abc.Iterator)</p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器:"></a>迭代器:</h4><p>实现了无参数的 <code>__next__</code> 方法，返回序列中下一个元素；如果没有元素了，抛出 StopIteration 异常。python中的迭代器还实现了<br><code>__iter__</code> 方法，因此迭代器也可以迭代。</p><h4 id="二者区别："><a href="#二者区别：" class="headerlink" title="二者区别："></a>二者区别：</h4><p>迭代器可以迭代，但是可迭代的对象不是迭代器。可迭代的对象一定不能是自身的迭代器。也就是说，可迭代对象必须实现  <code>__iter__</code><br>，但是不能实现 <code>__next__</code></p><h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><p>只要 python 的函数体中有 yield 关键字，该函数就是生成器函数。调用生成器函数会返回一个生成器对象。生成器函数是生成器工厂</p><h4 id="标准库的中生成器函数"><a href="#标准库的中生成器函数" class="headerlink" title="标准库的中生成器函数"></a>标准库的中生成器函数</h4><ul><li>用于过滤的生成器函数: itertools.takewhile/compress/dropwhile/filter/filterfalse/islice/</li><li>用于映射的生成器函数: 内置的 enumerate/map  itertools.accumulate/starmap</li><li>用于合并的生成器函数：itertools.chain/from_iterable/product/zip_longest  内置的 zip</li><li>从一个元素产生多个值，扩展输入的可迭代对象: itertools.combinations/combinations_with_replacement/count/cycle/permutations/repeat</li><li>产出输入可迭代对象的全部元素，以某种方式排列：itertools.groupby/tee     内置的 reversed</li></ul><h4 id="可迭代的规约函数"><a href="#可迭代的规约函数" class="headerlink" title="可迭代的规约函数"></a>可迭代的规约函数</h4><p>归约函数：接受一个可迭代的对象，返回单个结果。all/any/max/mini/functools.reduce/sum    all/any 有短路特性</p><h4 id="把生成器当协程"><a href="#把生成器当协程" class="headerlink" title="把生成器当协程"></a>把生成器当协程</h4><p><code>.send()</code> 方法致使生成器前进到下一个 yield 语句，还允许使用生成器的客户把数据发给自己，不管传给 send 方法什么参数，<br>那个参数都会成为生成器函数定义体中对应的 yield 表达式的值。</p><h1 id="15-上下文管理器和-else-块"><a href="#15-上下文管理器和-else-块" class="headerlink" title="15 上下文管理器和 else 块"></a>15 上下文管理器和 else 块</h1><h4 id="EAFP-vs-LBYL"><a href="#EAFP-vs-LBYL" class="headerlink" title="EAFP vs LBYL"></a>EAFP vs LBYL</h4><ul><li>EAFP: easier to ask for forgiveness than permission</li><li>LBYL: look before you leap</li></ul><h4 id="上下文管理器和-with-块"><a href="#上下文管理器和-with-块" class="headerlink" title="上下文管理器和 with 块"></a>上下文管理器和 with 块</h4><p>with 语句用来简化 try/finally 模式。经常用在管理事务，维护锁、条件和信号，给对象打补丁等。</p><pre><code>class LookingGlass:    def __enter__(self):  # &lt;1&gt;        import sys        self.original_write = sys.stdout.write  # &lt;2&gt;        sys.stdout.write = self.reverse_write  # &lt;3&gt;        return &apos;JABBERWOCKY&apos;  # &lt;4&gt;    def reverse_write(self, text):  # &lt;5&gt;        self.original_write(text[::-1])    def __exit__(self, exc_type, exc_value, traceback):  # &lt;6&gt;        import sys  # &lt;7&gt;        sys.stdout.write = self.original_write  # &lt;8&gt;        if exc_type is ZeroDivisionError:  # &lt;9&gt;            print(&apos;Please DO NOT divide by zero!&apos;)            return True  # &lt;10&gt;</code></pre><h4 id="contextlib-模块中的实用工具"><a href="#contextlib-模块中的实用工具" class="headerlink" title="contextlib 模块中的实用工具"></a>contextlib 模块中的实用工具</h4><p><code>@contextmanager</code> 装饰器能减少创建上下文管理器的样板代码。只需要实现一个 yield 语句的生成器，生成想让 <code>__enter__</code><br>方法返回的值。</p><pre><code>@contextlib.contextmanagerdef looking_glass():    import sys    original_write = sys.stdout.write    def reverse_write(text):        original_write(text[::-1])    sys.stdout.write = reverse_write    msg = &apos;&apos;  # &lt;1&gt;    try:        yield &apos;JABBERWOCKY&apos;  # 产出一个值，这个值会绑定到with语句中的 as 子句的目标变量上    except ZeroDivisionError:  # &lt;2&gt;        msg = &apos;Please DO NOT divide by zero!&apos;    finally:        sys.stdout.write = original_write  # &lt;3&gt;        if msg:            print(msg)  # &lt;4&gt;</code></pre><h1 id="16-协程"><a href="#16-协程" class="headerlink" title="16 协程"></a>16 协程</h1><p>句法上看，协程和生成器类似，都是定义体中包含 yield 关键字的函数。但在协程中，yield 通常出现在表达式右边(datum =<br>yield)，可以产出值，也可以不产出。如果yield 关键字后边没有表达式，那么生成器产出 None。调用方可以用 send<br>方法把数据提供给协程。从根本上把 yield 视作控制流程的方式。</p><h4 id="生成器如何进化成协程"><a href="#生成器如何进化成协程" class="headerlink" title="生成器如何进化成协程"></a>生成器如何进化成协程</h4><p>python2.5 之后yield 关键在能在表达式中使用，而且生成器 api 中增加了 <code>.send(value)</code> 方法。生成器的调用方可以用 send<br>发送数据，发送的数据会成为生成器函数中 yield 表达式的值。因此生成器能当做协程使用。协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。</p><p>协程使用 next 函数预激(prime)，即让协程向前执行到第一个 yield 表达式。</p><h4 id="预激（prime）协程的装饰器"><a href="#预激（prime）协程的装饰器" class="headerlink" title="预激（prime）协程的装饰器"></a>预激（prime）协程的装饰器</h4><p>启动协程之前需要 prime，方法是调用 send(None) 或者 next() 。为了简化协程的语法，有时候会使用一个 预激 装饰器。<br>比如 tornado.gen 装饰器。yield from 调用协程会自动 预激</p><pre><code>from functools import wrapsdef coroutine(func):    &quot;&quot;&quot;向前执行到第一个 yield 表达式，预激 func &quot;&quot;&quot;    @wraps(func)    def primer(*args, **kwargs):        gen = func(*args, **kwargs)    # 获取生成器对象        next(gen)    # prime        return gen    return primer</code></pre><h4 id="终止协程和异常处理"><a href="#终止协程和异常处理" class="headerlink" title="终止协程和异常处理"></a>终止协程和异常处理</h4><p>协程中未处理的异常会向上冒泡</p><ul><li>generator.throw(exc_type)</li><li>generator.close()</li></ul><h4 id="让协程返回值"><a href="#让协程返回值" class="headerlink" title="让协程返回值"></a>让协程返回值</h4><p>协程中 return 表达式的值会偷偷传给调用方，赋值给 StopIteration 异常的一个属性 value</p><pre><code>try:    coro.send(None)except StopIteration as exc:    result = exc.value</code></pre><h4 id="yield-from-python3"><a href="#yield-from-python3" class="headerlink" title="yield from(python3)"></a>yield from(python3)</h4><p>RESULT = yield from EXPR  等效代码如下，虽然比较复杂， 但是能帮助我们理解 yield from 如何工作</p><pre><code>_i = iter(EXPR)  # EXPR 是任何可迭代对象try:    _y = next(_i)  # 预激(prime) 子生成器except StopIteration as _e:    _r = _e.value  # 如果抛出 StopIteration 获取 value 属性（返回值）else:    while 1:  # 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道        try:            _s = yield _y  # 产出字生成器当前产出元素；等待调用方发送 _s 中保存的值        except GeneratorExit as _e:  # 用于关闭委派生成器和子生成器            try:                _m = _i.close            except AttributeError:   # 子生成器是任何可迭代对象，所以可能没有 close 方法                pass            else:                _m()            raise _e        except BaseException as _e:  # 处理调用方通过 throw 方法传入的异常            _x = sys.exc_info()            try:                _m = _i.throw            except AttributeError:    # 子生成器是任何可迭代对象，所以可能没有 throw 方法                raise _e            else:  # 如果子生成器有 throw 方法，调用它并传入调用方发来的异常                try:                    _y = _m(*_x)                except StopIteration as _e:                    _r = _e.value                    break        else:  # 如果产出值时没有异常            try:  尝试让子生成器向前执行                if _s is None:  # &lt;11&gt;                    _y = next(_i)                else:                    _y = _i.send(_s)            except StopIteration as _e:  # &lt;12&gt;                _r = _e.value                breakRESULT = _r  # 返回的值是 _r，即整个 yield from 表达式的值</code></pre><h1 id="17-使用-concurrent-futures-处理并发"><a href="#17-使用-concurrent-futures-处理并发" class="headerlink" title="17 使用 concurrent.futures 处理并发"></a>17 使用 concurrent.futures 处理并发</h1><p>python3.2 后引入了 concurrent.futers 模块用来处理并发。该模块引入了 TreadPoolExecutor 和 ProcessPoolExecutor<br>类，这两个类实现的接口能分别在不同的线程和进程中执行可调用的对象。</p><pre><code>from concurrent import futuresfrom flags import save_flag, get_flag, show, main  # &lt;1&gt;MAX_WORKERS = 20  # &lt;2&gt;def download_one(cc):  # &lt;3&gt;    image = get_flag(cc)    show(cc)    save_flag(image, cc.lower() + &apos;.gif&apos;)    return ccdef download_many(cc_list):    workers = min(MAX_WORKERS, len(cc_list))  # &lt;4&gt;    with futures.ThreadPoolExecutor(workers) as executor:  # &lt;5&gt;        res = executor.map(download_one, sorted(cc_list))  # &lt;6&gt;    return len(list(res))  # &lt;7&gt;if __name__ == &apos;__main__&apos;:    main(download_many)  # &lt;8&gt;</code></pre><h4 id="Future-期物-中文版翻译感觉这个名字怪怪的"><a href="#Future-期物-中文版翻译感觉这个名字怪怪的" class="headerlink" title="Future(期物)(中文版翻译感觉这个名字怪怪的)"></a>Future(期物)(中文版翻译感觉这个名字怪怪的)</h4><p>concurrent.futures.Future: Feature 类的实例都表示可能已经完成或者尚未完成的延迟计算，可以调用它的 result() 方法获取结果</p><pre><code>def download_many(cc_list):    cc_list = cc_list[:5]  # &lt;1&gt;    with futures.ThreadPoolExecutor(max_workers=3) as executor:  # &lt;2&gt;        to_do = []        for cc in sorted(cc_list):  # &lt;3&gt;            future = executor.submit(download_one, cc)  # &lt;4&gt;            to_do.append(future)  # &lt;5&gt;            msg = &apos;Scheduled for {}: {}&apos;            print(msg.format(cc, future))  # &lt;6&gt;        results = []        for future in futures.as_completed(to_do):  # &lt;7&gt;            res = future.result()  # &lt;8&gt;            msg = &apos;{} result: {!r}&apos;            print(msg.format(future, res)) # &lt;9&gt;            results.append(res)    return len(results)</code></pre><h4 id="阻塞型-IO-和-GIL"><a href="#阻塞型-IO-和-GIL" class="headerlink" title="阻塞型 IO 和 GIL"></a>阻塞型 IO 和 GIL</h4><p>GIL 一次只允许一个线程执行 python 字节码。但是标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回的结果时都会释放<br>GIL，这意味着python 在这个层次上能使用多线程，一个 python 线程等待网络请求时，阻塞型 I/O 会释放(sleep 函数也会)<br>GIL，运行另一个线程。因此尽管有 GIL，python 线程还是能在 IO 密集型应用中发挥作用。</p><h4 id="concurrent-futures-ProcessPoolExecutor-绕开-GIL"><a href="#concurrent-futures-ProcessPoolExecutor-绕开-GIL" class="headerlink" title="concurrent.futures.ProcessPoolExecutor 绕开 GIL"></a>concurrent.futures.ProcessPoolExecutor 绕开 GIL</h4><h1 id="18-使用-asyncio-处理并发"><a href="#18-使用-asyncio-处理并发" class="headerlink" title="18 使用 asyncio 处理并发"></a>18 使用 asyncio 处理并发</h1><h4 id="asyncio-使用事件循环驱动的协程实现并发"><a href="#asyncio-使用事件循环驱动的协程实现并发" class="headerlink" title="asyncio 使用事件循环驱动的协程实现并发"></a>asyncio 使用事件循环驱动的协程实现并发</h4><pre><code>import asyncioimport aiohttp  # &lt;1&gt;from flags import BASE_URL, save_flag, show, main  # &lt;2&gt;@asyncio.coroutine  # &lt;3&gt;def get_flag(cc):    url = &apos;{}/{cc}/{cc}.gif&apos;.format(BASE_URL, cc=cc.lower())    resp = yield from aiohttp.request(&apos;GET&apos;, url)  # &lt;4&gt;    image = yield from resp.read()  # &lt;5&gt;    return image@asyncio.coroutinedef download_one(cc):  # &lt;6&gt;    image = yield from get_flag(cc)  # &lt;7&gt;    show(cc)    save_flag(image, cc.lower() + &apos;.gif&apos;)    return ccdef download_many(cc_list):    loop = asyncio.get_event_loop()  # &lt;8&gt;    to_do = [download_one(cc) for cc in sorted(cc_list)]  # &lt;9&gt;    wait_coro = asyncio.wait(to_do)  # &lt;10&gt;    res, _ = loop.run_until_complete(wait_coro)  # &lt;11&gt;    loop.close() # &lt;12&gt;    return len(res)if __name__ == &apos;__main__&apos;:    main(download_many)</code></pre><h4 id="避免阻塞型调用"><a href="#避免阻塞型调用" class="headerlink" title="避免阻塞型调用"></a>避免阻塞型调用</h4><p>两种方式避免阻塞型调用中止整个应用程序的进程：</p><ul><li>在单独的线程中运行各个阻塞型操作</li><li>把每个阻塞型调用操作转成非阻塞的异步调用</li></ul><h5 id="在-asyncio-中使用-Executor-对象，防止阻塞事件循环"><a href="#在-asyncio-中使用-Executor-对象，防止阻塞事件循环" class="headerlink" title="在 asyncio 中使用 Executor 对象，防止阻塞事件循环"></a>在 asyncio 中使用 Executor 对象，防止阻塞事件循环</h5><p>python 访问本地文件系统会阻塞，硬盘IO 阻塞会浪费几百万个 cpu 周期。解决方法是使用时间循环对象的 run_in_executor 方法。</p><pre><code>@asyncio.coroutinedef download_one(cc, base_url, semaphore, verbose):    try:        with (yield from semaphore):            image = yield from get_flag(base_url, cc)    except web.HTTPNotFound:        status = HTTPStatus.not_found        msg = &apos;not found&apos;    except Exception as exc:        raise FetchError(cc) from exc    else:        loop = asyncio.get_event_loop()  # 获取事件循环对象的引用        loop.run_in_executor(None,  # None 使用默认的 TrreadPoolExecutor 实例                save_flag, image, cc.lower() + &apos;.gif&apos;)  # 传入可调用对象        status = HTTPStatus.ok        msg = &apos;OK&apos;    if verbose and msg:        print(cc, msg)    return Result(status, cc)asyncio 的事件循环背后维护一个 ThreadPoolExecutor 对象，我们可以调用 run_in_executor 方法， 把可调用的对象发给它执行。</code></pre><h4 id="从回调到-Futures-和-协程"><a href="#从回调到-Futures-和-协程" class="headerlink" title="从回调到 Futures 和 协程"></a>从回调到 Futures 和 协程</h4><p>回调地狱：如果一个操作需要依赖之前操作的结果，那就得嵌套回调。</p><p>python 中的回调地狱：</p><pre><code>def stage1(response1):    request2 = step1(response1)    api_call2(request2, stage2)def stage2(response2):    request3 = step2(response2)    api_call3(request3, stage3)def stage3(response3):    step3(response3)api_call1(request1, step1)</code></pre><p>使用 协程 和 yield from 结构做异步编程，无需用回调</p><pre><code>@asyncio.coroutinedef three_stages(request1):    response1 = yield from api_call1()    request2 = step1(response1)    response2 = yield from api_call2(request2)    request3 = step2(response2)    response3 = yield from api_call3(request3)    step3(response3)# 协程不能直接调用，必须用事件循环显示指定协程的执行时间，或者在其他排定了执行时间的协程中使用 yield from 表达式把它激活loop.create_task(three_stages(request1))</code></pre><p>何时使用 yield from：基本原则很简单，yield from 只能用于 协程 和 asyncio.Future 实例（包括 Task<br>实例）。有些肆意混淆了协程和普通函数的 api 比较棘手。</p><p>驱动协程：只有驱动协程，协程才能做事，而驱动 asyncio.coroutine 装饰的协程有两种方法，要么使用 yield from，要么传给<br>asyncio 包中某个参数为协程或者 Futures 的函数，例如 run_until_complete</p><h4 id="使用-asyncio-包编写服务器"><a href="#使用-asyncio-包编写服务器" class="headerlink" title="使用 asyncio 包编写服务器"></a>使用 asyncio 包编写服务器</h4><p>可以使用 asyncio 编写 tcp/udp 服务器，使用 aiohttp 编写 web 服务器。具体看各自的文档吧。</p><h1 id="19-动态属性-attribute-和特性-property"><a href="#19-动态属性-attribute-和特性-property" class="headerlink" title="19 动态属性(attribute)和特性(property)"></a>19 动态属性(attribute)和特性(property)</h1><p>python 中，数据的属性和处理数据的方法统称为属性（attribute），方法是可调用的属性。特性（property）是不改变类接口的前提下，使用存取方法（读值和设值）修改数据属性。</p><p>统一访问原则：不管服务是由存取还是计算实现的，一个模块提供的所有服务都应该统一的方式使用。</p><h2 id="使用动态属性转换数据"><a href="#使用动态属性转换数据" class="headerlink" title="使用动态属性转换数据"></a>使用动态属性转换数据</h2><h4 id="使用动态属性访问数据"><a href="#使用动态属性访问数据" class="headerlink" title="使用动态属性访问数据"></a>使用动态属性访问数据</h4><pre><code>from collections import abcclass FrozenJSON:    &quot;&quot;&quot;A read-only façade for navigating a JSON-like object    using attribute notation    &quot;&quot;&quot;    def __init__(self, mapping):        self.__data = dict(mapping)  # &lt;1&gt;    def __getattr__(self, name):  # &lt;2&gt;        if hasattr(self.__data, name):            return getattr(self.__data, name)  # &lt;3&gt;        else:            return FrozenJSON.build(self.__data[name])  # &lt;4&gt;    @classmethod    def build(cls, obj):  # &lt;5&gt;        if isinstance(obj, abc.Mapping):  # &lt;6&gt;            return cls(obj)        elif isinstance(obj, abc.MutableSequence):  # &lt;7&gt;            return [cls.build(item) for item in obj]        else:  # &lt;8&gt;            return obj</code></pre><h4 id="处理无效属性名"><a href="#处理无效属性名" class="headerlink" title="处理无效属性名"></a>处理无效属性名</h4><pre><code>def __init__(self, mapping):    self.__data = {}    for key, value in mapping.items():        if keyword.iskeyword(key):  # &lt;1&gt;            key += &apos;_&apos;    # 和 python 重名的关键字加上下划线        self.__data[key] = value</code></pre><h4 id="使用-new-以灵活的方式创建对象"><a href="#使用-new-以灵活的方式创建对象" class="headerlink" title="使用 __new__ 以灵活的方式创建对象"></a>使用 <code>__new__</code> 以灵活的方式创建对象</h4><p>实际上用来构建对象的方法是 <code>__new__</code>，<code>__init__</code> 是初始化方法。<code>__new__</code> 必须返回一个实例，作为 <code>__init__</code><br>方法的第一个参数。</p><pre><code>def __new__(cls, arg):  # &lt;1&gt;    if isinstance(arg, abc.Mapping):        return super().__new__(cls)  # &lt;2&gt;    elif isinstance(arg, abc.MutableSequence):  # &lt;3&gt;        return [cls(item) for item in arg]    else:        return arg</code></pre><h2 id="使用特性验证属性"><a href="#使用特性验证属性" class="headerlink" title="使用特性验证属性"></a>使用特性验证属性</h2><pre><code>class LineItem:    def __init__(self, description, weight, price):        self.description = description        self.weight = weight  # &lt;1&gt;        self.price = price    def subtotal(self):        return self.weight * self.price    @property  # &lt;2&gt;    def weight(self):  # &lt;3&gt;        return self.__weight  # &lt;4&gt;    @weight.setter  # &lt;5&gt;    def weight(self, value):        if value &gt; 0:            self.__weight = value  # &lt;6&gt;        else:            raise ValueError(&apos;value must be &gt; 0&apos;)  # &lt;7&gt;</code></pre><h2 id="解析-property"><a href="#解析-property" class="headerlink" title="解析 property"></a>解析 property</h2><p>property 签名</p><pre><code>class property(fget=None, fset=None, fdel=None, doc=None)</code></pre><ul><li>特性会覆盖实例属性。特性都是【类属性】，但是特性管理的其实是实例属性的存取。obj.attr 这样的表达式不会从 obj 开始寻找<br>attr，而是从 <code>obj.__class__</code> 开始，且仅当类中没有 attr 的属性时， python 才会在 obj 实例中寻找。</li></ul><h2 id="定义一个特性工厂函数"><a href="#定义一个特性工厂函数" class="headerlink" title="定义一个特性工厂函数"></a>定义一个特性工厂函数</h2><pre><code>def quantity(storage_name):  # &lt;1&gt;    def qty_getter(instance):  # &lt;2&gt;        return instance.__dict__[storage_name]  # &lt;3&gt;    def qty_setter(instance, value):  # &lt;4&gt;        if value &gt; 0:            instance.__dict__[storage_name] = value  # &lt;5&gt;        else:            raise ValueError(&apos;value must be &gt; 0&apos;)    return property(qty_getter, qty_setter)  # &lt;6&gt;class LineItem:    weight = quantity(&apos;weight&apos;)  # &lt;1&gt;    price = quantity(&apos;price&apos;)  # &lt;2&gt;    def __init__(self, description, weight, price):        self.description = description        self.weight = weight  # &lt;3&gt;        self.price = price    def subtotal(self):        return self.weight * self.price  # &lt;4&gt;</code></pre><h2 id="处理属性删除操作"><a href="#处理属性删除操作" class="headerlink" title="处理属性删除操作"></a>处理属性删除操作</h2><pre><code>class BlackKnight:  def __init__(self):      self.members = [&apos;an arm&apos;, &apos;another arm&apos;,                      &apos;a leg&apos;, &apos;another leg&apos;]      self.phrases = [&quot;&apos;Tis but a scratch.&quot;,                      &quot;It&apos;s just a flesh wound.&quot;,                      &quot;I&apos;m invincible!&quot;,                      &quot;All right, we&apos;ll call it a draw.&quot;]  @property  def member(self):      print(&apos;next member is:&apos;)      return self.members[0]  @member.deleter  def member(self):      text = &apos;BLACK KNIGHT (loses {})\n-- {}&apos;      print(text.format(self.members.pop(0), self.phrases.pop(0)))</code></pre><h2 id="处理属性的重要属性和函数"><a href="#处理属性的重要属性和函数" class="headerlink" title="处理属性的重要属性和函数"></a>处理属性的重要属性和函数</h2><h5 id="影响属性处理方式的特殊属性"><a href="#影响属性处理方式的特殊属性" class="headerlink" title="影响属性处理方式的特殊属性"></a>影响属性处理方式的特殊属性</h5><ul><li><code>__class__</code>: 对象所属类的引用。 <code>obj.__class__</code> 与 type(obj) 作用相同。python的某些特殊方法比如<br><code>__getattr__</code>，只在对象的类中寻找，而不在实例中寻找</li><li><code>__dict__</code>: 存储对象或者类的可写属性。</li><li><code>__slots__</code>: 字符串tuple，限制允许有的属性。</li></ul><h4 id="处理属性的内置函数"><a href="#处理属性的内置函数" class="headerlink" title="处理属性的内置函数"></a>处理属性的内置函数</h4><ul><li>dir: 列出对象的大多数属性</li><li>getattr: 从 obj 对象中获取对应名称的属性。获取的属性可能来自对象所属的类或者超类。</li><li>hasattr: 判断对象中存在指定的属性</li><li>setattr: 创建新属性或者覆盖现有属性</li><li>vars： 返回对象的 <code>__dict__</code> 属性</li></ul><h4 id="处理属性的特殊方法"><a href="#处理属性的特殊方法" class="headerlink" title="处理属性的特殊方法"></a>处理属性的特殊方法</h4><ul><li><code>__delatttr__(self, name)</code> 使用 del 删除属性就会调用这个方法</li><li><code>__dir__(self)</code>: 把对象传给 dir 函数时候调用</li><li><code>__getattr__</code>: 仅当获取指定的属性失败，搜索过 obj、Class、和超类之后调用</li><li><code>__getattribute__</code>: 尝试获取指定的属性时总会调用这个方法，寻找的属性是特殊属性或者特殊方法时候除外。为了防止获取 obj<br>的属性无限递归， <code>__getattribute__</code> 方法的实现要使用  <code>super().__getattribute__(obj, name)</code></li><li><code>__setattr__</code>: 尝试设置指定的属性总会调用<h1 id="20-属性描述符"><a href="#20-属性描述符" class="headerlink" title="20 属性描述符"></a>20 属性描述符</h1></li></ul><p>描述符是对多个属性运用相同存储逻辑的一种方式。例如 orm 中的字段类型是描述符。描述符是实现了特定协议的类，这个协议包括<br><code>__get__ __set__ __delete__</code> 方法。描述符的用法是创建一个实例，作为另一个类的类属性。</p><pre><code>class Quantity:  # &lt;1&gt;    def __init__(self, storage_name):        self.storage_name = storage_name  # &lt;2&gt;    def __set__(self, instance, value):  # &lt;3&gt;        if value &gt; 0:            instance.__dict__[self.storage_name] = value  # &lt;4&gt;        else:            raise ValueError(&apos;value must be &gt; 0&apos;)class LineItem:    weight = Quantity(&apos;weight&apos;)  # &lt;5&gt;    price = Quantity(&apos;price&apos;)  # &lt;6&gt;    def __init__(self, description, weight, price):  # &lt;7&gt;        self.description = description        self.weight = weight        self.price = price    def subtotal(self):        return self.weight * self.price</code></pre><p>覆盖型描述符：实现 <code>__set__</code>  方法的描述符属于覆盖型描述符。<br>非覆盖型描述符：没有实现 <code>__set__</code> 方法的描述符。</p><p>方法是描述符</p><h4 id="描述符用法建议："><a href="#描述符用法建议：" class="headerlink" title="描述符用法建议："></a>描述符用法建议：</h4><ul><li>使用 property 以保持简单: 内置的 property 实现的其实是覆盖型描述符</li><li>只读描述符必须有 <code>__set__</code> 方法: 如果使用描述符类实现只读属性， <code>__get__ __set__</code> 两个方法必须定义，否则实例的同名属性会遮盖描述符。只读属性的 <code>__set__</code> 只需抛出 AttributeError 异常，并提供合适的错误消息</li><li>用于验证的描述符可以只有 <code>__set__</code></li><li>只有 <code>__get__</code> 方法的描述符可以实现高效缓存</li><li>非特殊的方法可以被实例属性覆盖</li></ul><h1 id="21-类元编程"><a href="#21-类元编程" class="headerlink" title="21 类元编程"></a>21 类元编程</h1><p>元编程是指在运行时创建或者定制类的技术。除非开发框架，否则不要编写元类<br>类装饰器能以较为简单的的方式做到需要使用元类去做的事情-创建时定制类。缺点是无法继承</p><h4 id="导入时和运行时比较"><a href="#导入时和运行时比较" class="headerlink" title="导入时和运行时比较"></a>导入时和运行时比较</h4><p>python 中的 import 不只是声明，进程首次导入模块时，还会运行所导入模块中的全部顶层代码。导入时，解释器会执行执行每个类的定义体.<br>（原书有段代码示例非常好地解释了导入的问题）</p><h4 id="元类基础"><a href="#元类基础" class="headerlink" title="元类基础"></a>元类基础</h4><p>感觉这一章写得不如笔者之前写的一篇博客《简单的python元类》好理解。</p><pre><code>class EntityMeta(type):    &quot;&quot;&quot;Metaclass for business entities with validated fields&quot;&quot;&quot;    def __init__(cls, name, bases, attr_dict):        super().__init__(name, bases, attr_dict)  # &lt;1&gt;        for key, attr in attr_dict.items():  # &lt;2&gt;            if isinstance(attr, Validated):                type_name = type(attr).__name__                attr.storage_name = &apos;_{}#{}&apos;.format(type_name, key)class Entity(metaclass=EntityMeta):  # &lt;3&gt;    &quot;&quot;&quot;Business entity with validated fields&quot;&quot;&quot;</code></pre><h4 id="元类的特殊方法-prepare"><a href="#元类的特殊方法-prepare" class="headerlink" title="元类的特殊方法 __prepare__"></a>元类的特殊方法 <code>__prepare__</code></h4><p>某些应用中可能想知道属性定义的顺序，解决办法是使用 python3 引入的 <code>__prepare__</code> 。这个特殊方法只在元类中有用，而且必须是类方法。解释器调用元类的 <code>__new__</code> 之前会先调用 <code>__prepare__</code>，使用类定义体中的属性创建映射。<br>元类构建新类时， <code>__prepare__</code> 方法返回的映射会传给 <code>__new__</code> 的最后一个参数，然后再传给  <code>__init__</code> 方法。</p><pre><code>class EntityMeta(type):    &quot;&quot;&quot;Metaclass for business entities with validated fields&quot;&quot;&quot;    @classmethod    def __prepare__(cls, name, bases):    # py3, must be a class method        return collections.OrderedDict()  # &lt;1&gt; return empty OrderedDict, where the class attritubes will be stored    def __init__(cls, name, bases, attr_dict):        super().__init__(name, bases, attr_dict)        cls._field_names = []  # &lt;2&gt;        for key, attr in attr_dict.items():  # &lt;3&gt;    # in order            if isinstance(attr, Validated):                type_name = type(attr).__name__                attr.storage_name = &apos;_{}#{}&apos;.format(type_name, key)                cls._field_names.append(key)  # &lt;4&gt;class Entity(metaclass=EntityMeta):    &quot;&quot;&quot;Business entity with validated fields&quot;&quot;&quot;    @classmethod    def field_names(cls):  # &lt;5&gt;        for name in cls._field_names:            yield name</code></pre><h4 id="元类使用场景"><a href="#元类使用场景" class="headerlink" title="元类使用场景"></a>元类使用场景</h4><ul><li>验证属性</li><li>一次把装饰器依附到多个方法上</li><li>序列化对象或者转换数据</li><li>对象关系映射（ORM框架）</li><li>基于对象的持久存储</li><li>动态转换使用其他语言编写的类结构</li></ul><h4 id="类作为对象"><a href="#类作为对象" class="headerlink" title="类作为对象"></a>类作为对象</h4><ul><li><code>cls.__bases__</code>: 类的基类组成的元祖</li><li><code>cls.__qualname__</code>: py3 引入，值是类或函数的限定名称，即从模块的全局作用域到类的点分路径</li><li><code>cls.__subclasses__()</code>： 返回一个list，包含类的直接子类。其实现使用弱引用，防止超类和子类之间出现循环引用。这个方法返回的列表是内存里现存的子类。</li><li><code>cls.mro()</code>: 构建类时，如果需要获取存储在类属性 <code>__mro__</code> 中的超类元组，解释器会调用这个方法。元类可以覆盖这个方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Python is a language for consenting adults. —Alan Runyan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重新看了下 《Fluent Python》，依旧还是很多东西没能消化完。简单记录下吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://ningning.today/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>知乎是怎么运行 tornado web 服务的</title>
    <link href="http://ningning.today/2017/11/28/python/tornado-use-gevent-wsgi/"/>
    <id>http://ningning.today/2017/11/28/python/tornado-use-gevent-wsgi/</id>
    <published>2017-11-28T13:31:33.000Z</published>
    <updated>2018-01-25T15:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>You build it, you run it. - Werner Vogels</p></blockquote><p>现在很多互联网公司采用了微服务架构，将业务拆分，保持代码仓库尽量精简。同时一个小团队负责开发和维护一个服务，提升了开发和部署效率（软件本身的组织结构与软件团队的组织结构式一致的，即康威定律）。 知乎很多业务后端采用了 python web 框架 tornado，都是开源的、成熟稳定的技术（虽然笔者更喜欢 flask 全家桶）</p><a id="more"></a><hr><h1 id="用-gunicorn-gevent-跑-tornado-app"><a href="#用-gunicorn-gevent-跑-tornado-app" class="headerlink" title="用 gunicorn + gevent 跑 tornado app"></a>用 gunicorn + gevent 跑 tornado app</h1><p>先来写个无聊的 tornado handler，统计多个网站页面的 html 长度之和。原始代码如下，为了简单起见省去所有异常处理 (tornado_app.py):</p><pre><code>import gevent.pywsgiimport requestsimport tornado.wsgifrom tornado.web import Application, RequestHandlerdef get_html_length(url):    return len(requests.get(url).text)URLS = [&apos;https://www.baidu.com?page={}&apos;.format(i) for i in range(100)]class CurlHandler(RequestHandler):    def get(self):        length = 0        for url in URLS:            length += get_html_length(url)        self.write(str(length))def get_tornado_application():    application = Application(        [            (r&apos;/&apos;, CurlHandler),        ],        debug=True    )    return applicationdef get_wsgi_application():    application = get_tornado_application()    return tornado.wsgi.WSGIAdapter(application)app = get_wsgi_application()def run():    server = gevent.pywsgi.WSGIServer((&apos;&apos;, 8000), app)    server.serve_forever()if __name__ == &apos;__main__&apos;:    run()</code></pre><p>如果安装了 gevent，可以直接 <code>python tornado_app.py</code> 运行此 app。不过我们一般使用 gunicorn 指定 worker 为 gevent 来运行 tornado app。<br>在命令行中用如下命令启动(实际上就是用的 gevent wsgi):</p><p><code>gunicorn tornado_app:app -b 0.0.0.0:8000 -w 4 -k gevent</code></p><p>一般一个请求的流程如下：http request -&gt; Nginx -&gt; HAProxy -&gt; gunicorn(gevent wsgi) -&gt; tornado app<br>由于是容器部署，会根据容器的 cpu 和内存资源适当调整 worker 的值，具体需要根据真实的部署环境实测一把。</p><hr><h1 id="在-tornado-中使用-gevent-并发"><a href="#在-tornado-中使用-gevent-并发" class="headerlink" title="在 tornado 中使用 gevent 并发"></a>在 tornado 中使用 gevent 并发</h1><p>mysql 连接上使用了 PyMySQL，用 sqlalchemy core 请求数据，纯 python 实现的 mysql driver 支持被 gevent patch</p><blockquote><p>Pure python driver support gevent’s monkey patch, so they support cooperative multitasking using coroutines. That means the main thread won’t be block by MySQL calls when you use PyMySQL</p></blockquote><p>经常在一个 api 接口里需要请求多个数据(多个数据库请求、rpc调用、网络请求等)，比如用户、文章等，这个时候如果不是并发请求数据，速度将是不可接受的。我们用 gevent 来实现并发请求，具体大家可以参考 gevent 的文档。一个简单的并发请求的例子如下，实际上很简单，我们使用 gevent.pool (池(pool)是一个为处理数量变化并且需要限制并发的greenlet而设计的结构。):</p><pre><code>class PoolCurlHandler(RequestHandler):    def get(self):        length = 0        pool = gevent.pool.Pool(20)        res = pool.map(get_html_length, URLS)        length = sum(res)        self.write(str(length))</code></pre><p>完整的代码如下:</p><pre><code>import gevent.pywsgiimport requestsimport tornado.wsgifrom tornado.web import Application, RequestHandlerdef get_html_length(url):    return len(requests.get(url).text)URLS = [&apos;https://www.baidu.com?page={}&apos;.format(i) for i in range(100)]class CurlHandler(RequestHandler):    def get(self):        length = 0        for url in URLS:            length += get_html_length(url)        self.write(str(length))class PoolCurlHandler(RequestHandler):    def get(self):        length = 0        pool = gevent.pool.Pool(20)        res = pool.map(get_html_length, URLS)        length = sum(res)        self.write(str(length))def get_tornado_application():    application = Application(        [            (r&apos;/&apos;, CurlHandler),            (r&apos;/pool&apos;, PoolCurlHandler),        ],        debug=True    )    return applicationdef get_wsgi_application():    application = get_tornado_application()    return tornado.wsgi.WSGIAdapter(application)app = get_wsgi_application()def run():    server = gevent.pywsgi.WSGIServer((&apos;&apos;, 8000), app)    server.serve_forever()if __name__ == &apos;__main__&apos;:    run()</code></pre><p>启动 app 后用我们请求看下差距：</p><pre><code>time curl http://localhost:8000/time curl http://localhost:8000/pool</code></pre><p>至少能看到数倍的时间差距。</p><hr><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://link.zhihu.com/?target=http%3A//www.gevent.org/" target="_blank" rel="noopener">What is gevent? - gevent 1.3.0.dev0 documentation</a></p><p><a href="http://link.zhihu.com/?target=https%3A//github.com/Tin/sqlalchemy-gevent-mysql-drivers-comparison" target="_blank" rel="noopener">Tin/sqlalchemy-gevent-mysql-drivers-comparison</a></p><p><a href="http://link.zhihu.com/?target=http%3A//techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/" target="_blank" rel="noopener">Asynchronous Python and Databases</a> - sqlalchemy 作者的文章</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;You build it, you run it. - Werner Vogels&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在很多互联网公司采用了微服务架构，将业务拆分，保持代码仓库尽量精简。同时一个小团队负责开发和维护一个服务，提升了开发和部署效率（软件本身的组织结构与软件团队的组织结构式一致的，即康威定律）。 知乎很多业务后端采用了 python web 框架 tornado，都是开源的、成熟稳定的技术（虽然笔者更喜欢 flask 全家桶）&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://ningning.today/categories/python/"/>
    
    
      <category term="tornado" scheme="http://ningning.today/tags/tornado/"/>
    
      <category term="gevent" scheme="http://ningning.today/tags/gevent/"/>
    
  </entry>
  
  <entry>
    <title>From Vim To Neovim [视频]</title>
    <link href="http://ningning.today/2017/10/14/tools/from-vim-to-neovim/"/>
    <id>http://ningning.today/2017/10/14/tools/from-vim-to-neovim/</id>
    <published>2017-10-14T08:22:34.000Z</published>
    <updated>2017-10-15T05:28:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Think more, type less. Aim for minimalism, fewer states, less mutability, and just enough code for the known, relevant parts of the problem.</p></blockquote><p>最近一直忙着写公司业务代码(大家应该发现知乎可以上传和观看小视频啦^_^)，很久没更新博客了。不过笔者最近从 vim 迁移到了 neovim，花了几个晚上的时间修改配置文件，现在已经可以全面在 neovim 下写 python 了，就简单介绍下 neovim 吧。以前使用 vim7.4 还是有一些比较X疼的地方的，比如复制粘贴问题，大文件卡顿，一些插件会导致 vim 被 freeze 等，切到 neovim 之后使用体验比以前好了很多，没白瞎我几个晚上修改配置（之前自定义了很多快捷键也安装了很多插件）。</p><a id="more"></a><p>之前使用过一段时间的 Pycharm，后来还是不太习惯，又切回了 vim，平常用的是 tmux + vim 工作流。一般我会开多个 tmux session，每个 session 里打开一个项目，多的时候会同时打开很多项目(甚至十来个代码仓库)，每个 session 下会建立多个窗口，一个大窗口用 vim 编辑文件，其他的窗口会分开多个屏幕（tmux panel），一些用来跑测试，一些用来启动 server，一些用来执行 git 命令等。这种工作方式的好处就是可以在本地机器和开发机上实现一致的开发体验(以前团队有直接在服务器写代码的)，并且可以大大减少对鼠标的使用，而且很省资源， 同时打开十几个项目也占不了多少内存，也方便在多项目中快速切换。</p><hr><h2 id="安装-neovim"><a href="#安装-neovim" class="headerlink" title="安装 neovim"></a>安装 neovim</h2><p>官方文档比较详细了，无论你用什么平台都可以，笔者工作之余自己使用的是一台 14 年的低配 mac air（这应该也是我没法用 Pycharm 的一个原因），不过依旧可以在终端里用 vim 撸代码。</p><p><code>brew install neovim</code></p><hr><h2 id="懒人配置"><a href="#懒人配置" class="headerlink" title="懒人配置"></a>懒人配置</h2><p>在网上搜到一个强大到有点变态的 neovim 配置，用一个项目管理整个配置文件，笔者 clone<br>了一份新建个分之然后调教了一下，照着以前的配置改了下，用着比较顺手了(不过已经和原生的 vim 使用起来完全不一样了)。通过插件可以支持任何主流前后端编程语言，当前这个配置支持 python，go和前端 html，css，js 等。</p><p><a href="https://github.com/PegasusWang/vim-config/tree/wnn" target="_blank" rel="noopener">https://github.com/PegasusWang/vim-config/tree/wnn</a></p><p>只需要把这个配置 clone 到 ~/.config/nvim 目录下就好。</p><hr><h2 id="tmux-vim-workflow"><a href="#tmux-vim-workflow" class="headerlink" title="tmux + vim workflow"></a>tmux + vim workflow</h2><p>在我的老 mac 上给大家录制了一个视频（献丑了），有啥好用的工具可以一起交流下。油管上搜 “vim tmux workflow”<br>能看到一些类似的视频。全程都是键盘操作，全部在 terminal 下完成。演示步骤大概如下：</p><ol><li>从 github 上 clone tornado 项目，包含 demos</li><li>新建 tmux session 命名为 tornado</li><li>打开两个 window，其中一个 window 分屏，一个用来跑 server，执行 shell 命令等，一个用来编辑文件。（其实 neovim 支持在 vim 里起 terminal）</li><li>使用 nvim 修改 py 文件。插件 python-mode 集成了 autopep8, pylint, isort 等工具，帮助我们执行格式化、lint、导入包排序等功能。</li><li>在 tmux 中切换 panel 看效果</li></ol><video width="480" height="320" controls="controls"><br>    <source src="http://7ktuty.com1.z0.glb.clouddn.com/neovim_python.mp4" type="video/mp4"><br></video>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Think more, type less. Aim for minimalism, fewer states, less mutability, and just enough code for the known, relevant parts of the problem.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一直忙着写公司业务代码(大家应该发现知乎可以上传和观看小视频啦^_^)，很久没更新博客了。不过笔者最近从 vim 迁移到了 neovim，花了几个晚上的时间修改配置文件，现在已经可以全面在 neovim 下写 python 了，就简单介绍下 neovim 吧。以前使用 vim7.4 还是有一些比较X疼的地方的，比如复制粘贴问题，大文件卡顿，一些插件会导致 vim 被 freeze 等，切到 neovim 之后使用体验比以前好了很多，没白瞎我几个晚上修改配置（之前自定义了很多快捷键也安装了很多插件）。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://ningning.today/categories/tools/"/>
    
    
      <category term="vim" scheme="http://ningning.today/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>编写简单的 python web 框架</title>
    <link href="http://ningning.today/2017/08/05/web/build-python-web-framework/"/>
    <id>http://ningning.today/2017/08/05/web/build-python-web-framework/</id>
    <published>2017-08-05T09:22:02.000Z</published>
    <updated>2018-01-01T08:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reinventing the wheel is great if your goal is to learn more about wheels.” – James Tauber</p></blockquote><p>  Python web 框架众多，大而全的 django，小巧的 flask，支持异步的 tornado 等，可能是因为用 python 实现个 web 框架太简单了吧，python 的框架层出不穷。 下边一步步介绍下一个 web 框架的基础组成，以及如何写个简单的 web 框架(使用 python3)，从而了解下 web 框架的工作原理。</p><a id="more"></a><hr><h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>首先要了解 WSGI 规范的概念，WSGI(Web Server Gateway Interface)规范描述了web server(Gunicorn,uWSGI等)如何与web application(flask, django等)交互、web application如何处理请求，定义在 <a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">pep 3333</a>。正是有了 WSGI 规范，我们才能在任意 web server 上跑各种 web 应用。WSGI API 定义看起来很简单:</p><pre><code>def application(environ, start_response)</code></pre><ul><li>application 就是 WSGI app，一个可调用对象</li><li>参数:<ul><li>environ: 一个包含 WSGI 环境信息的字典，由 WSGI 服务器提供，常见的 key 有 PATH_INFO，QUERY_STRING 等</li><li>start_response: 生成 WSGI 响应的回调函数，接收两个参数，status 和 headers</li></ul></li><li>函数返回响应体的迭代器</li></ul><p>下面举个简单的例子，比如一个返回 hello world 的应用：</p><pre><code>def application(environ, start_response):    status = &apos;200 OK&apos;    headers = [(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;)]    start_response(status, headers)    return  [b&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;]</code></pre><p>接下来我们使用 python 内置的 wsgi server 来跑这个应用:</p><pre><code># 导入python内置的WSGI serverfrom wsgiref.simple_server import make_serverdef application(environ, start_response):    print(environ)    # 我建议你打出来这个字典看看有哪些参数    status = &apos;200 OK&apos;    headers = [(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;)]    start_response(status, headers)    return [b&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;]    # WSGI applications return iterables that yield bytesif __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;127.0.0.1&apos;, 8888, application)    httpd.serve_forever()</code></pre><p>运行这个文件，使用浏览器或者 curl 等工具访问 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> 就能看到结果了。如果你打出来了 environ，能看到很多由 WSGI 服务器提供的环境信息，常见的有以下几个:</p><table><thead><tr><th>Key</th><th>Contents</th></tr></thead><tbody><tr><td>PATH_INFO</td><td>请求路径，比如 /foo/bar/</td></tr><tr><td>QUERY_STRING</td><td>GET 请求参数，比如 foo=bar&amp;bar=spam，我们可以从这个变量中获取用户的请求参数</td></tr><tr><td>HTTP_{HEADER}</td><td>http 头信息，比如 HTTP_HOST 等</td></tr><tr><td>wsgi.input</td><td>包含请求内容的类文件对象(file-like object)，比如 post 请求数据</td></tr></tbody></table><p>接下来看看 start_response 这个可调用对象：</p><pre><code>status = &apos;200 OK&apos;headers = [(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;)]start_response(status, headers)</code></pre><p>start_response 接收两个参数 :</p><pre><code>start_response(status, headers)&quot;&quot;&quot;status: 一个包含 http 状态码和描述的字符串, 比如 &apos;200 OK&apos;headers: 一个包含 http 头的元祖列表，[(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;)]&quot;&quot;&quot;</code></pre><p>最后 WSGI 应用返回一个可迭代的 bytes 序列，比如</p><pre><code># 注意返回的 bytes 编码要符合你指定的返回头def app(environ, start_response):    # ...    return [b&apos;hello&apos;, b&apos;world&apos;]def app(environ, start_response):    # ...    yield b&apos;hello&apos;    yield b&apos;world&apos;</code></pre><p>到这里我们就知道如何编写一个最简单的 WSGI 应用了，我们做个简单的练习，当用户访问 <a href="http://localhost:8888/?name=John" target="_blank" rel="noopener">http://localhost:8888/?name=John</a> 的时候， 在网页上输出 “Hello John”。代码如下：</p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-from wsgiref.simple_server import make_serverdef application(environ, start_response):    # print(environ)    status = &apos;200 OK&apos;    headers = [(&apos;Content-Type&apos;, &apos;text/html; charset=utf8&apos;)]    query_string = environ[&apos;QUERY_STRING&apos;]    # 这里是 &quot;name=John&quot;    name = query_string.split(&quot;=&quot;)[1]    # 从查询字符串 &quot;name=John&quot; 里获取 &quot;John&quot;    start_response(status, headers)    return [b&quot;&lt;h1&gt;Hello, {}!&lt;/h1&gt;&quot;.format(name)]if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;127.0.0.1&apos;, 8888, application)    httpd.serve_forever()</code></pre><hr><h2 id="抽象-Request-和-Response-对象"><a href="#抽象-Request-和-Response-对象" class="headerlink" title="抽象 Request 和 Response 对象"></a>抽象 Request 和 Response 对象</h2><p>前面看到我们可以直接编写符合 WSGI 规范的应用，但是要做的工作量比较多，比如我们得直接去处理 query string，大部分 web 框架会抽象出 Request/Response 对象，这样一个 web 应用看起来会像这样：</p><pre><code>from somewhere import Responsedef application(request):    # ...    return Response(&apos;blablabla&apos;)</code></pre><p>这样做的好处就是概念上更加清晰，测试更加容易，大部分的 web 框架都采用了类似抽象。接下来我们看看 web 框架是如何映射 WSGI 到 Request/Response 对象的。我们的代码结构将类似这样：</p><pre><code>class Request: ...class Response: ...def request_response_application(function):    def application(environ, start_response):    # ...    return application@request_response_applicationdef application(request):    # ...    return Response(...)</code></pre><p>先来实现 Request 对象，思路是这样的，我们把 environ 作为构造函数的参数传过去，这样我们就能利用各种子函数来获取我们需要的值。<br>比如请求地址(HTTP_HOST)，请求参数(QUERY_STRING) 等。比如我们可以用一个函数把 QUERY_STRING 字符串解析后作为 请求参数字典返回，这样使用的时候就方便很多。</p><pre><code>import urllib.parseclass Request:    def __init__(self, environ):        self.environ = environ    @property    def args(self):        &quot;&quot;&quot; 把查询参数转成字典形式 &quot;&quot;&quot;        get_arguments = urllib.parse.parse_qs(self.environ[&apos;QUERY_STRING&apos;])        return {k: v[0] for k, v in get_arguments.items()}</code></pre><p>Response 对象需要返回的值有返回内容，状态码，字符编码，返回类型等。大概如下:</p><pre><code>import http.clientfrom wsgiref.headers import Headersclass Response:    def __init__(self, response=None, status=200, charset=&apos;utf-8&apos;, content_type=&apos;text/html&apos;):        self.response = [] if response is None else response        self.charset = charset        self.headers = Headers()        content_type = &apos;{content_type}; charset={charset}&apos;.format(content_type=content_type, charset=charset)        self.headers.add_header(&apos;content-type&apos;, content_type)        self._status = status    @property    def status(self):        status_string = http.client.responses.get(self._status, &apos;UNKNOWN&apos;)        return &apos;{status} {status_string}&apos;.format(status=self._status, status_string=status_string)    def __iter__(self):        for val in self.response:            if isinstance(val, bytes):                yield val            else:                yield val.encode(self.charset)</code></pre><p>现在 Request/Response 对象都有啦，还差一个转换函数，用来把之前的 WSGI 函数转换成使用我们的 Request/Response 对象的函数，我们写个装饰器来实现这个功能：</p><pre><code>def request_response_application(func):    def application(environ, start_response):        request = Request(environ)        response = func(request)        start_response(response.status, response.headers.items())        return iter(response)    return application</code></pre><p>大功告成，来试一把：</p><pre><code>@request_response_applicationdef application(request):    name = request.args.get(&apos;name&apos;, &apos;default_name&apos;)    # 获取查询字符串中的 name    return Response([&apos;&lt;h1&gt;hello {name}&lt;/h1&gt;&apos;.format(name=name)])if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;127.0.0.1&apos;, 8888, application)    httpd.serve_forever()</code></pre><p>其实如果你用过 flask 你一定知道 Werkzeug，一套 flask 依赖的 WSGI 工具集。我们换用 Werkzeug 来写上面的应用几乎一样（嗯，就是照葫芦画瓢）:</p><pre><code>from werkzeug.wrappers import Request, Response@Request.applicationdef application(request):    name = request.args.get(&apos;name&apos;, &apos;PyCon&apos;)    return Response([&apos;&lt;h1&gt;hello {name}&lt;/h1&gt;&apos;.format(name=name)])</code></pre><hr><h2 id="路由-Routing"><a href="#路由-Routing" class="headerlink" title="路由 Routing"></a>路由 Routing</h2><p>前面我们实现了 Request/Response 对象，不过好像还缺点什么，似乎只能处理一个 url，web 框架都可以处理很多请求路径，然后把不同的请求路径映射到不同的处理逻辑。<br>比如:</p><ul><li><a href="https://www.instagram.com/{username}/" target="_blank" rel="noopener">https://www.instagram.com/{username}/</a> 获取某个用户的个人页</li><li><a href="https://www.instagram.com/p/{id}/" target="_blank" rel="noopener">https://www.instagram.com/p/{id}/</a> 获取某个图片</li></ul><p>大部分 web 框架实现了基于匹配的路由，将 url 模式与一个可调用对象匹配，比如 flask 的路由方式：</p><pre><code>@app.route(&quot;/user/&lt;username&gt;/photos/&lt;int:photo_id&gt;&quot;)def photo_detail(username, photo_id):    # ...</code></pre><p>我们也来写个 Router 实现路由功能：</p><pre><code>def hello(request, name):    return Response(f&quot;&lt;h1&gt;Hello, {name}&lt;/h1&gt;&quot;)def goodbye(request, name):    return Response(f&quot;&lt;h1&gt;Goodbye, {name}&lt;/h1&gt;&quot;)routes = Router()routes.add_route(r&apos;/hello/(.*)/$&apos;, hello)routes.add_route(r&apos;/goodbye/(.*)/$&apos;, goodbye)</code></pre><p>Router 实现方式如下，维护一个请求路径到可调用对象的 tuple 列表，每次从列表中查找请求路径是否满足当前 pattern，<br>满足则调用当前 pattern 对应的可调用对象进行处理。否则抛个异常返回 404 response。实现代码:</p><pre><code>class NotFoundError(Exception):    &quot;&quot;&quot; url pattern not found &quot;&quot;&quot;    passclass Router:    def __init__(self):        self.routing_table = []    # 保存 url pattern 和 可调用对象    def add_route(self, pattern, callback):        self.routing_table.append((pattern, callback))    def match(self, path):        for (pattern, callback) in self.routing_table:            m = re.match(pattern, path)            if m:                return (callback, m.groups())        raise NotFoundError()def hello(request, name):    return Response(&quot;&lt;h1&gt;Hello, {name}&lt;/h1&gt;&quot;.format(name=name))def goodbye(request, name):    return Response(&quot;&lt;h1&gt;Goodbye, {name}&lt;/h1&gt;&quot;.format(name=name))routers = Router()routers.add_route(r&apos;/hello/(.*)/$&apos;, hello)routers.add_route(r&apos;/goodbye/(.*)/$&apos;, goodbye)def application(environ, start_response):    try:        request = Request(environ)        callback, args = routers.match(request.path)        response = callback(request, *args)    except NotFoundError:        response = Response(&quot;&lt;h1&gt;Not found&lt;/h1&gt;&quot;, status=404)    start_response(response.status, response.headers.items())    return iter(response)if __name__ == &apos;__main__&apos;:    httpd = make_server(&apos;127.0.0.1&apos;, 8888, application)    httpd.serve_forever()</code></pre><p>当然了，如果你喜欢类似 flask 那样的装饰器实现，我们也可以使用类的 <code>__call__</code> 方法:</p><pre><code>class DecoratorRouter:    def __init__(self):        self.routing_table = []    # 保存 url pattern 和 可调用对象    def match(self, path):        for (pattern, callback) in self.routing_table:            m = re.match(pattern, path)            if m:                return (callback, m.groups())        raise NotFoundError()    def __call__(self, pattern):        def _(func):            self.routing_table.append((pattern, func))        return _routers = DecoratorRouter()@routers(r&apos;/hello/(.*)/$&apos;)def hello(request, name):    return Response(&quot;&lt;h1&gt;Hello, {name}&lt;/h1&gt;&quot;.format(name=name))@routers(r&apos;/goodbye/(.*)/$&apos;)def goodbye(request, name):    return Response(&quot;&lt;h1&gt;Goodbye, {name}&lt;/h1&gt;&quot;.format(name=name))</code></pre><p>我们运行下这个文件，然后执行 <code>curl http://127.0.0.1:8888/hello/laowang/</code> 和 <code>curl http://127.0.0.1:8888/goodbye/laowang/</code> 就能看到不同结果了，是不是挺简单。</p><hr><h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>上面我们差不多实现了一个简单的 web 框架，现代 web 框架大部分都是使用的 MVC 模式：</p><ul><li>Model: 数据存储、验证逻辑</li><li>Controller: 行为和业务逻辑</li><li>View: 展示层 (html)。大部分 web 框架都会提供一个模板引擎用来渲染页面(mako, Jinja2等)，如果是做前后端分离或者仅提供 api 接口就不需要了(貌似这是个趋势，越来越多渲染放在了非服务端)。这个时候通常需要一个数据格式化层(Formatter)，一个开源实现是 marshmallow 库，用来决定返回什么样的数据和格式。</li></ul><p>实际上我个人习惯这么分层次，http 请求 -&gt; 表单验证层(wtforms 等库) -&gt; views -&gt; controllers (业务逻辑层) -&gt; models (ORM 层) -&gt; formatters (marshmallow 等格式化输出)。大概就是一个请求到了，先用表单验证等库校验参数的类型、范围等，接下来调用 controllers 里的业务逻辑，controllers 层会调用 orm 层获取数据后处理，之后返回的数据使用 marshmallow 等格式化库输出 json 数据。总体来说还是比较清晰的，之前碰到很多项目都是校验、业务逻辑、数据获取揉在一起，代码相当难看。</p><p>MVC 模式常用的几种方式:</p><pre><code>def hello(request, name):    t = load_template(&quot;say_hello.html&quot;)    return Response(t.render(name=name))def hello(request, name)    return TemplateResponse(&quot;say_hello.html&quot;, name=name)@app.route(&quot;/hello/&lt;name&gt;&quot;, template=&quot;say_hello.html&quot;)def hello(request, name):    return {&quot;name&quot;: name}</code></pre><p>模板引擎大致的原理就是使用标记符号等替换填充的数据(content)，格式化成字符串后返回。有点类似于 format 函数， 比如</p><pre><code>&quot;&lt;h1&gt;hello {name}&lt;/h1&gt;&quot;.format(name=name)</code></pre><hr><h2 id="ORM-To-ORM-or-not-to-ORM"><a href="#ORM-To-ORM-or-not-to-ORM" class="headerlink" title="ORM : To ORM or not to ORM ?"></a>ORM : To ORM or not to ORM ?</h2><p>ORM(Object Relatetional Mapping): 对象关系映射，就是把关系数据库中的表映射到程序语言中的一个对象，这样我们就能以更加面向对象的方式操作数据库中的数据。在 python 中比较著名的 ORM 框架就是 sqlalchemy，还有轻量点的 peewee，以及 django 自带的 ORM等。笔者所经历过的项目中基本上都用了 sqlalchemy，直接使用其 ORM 或者抽象层次更低一些的 core。包括知乎、reddit 等也是使用了 sqlalchemy。ORM 的编写需要使用元类的知识，如果你感兴趣，可以参考这篇文章。<a href="https://zhuanlan.zhihu.com/p/28333506" target="_blank" rel="noopener">『简单』的 python 元类</a></p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>上面基本列举了一个 web 框架的基础结构，当然实现一个 web 应用还有很多需要做，比如表单验证，用户认证、国际化、测试、部署、web 服务器等。笔者曾经用过 flask 全家桶（各种插件），感觉开发效率还是比较高的。这篇文章只是为了让大家了解下一个基础的 web 框架如何实现，有兴趣的可以看看 django、flask、tornado 等比较著名的开源 web 框架实现。</p><hr><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="http://www.letiantian.me/2015-09-10-understand-python-wsgi/" target="_blank" rel="noopener">理解Python WSGI</a></p><p><a href="https://jacobian.github.io/pycon2017/#/" target="_blank" rel="noopener">LET’S BUILD A WEB FRAMEWORK!</a></p><p><a href="http://www.bingtel.wang/2017/03/05/PEP-333-Python-Web-Server-Gateway-Interface-v1-0/" target="_blank" rel="noopener">PEP-333-Python-Web-Server-Gateway-Interface-v1-0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Reinventing the wheel is great if your goal is to learn more about wheels.” – James Tauber&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  Python web 框架众多，大而全的 django，小巧的 flask，支持异步的 tornado 等，可能是因为用 python 实现个 web 框架太简单了吧，python 的框架层出不穷。 下边一步步介绍下一个 web 框架的基础组成，以及如何写个简单的 web 框架(使用 python3)，从而了解下 web 框架的工作原理。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《The Art of Readable Code》</title>
    <link href="http://ningning.today/2017/07/22/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/the-art-of-readable-code/"/>
    <id>http://ningning.today/2017/07/22/软件工程/the-art-of-readable-code/</id>
    <published>2017-07-22T05:44:02.000Z</published>
    <updated>2017-07-22T05:57:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代码的写法应当使别人理解它所需的时间最小化。- 可读性基本定理</p></blockquote><p>刚工作那会总喜欢追求一些代码语法糖，感觉有奇淫技巧的代码才是牛逼的。真正开始做项目后才发现代码可读性是如此重要，最近 code review 也因为一些命名问题修改过代码（英文词汇匮乏啊。。。）重新回顾下这本书，争取写出更易维护和可读性高的代码。</p><a id="more"></a><hr><h1 id="1-代码应当易于理解"><a href="#1-代码应当易于理解" class="headerlink" title="1.代码应当易于理解"></a>1.代码应当易于理解</h1><p>代码的写法应当使别人理解它所需的时间最小化。（相比于仅仅减少行数来说）如果与其他理念冲突，本条优先。</p><hr><h1 id="2-把信息装进名字里"><a href="#2-把信息装进名字里" class="headerlink" title="2.把信息装进名字里"></a>2.把信息装进名字里</h1><ul><li>选择专业的词语(清晰和精确)。比如 fetchPage 优于 getPage</li><li>避免宽泛的名字: 避免 tmp 和 retval 这样宽泛的名字。好的名字应当描述变量的目的或者它承载的值，tmp_file 也比 tmp 好</li><li>用具体的名字代替抽象的名字</li><li>使用前缀或者后缀给名字附带更多信息(英语表示法，非匈牙利命名法)。比如 delay_secs, html_utf8</li><li>决定名字的长度：小的作用域尽可能用短名称，否则应该包含足够的信息。缩略词（团队新成员能否理解它的含义，不能就不要用偏门的缩写）</li><li>利用名字的格式表达含义：比如纯大写表示常量等，骆驼命名法表示类等，遵循一门语言的编程命名约定。在项目中保持一致的命名法</li></ul><hr><h1 id="3-不会误解的名字"><a href="#3-不会误解的名字" class="headerlink" title="3.不会误解的名字"></a>3.不会误解的名字</h1><p>不要使用有歧义的名称</p><ul><li>用 max_ 和 min_ 前缀表示上限和下限；对于包含的范围用 first 和 last；对于包含/排除范围（左闭右开区间）用 begin 和 end</li><li>is、has、can、或 shoould 这样的词能使得 bool 值更明确，并且尽量避免用反义词汇。比如 use_ssl 好于 disable_ssl。（人脑更易于理解正向词汇）</li><li>与使用者的期望匹配：比如使用 get 误让使用者以为这是轻量级操作，可以用 compute 替代</li></ul><hr><h1 id="4-审美"><a href="#4-审美" class="headerlink" title="4. 审美"></a>4. 审美</h1><p>好的代码应该看上去『养眼』，三条原则：</p><ul><li>使用一致的布局，让读者很快就能习惯这种风格</li><li>让相似的代码看上去相似</li><li>把相关的代码分组，形成代码块</li></ul><p>编程的大部分时间都花在看代码上，浏览代码的速度越快，越容易使用它：</p><ul><li>重新安排换行来保持一致和紧凑</li><li>提炼出『方法』整理不规则的东西</li><li>在需要的时候使用『列对齐』。（有些编辑器插件能帮助你做这种事，比如 <a href="http://vimcasts.org/episodes/aligning-text-with-tabular-vim/）" target="_blank" rel="noopener">http://vimcasts.org/episodes/aligning-text-with-tabular-vim/）</a></li><li>选择一个有意义的顺序。比如字典序、重要性等排序</li><li>把声明按照块组织起来，按照逻辑分组</li><li>把代码分成段落，比如按照步骤来分段</li><li>一致的风格比正确的风格重要</li></ul><hr><h1 id="5-该写什么样的注释"><a href="#5-该写什么样的注释" class="headerlink" title="5. 该写什么样的注释"></a>5. 该写什么样的注释</h1><p>好代码&gt;差代码+好注释<br>什么时候加上：别人看不懂；代码使用的注意事项；</p><ul><li>什么不需要注释。不要拐杖式注释，试图粉饰可读性差的代码的注释。</li><li>用代码记录你的思想。加入『指导性批注』；为瑕疵写注释(TODO,FIXME,HACK)；给常量加注释；</li><li>站在读者的角度，去想象他们需要知道什么。<ul><li>别人读你代码在想为什么要这样的地方需要注释；</li><li>可能的陷阱。比如代码中数据上规模以后有严重性能问题等</li><li>全局观注释。类之间如何交互，数据流动，入口点在哪里等。</li><li>总结性注释。帮助快速理解代码块，不用迷失在细节中</li></ul></li></ul><hr><h1 id="6-写出言简意赅的注释"><a href="#6-写出言简意赅的注释" class="headerlink" title="6. 写出言简意赅的注释"></a>6. 写出言简意赅的注释</h1><p>注释应当具有很高的高信息/空间率</p><ul><li>让注释保持紧凑</li><li>避免使用不明确的代词，用代码名称代替 it 等词语</li><li>润色粗糙的句子</li><li>精确描述函数的行为</li><li>用输入输出例子来描述特殊的情况（更直观）</li><li>声明代码的意图。很多时候注释就是告诉读者你写代码的时候怎么想的。</li><li>使用具名函数。python 等语言能这么调用 f(timeout=1)</li><li>采用信息量高的词语。业界常用词汇</li></ul><hr><h1 id="7-把控制流变得易读"><a href="#7-把控制流变得易读" class="headerlink" title="7. 把控制流变得易读"></a>7. 把控制流变得易读</h1><ul><li>条件语句中参数的顺序。条件表达式左边的值倾向于是变化的值，右边的值倾向于常量</li><li>if/else 语句块的顺序。建议：先处理正常逻辑；先处理简单的情况；先处理有趣或者可疑的情况</li><li>三目运算符。 相对于减少代码行数，更好的度量方法是理解它的时间。不太建议在三目运算符中使用复杂的表达式，不如 if/else 直观</li><li>避免使用 do/while</li><li>从函数中提前返回</li><li>最小化嵌套。过多的逻辑嵌套会导致难以理解，大脑不断”入栈出栈”，增大圈复杂度</li><li>通过提前返回减少嵌套</li><li>你能理解程序执行的流程吗？线程、信号量（中断）、异常、匿名函数、虚方法等会让流程难以理解，不要滥用。</li></ul><hr><h1 id="8-拆分超长表达式"><a href="#8-拆分超长表达式" class="headerlink" title="8. 拆分超长表达式"></a>8. 拆分超长表达式</h1><p>大多数人的大脑最多只能同时考虑 3~4 件事情，代码中的表达式越长，就越难理解。</p><ul><li>引入解释变量。<ul><li><code>if line.split(&#39;:&#39;)[0].strip() == &quot;root&quot;</code> 改为如下表达式:</li><li><code>username = line.split(&#39;:&#39;)[0].strip(); if username == &quot;root&quot;</code></li></ul></li><li>总结变量。<code>boolean user_owns_document = (request.user.id == document.owner_id)</code></li><li>使用德摩根律简化逻辑表达式。（口诀：分别取反，转换与/或）<ul><li>not (a or b or c) &lt;=&gt; (not a) and (not b) and (not c)</li><li>not (a and b and c) &lt;=&gt; (not a) or (not b) or (not c)</li></ul></li><li>不要滥用短路逻辑。短路求值有时候会很简洁，但是影响可读性</li><li>从逻辑的反面思考有时候能简化表达式</li><li>提炼重复表达式为变量</li></ul><hr><h1 id="9-变量与可读性"><a href="#9-变量与可读性" class="headerlink" title="9. 变量与可读性"></a>9. 变量与可读性</h1><p>变量的草率运用会让程序更难理解：</p><ul><li>变量越多，越难以跟踪他们的动向</li><li>变量的作用域越大，就需要跟踪它的动向越久</li><li>变量改变地越频繁，就越难以跟踪它的当前值</li></ul><p>增强可读性的方式：</p><ul><li>减少不必要临时变量；比如它没有拆分任何复杂的表达式；没有做出更多澄清；只使用过一次等</li><li>减少中间结果</li><li>减少控制流变量：比如 done 标记。可以通过运用结构化编程消除</li><li>缩小变量作用域：防止名称污染。让你的变量对尽量少的代码可见，减少读者同时需要思考的变量个数。</li><li>把变量定义放到使用前</li><li>只写一次的变量更好。常量往往不会引来麻烦。让变量在较少的地方有改动，操作它的地方越多，越难以确定它的值</li></ul><hr><h1 id="10-抽取不相关子问题"><a href="#10-抽取不相关子问题" class="headerlink" title="10. 抽取不相关子问题"></a>10. 抽取不相关子问题</h1><p>积极抽出不相关子问题，能让读代码的人关注程序的更高层次目标</p><ul><li>不相关子问题：自包含的，不知道其他程序如何使用它。</li><li>纯工具代码</li><li>简化已有接口</li><li>不要过犹不及，太多小函数会跳转增加理解负担。</li></ul><hr><h1 id="11-一次只做一件事"><a href="#11-一次只做一件事" class="headerlink" title="11. 一次只做一件事"></a>11. 一次只做一件事</h1><p>使『代码』一次只做一件事所用到的流程：</p><ul><li>1.列出代码所做的所有『任务』。</li><li>2.尽力把这些任务拆分到不同的函数中，或者至少是代码中的不同段落中。</li></ul><p>对于难度的代码，尝试列出所有任务，其中一些任务可以成为单独的函数或者类，也可以成为函数中的『逻辑段落』</p><hr><h1 id="12-把想法变成代码"><a href="#12-把想法变成代码" class="headerlink" title="12. 把想法变成代码"></a>12. 把想法变成代码</h1><p>一个简单的过程使你写出更清晰的代码:</p><ul><li>1.像对着一个同事一样用自然语言描述代码要做什么。</li><li>2.注意描述中所用的关键词和短语</li><li>3.写出与描述匹配的代码</li></ul><hr><h1 id="13-少写代码"><a href="#13-少写代码" class="headerlink" title="13. 少写代码"></a>13. 少写代码</h1><ul><li>你不会需要它：不要提前实现不需要的功能</li><li>质疑和拆分你的需求：『减少需求』和『解决更简单的问题』</li><li>保持小代码库：<ul><li>创建越多越好的『工具』代码来减少重复代码</li><li>减少无用代码或没有用到的功能</li><li>让你的项目保持分开的子项目状态</li><li>小心代码『重量』。程序员往往不情愿删除无用代码，因为它代表很多实际的工作量</li></ul></li><li>熟悉你周边的库：每个一段时间时间阅读下标准库中所有函数、模块、类型的名字，防止重复发明轮子</li></ul><hr><h1 id="14-测试与可读性"><a href="#14-测试与可读性" class="headerlink" title="14. 测试与可读性"></a>14. 测试与可读性</h1><ul><li>测试应具有可读性，其他程序员可以舒服地改变或者增加测试。</li><li>使用辅助函数隐藏不重要细节。（如构建对象）</li><li>让出错消息易读。</li><li>使用简单但是可以覆盖边界条件的测试值。</li><li>TDD: 仅在写代码的时候想着测试这件事就能帮助把代码写得更好</li><li>所有解耦的方法中，最好的往往就是最容易测试的那个。</li></ul><p>不要走得太远：</p><ul><li>为了测试牺牲真实代码的可读性</li><li>着迷于 100% 的测试覆盖率</li><li>让测试成为产品开发的阻碍</li></ul><p>可读性差的代码及其测试问题和设计问题：</p><ul><li>全局变量：不同测试互相影响：难以理解函数副作用</li><li>大量依赖：难以构建测试脚手架：难以重构</li><li>代码不确定行为：测试古怪：难以跟踪的bug</li></ul><p>可测试较好的代码特征：</p><ul><li>类中很少或没有内部状态：容易测试，很少检查隐藏状态：易于理解</li><li>只做一件事：需要较少测试用例：模块化，少耦合</li><li>依赖少：可以独立测试：可以并行开发</li><li>接口简单明确：明确的行为测试；可重用高</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;代码的写法应当使别人理解它所需的时间最小化。- 可读性基本定理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刚工作那会总喜欢追求一些代码语法糖，感觉有奇淫技巧的代码才是牛逼的。真正开始做项目后才发现代码可读性是如此重要，最近 code review 也因为一些命名问题修改过代码（英文词汇匮乏啊。。。）重新回顾下这本书，争取写出更易维护和可读性高的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://ningning.today/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://ningning.today/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重读《代码大全》</title>
    <link href="http://ningning.today/2017/05/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/code-complete-note/"/>
    <id>http://ningning.today/2017/05/27/软件工程/code-complete-note/</id>
    <published>2017-05-27T13:38:35.000Z</published>
    <updated>2017-08-05T13:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>软件构建的核心就是管理复杂度。 - 《Code Complete》</p></blockquote><p>最近笔者加入新公司，又开始一段新的程序员之旅。每次最头疼的还是上手已有的很多代码仓库，看别人的代码一直是一件痛苦的事情(理解最初的编程意图是最难的问题)，不过好处就是又学到了很多新东西，又了解到自己有多菜。最近又重新翻看了《代码大全》，摘抄了一点东西。如果说软件工程领域非得让我推荐一本书的话，无疑是这一本大而全的代码百科全书（虽然有点陈旧），汇集了很多编程技巧和工程领域的研究成果，很有启发，也正是这本书让我在编程上从野路子走向正规军。笔者一直感觉自己智商平庸，很想与高手程序员一起工作，看看别人是怎么解决问题的。我感觉高手和菜鸟最大的区别，除了智商、基础知识、自控能力以外，就是编程的习惯与思维方式的不同了。好在后面的特质都是可以学习和改善的，加入一个好团队就比较重要了。另外，对于团队而言，一个人的杰出能力往往不是那么重要的，开发流程和方法却会对产品质量产生很大影响。更反直觉的是，技术领域由于发展迅速过往经验有时候反倒是个阻碍。笔者现在写代码总有一种如履薄冰的感觉，生怕上线后出错跪了(在众多代码仓库中定位和修复 bug 也是个不小的挑战)。当然笔者也看到，很多厉害的技术老手也会犯一些低级错误，人的思维总是会有疏漏的，所以更要靠良好的习惯、规范和工作流程克服人的思维缺陷。工作的过程中也感觉到，自身的沟通能力、业务理解能力、主观能动性等还是有待提高啊。。。光会写点代码还是远远不够滴。</p><a id="more"></a><h2 id="1章：软件创建世界"><a href="#1章：软件创建世界" class="headerlink" title="1章：软件创建世界"></a>1章：软件创建世界</h2><p>创建活动主要包括：详细设计、编码、调试和单元测试</p><h2 id="2章：利用隐喻对编程进行更深刻的理解"><a href="#2章：利用隐喻对编程进行更深刻的理解" class="headerlink" title="2章：利用隐喻对编程进行更深刻的理解"></a>2章：利用隐喻对编程进行更深刻的理解</h2><p>隐喻通过把软件开发和熟知的事情联系在一起，从而使你对其有更深刻的理解。</p><h2 id="3章：软件创建的先决条件"><a href="#3章：软件创建的先决条件" class="headerlink" title="3章：软件创建的先决条件"></a>3章：软件创建的先决条件</h2><p>求助于逻辑推理、类比、数据<br>立刻开始编码的程序员往往比先做计划、后编码的程序员花费更多时间。</p><p>问题定义的先决条件：你要解决的问题是什么<br>需求分析先决条件：描述一个软件系统需要解决的问题<br>结构设计先决条件：典型结构要素：</p><ul><li>程序的组织形式(设计理由对于维护性来说，与设计本身同等重要)。定义主要模块，每个模块做什么应该明确定义，每个模块之间的交界面也应该明确定义，结构设计应该规定可以直接调用那些模块，不能调用哪些模块。结构设计也应该定义模块传送和从其他模块接受的数据。</li><li>主要的数据结构，结构设计应该给出主要文件、表和数据结构。</li><li>关键算法。</li><li>主要对象，每个对象的责任和相互作用</li><li>通用功能</li><li>用户界面</li><li>输入、输出</li><li>错误处理</li><li>鲁棒性。冗余设计、断言、容错性</li><li>性能（速度和内存）</li></ul><p>编程约定</p><h2 id="4章：建立子程序的步骤"><a href="#4章：建立子程序的步骤" class="headerlink" title="4章：建立子程序的步骤"></a>4章：建立子程序的步骤</h2><p>结构设计至少指出以下问题：</p><ul><li>要隐含的信息</li><li>输入、输出、受影响的全局变量</li><li>子程序如何处理错误</li></ul><p>先写PDL注释，再在注释下填充代码</p><p>确定质量标准：</p><ul><li>接口。确认所有输入和输出数据做了解释、并且使用了所有参数</li><li>设计质量</li><li>数据</li><li>控制结构</li><li>设计（表达式、参数、逻辑结构）</li></ul><p>迷信还是理解</p><h2 id="5章：高质量子程序的特点"><a href="#5章：高质量子程序的特点" class="headerlink" title="5章：高质量子程序的特点"></a>5章：高质量子程序的特点</h2><p>子程序：具有单一功能的可调用的函数或者过程<br>生成子程序的原因：降低复杂性、避免重复、限制改动带来的影响、隐含顺序、改进型能、集中控制、隐含数据结构、隐含全局变量、隐含指针操作、代码重用、提高可移植性、分隔复杂操作、简化测试</p><p>有意义的命名</p><p>可取的内聚性:</p><ul><li>功能内聚性: 子程序名称和功能相符</li><li>顺序内聚性: 子程序包含需要按照特定顺序进行的、逐步分享数据而不形成完成功能的操作，这时候需要重新组织成功能内聚性的</li><li>通讯内聚性: 一个子程序中、两个操作只是使用相同的操作，没有其他任何联系。这种内聚性可以接受</li><li>临时内聚性：因为同事执行的原因才被放入同一个子程序里</li></ul><p>不可取的内聚性：不要试图修补，重新创建<br>过程内聚性：当子程序中的操作是按某一特定顺序进行的，和顺序内聚性不同，它使用的是不同的数据<br>逻辑内聚性：一个子程序同时含有几个操作，其中一个操作又被传进来的控制标志所选择时，这些操作仅仅是因为控制流才被联系在一起的，并没有其他逻辑上的联系<br>偶然内聚性：操作无任何联系</p><p>松耦合：两个子程序中间的紧密程度。内聚性指的是一个子程序的内部各部分之间的联系程度，耦合性指的是子程序之间的联系程度。<br>耦合标准：<br>耦合规模、密切行、可见性、灵活性 一个子程序越容易被其他子程序调用，耦合度越低。<br>耦合层次:</p><pre><code>- 简单数据耦合:最好的耦合，通过参数传递数据，数据是非结构化的- 数据结构耦合：结构化数据，通过参数传递- 控制耦合：一个子程序通过传入另一个子程序的数据通知它做什么，令人不快- 全局数据耦合：使用同一个全局数据，如果只读还可以忍受- 不合理耦合：一个子程序使用了另一个子程序中的代码或者改变了其中的局部变量。也叫做内容耦合。</code></pre><p>子程序长度:尽量不要超过200行。错误率和可理解性最好。子程序的长度是由功能和逻辑自然决定的，而不是人为标准决定的。</p><p>防错性编程：思想核心是成人程序中都会产生问题，都要被改动。逐步设计：写好PDL、进行低层次设计、审查等手段防止错误引入。</p><pre><code>- 使用断言。- 输入垃圾不一定输出垃圾。好的程序从来不会输出乱七八糟的垃圾，不管输入什么- 异常情况处理。预先设计好异常处理措施来注意意想不到的情况。开发阶段变明显，运行阶段可修复- 预计改动：预想到的改动隐藏起来- 发布时去掉调试信息- 尽早引入调试辅助工具- 使用防火墙包容错误带来的危害- 检查返回值- 使用多少防错性编程</code></pre><p>子程序参数：</p><ul><li>确保形参实参匹配</li><li>按照 输入-修改-输出 的顺序排列参数，是否使用到了所有的输入和输出参数</li><li>状态和错误变量放在最后</li><li>不要子程序中的参数当做工作变量</li><li>说明参数的接口假设</li></ul><p>使用函数：（函数是返回值的子程序，过程不返回值的子程序）</p><ul><li>何时使用函数，何时使用过程</li><li>确保函数的每个执行路径都是有返回值的。</li></ul><h2 id="6章：模块化设计"><a href="#6章：模块化设计" class="headerlink" title="6章：模块化设计"></a>6章：模块化设计</h2><p>模块化：内聚性与耦合性。目标是使得每一个子程序都成为一个黑盒子。</p><pre><code>- 模块内聚性：一个模块应该提供一组相互联系的服务- 模块耦合：模块应该被设计成可提供一整套功能，一边程序的其他部分与它清楚地相互作用。而不用对其内部数据进行读写操作。尽可能减少使用全局变量。   模块设计最重要的决定之一就是决定哪个子程序需要对模块中的数据直接存取。</code></pre><p>信息隐藏：</p><pre><code>- 保密：决定那些特性应该是对外部公开的，那些应该是作为秘密隐藏的。隐藏细节方便澄清意图（比如用子程序替代代码片段）-从常见需要隐藏的信息：    - 容易被改动的区域:硬件依赖的地方、输入和输出、非标准语言特性、难于设计和实现的阈、状态变量（不要使用逻辑变量使用枚举变量；使用子程序而不是直接检查）、数据规模限制、商业规则（法律、规定等）、        预防潜在改动（分析程序中可能会被用户用到的最小子单元）    - 复杂的数据：存取子程序    - 复杂的逻辑：改善可读性；把对数据的操作隐藏在子程序中    - 编程语言层次上的操作- 障碍：信息过度分散；交叉依赖；误把模块数据当成全局数据</code></pre><p>简历模块的理由：用户接口、对硬件有依赖的部分、输入和输出、操作系统依赖、数据管理、ADT、可再使用的代码、可能发生变动的相互联系的操作、互相联系的操作</p><p>编程语言支持：<br>    模块包括数据、数据类型、数据操作、公共和局部操作的区分</p><h2 id="7章：高级结构设计"><a href="#7章：高级结构设计" class="headerlink" title="7章：高级结构设计"></a>7章：高级结构设计</h2><p>设计的层次：</p><pre><code>- 划分成子系统- 划分成模块- 划分成子程序- 子程序的内部设计</code></pre><p>结构化设计:<br>自顶向下分解<br>自底向上合成</p><p>面向对象：<br>抽象：抽象的单位是对象<br>封装：可以看到外表但是不能走进去的方法<br>模块化：内部发生变化的时候，接口不变<br>继承：共同与不同</p><p>面向对象的设计步骤：</p><pre><code>- 识别对象及其属性，它往往是数据- 确定每个对象可以做什么- 确定每一个对象可以对其他对象做什么- 确定每个对象对其他对象来说可以见的部分：那一部分是开放的，哪一部分是专用的- 确定每个对象的公共接口</code></pre><p>如果数据变动可能性很大，采用面向对象设计比较适合，如果是功能变动可能性较大，使用分解功能的结构化设计比较好。尽可能用信息隐藏。</p><p>往返设计：<br>设计是一个启发的过程。硬算；图示法。不要死抱着一种方法不放，确认你是不屈不挠，而不是顽固不化。看看波利亚的《how to solve it》<br>1.理解问题，问题是什么？，你必须要理解问题是什么。问题是什么？条件是什么？有可能满足条件吗？已知条件充分吗？是否矛盾和冗余。画一个图，引入恰当的符号，条件的不同部分分解开<br>2.设计一个方案。已知和未知的联系，如果不能找到直接联系，能不能得出一个辅助问题，但最后你应该找到一个解决方案。<br>3.执行你的计划，审查每一步工作是否是正确的，你能证明吗？<br>4.回顾，检查下答案。</p><p>受欢迎的设计的特点：</p><pre><code>- 智力上的可管理性- 低复杂性- 维护的方便性- 最小联系性- 可扩充性- 可重复使用性- 高扇入。对于一个给定的子程序，应该有尽可能多的子程序调用它。表明低层次上充分利用了功能子程序- 中或低程序扇出。对于一个给定子程序，它所调用的子程序尽可能少（0-2个）- 可移植性- 简练性，不要有任何多余代码- 成层设计：尽量分解层次成层，不要让子程序在几个层次上起作用- 标准化</code></pre><h2 id="8章：生成数据"><a href="#8章：生成数据" class="headerlink" title="8章：生成数据"></a>8章：生成数据</h2><p>初始化数据的准则：</p><ul><li>检查输入参数的有效性，临近原则，相关操作放在一起。</li><li>查找需要重新初始化的地方。</li></ul><h2 id="9章：数据名称"><a href="#9章：数据名称" class="headerlink" title="9章：数据名称"></a>9章：数据名称</h2><p>命名时要考虑的最重要的问题（命名真的是很讲究的问题，笔者经常在 codereview 时因为命名不合理修改代码，尤其是动态语言中的命名）</p><ul><li>名称是否完全而又准确地描述了变量所代表的实体，最好使用英语描述实体</li><li>好记的名称通常面向问题而不是解决问题的。一个恰当的名字说明『是什么』而非『怎样』。</li><li>最佳名称长度：10-16个</li><li>变量名中的计算值限定词：含有计算值的限定词（sum、avg）等放在后边</li><li>变量名中的反义词：保持连续性</li></ul><p>特定数据类型命名：</p><ul><li>循环变量：避免使用i，j，k等命名，容易混淆</li><li>状态变量：不要用flag命名，使用精确含义的描述词</li><li>临时变量：不要用temp命名</li><li>逻辑变量的命名：使用典型词语：done、error’found’success’，使用 “非真即假”的词语</li><li>枚举类型命名：使用相同前缀或者后缀表明同一组的</li><li>常量命名：使用抽象实体</li></ul><p>命名约定：<br>需要建立约定<br>一些语言无关的约定准则：</p><ul><li>标识全局变量: 使用前缀</li><li>标识模块变量: 表示模块内部使用的变量</li><li>标识类型定义：避免与变量名称冲突</li><li>标识命名常量</li><li>标识枚举类型: 使用后缀</li><li>表示输入参数</li><li>使用下划线等分隔增强可读性</li></ul><p>变量名应该包括三个方面的信息:</p><ul><li>变量内容，它代表的是什么</li><li>变量数据类型（整形、浮点等）</li><li>变量在程序结构中的位置，比如模块、全局等</li></ul><h2 id="10章：变量"><a href="#10章：变量" class="headerlink" title="10章：变量"></a>10章：变量</h2><p>作用域：影响范围，也成可见性。</p><ul><li>尽可能减小作用域。同意变量的引用集中放置</li></ul><p>持久性：某一个数据使用的寿命。养成初始化的习惯</p><p>赋值时间：越晚赋值，灵活性越大</p><p>数据结构与控制结构的关系：从可用的数据和输出该是什么样子开始，然后对程序进行定义，使其把输入转化为输出。</p><p>变量功能单一性：应使每一个变量只具有一个功能，比如不要用tmp命名然后多次赋值</p><p>全局变量：常见问题：疏忽被其他地方改变；别名覆盖；代码重入；妨碍重新使用代码；损害模块性和可管理性<br>全局变量使用场景：保存全局数值；代替命名常量；方便常用数据的使用；消除穿梭数据。<br>安全使用全局变量：区分全局和模块变量；一眼可以识别的全局命名约定；注释表；需要加锁吗；不要把数据放入庞大的变量；使用存取子程序代替全局数据</p><h2 id="11章：基本数据类型"><a href="#11章：基本数据类型" class="headerlink" title="11章：基本数据类型"></a>11章：基本数据类型</h2><p>常数：避免使用幻数；避免除0；确保类型转换是显示的；避免不同类型比较<br>整数：检查整数相除；避免整数溢出（了解整数范围）；检查中间结果是否溢出<br>浮点数：不要在位数相差太多的数字运算；不要对浮点数做==比较；防止舍入误差<br>字符和字符串：避免常量字符串；注意c语言的字符串边界错误；<br>逻辑变量：用逻辑变量说明程序；避免复杂的多重逻辑判断，代之以有意义的逻辑变量；<br>枚举类型：可靠已修改；在case语句中刻意代替逻辑变量；第一个入口是否保留为无效值<br>数组：确保下标没有越界；<br>指针：内存存储单元及对这个存储单元的解释; 使用显示指针类型；避免强制类型转换(重新设计)</p><h2 id="12章：复杂数据类型"><a href="#12章：复杂数据类型" class="headerlink" title="12章：复杂数据类型"></a>12章：复杂数据类型</h2><p>记录与结构：相关数据组织到一个结构中；简化参数表；</p><p>表驱动法：可以在表中查找信息而使用 if 或者 case 的方法。</p><ul><li>直接存取：直接查表，代替复杂的逻辑控制，可读性更强容易修改；使用转换函数简历存取标志</li><li>变址存取:</li><li>阶梯存取:节省空间，入口对数据范围有效。注意边界（&lt; or &lt;=）;</li></ul><p>抽象数据类型：数据及对数据的操作，解决客观世界实体问题。尽可能从高水平的抽象处理问题。</p><h2 id="13章：顺序程序语句"><a href="#13章：顺序程序语句" class="headerlink" title="13章：顺序程序语句"></a>13章：顺序程序语句</h2><p>必须有明确顺序的语句：组织使它们之间的依赖关系明显；子程序名称应当清晰表明依赖关系；使用子程序参数使得依赖关系明显；注明不明确的依赖关系<br>与顺序无关的程序语句：接近原则，相关操作组织在一起; 使代码能从上读到下；同一变量局部化（跨度）；使变量存活时间尽量短(清楚变量使用范围)；<br>相关语句组织在一起（方法：用框框把相关语句括起来，框与框之间没有交叉）</p><h2 id="14章：条件语句"><a href="#14章：条件语句" class="headerlink" title="14章：条件语句"></a>14章：条件语句</h2><p>if 语句：先按照正常情况路径编写，然后写异常情况。使得正常情况的路径在代码中显清晰；把正常情况放在 if 后边而不是 else 后边；确保 if 和 else 语句的正确性<br>if then else: 用布尔函数调用简化程序；；最常见的情况放在开始；保证覆盖全部情况。<br>case： 按照字母或者数字顺序排列；正常情况放在最开始；按照出现频率组织。</p><h2 id="15章：循环语句"><a href="#15章：循环语句" class="headerlink" title="15章：循环语句"></a>15章：循环语句</h2><p>循环的内务处理工作放在循环的开头或者结尾（控制循环）；循环中不要强制改变控制循环的变量而达到提前终止循环的目的；使得推出循环的代码明显；<br>检查循环边界：初始情况、中间、结束情况<br>从里到外写</p><h2 id="16章：少见的控制结构"><a href="#16章：少见的控制结构" class="headerlink" title="16章：少见的控制结构"></a>16章：少见的控制结构</h2><p>goto 语句：少用或不用<br>return 语句：减少 return 语句。</p><p>递归 : 递归至少要有终止条件；设置安全计数器防止无限递归；把递归调用限制在子程序里；注意堆栈是否会溢出；使用循环还是递归，慎用递归</p><h2 id="17章：常见的控制问题"><a href="#17章：常见的控制问题" class="headerlink" title="17章：常见的控制问题"></a>17章：常见的控制问题</h2><p>布尔表达式：用True和False不要用1和0； 编写肯定形式的布尔表达式，人们不善于理解否定句；利用括号使得表达式清晰；利用懒惰求值(警惕懒惰求值后的语句有错误); 按照数轴上的数字顺序编写数字算式</p><p>减少深层嵌套：</p><ul><li>重新组织测试条件减少嵌套</li><li>使用 if-then-els  替代嵌套</li><li>把深层嵌套的代码写成子程序</li><li>重新设计</li></ul><p>结构化编程：程序总是单入单初的结构，即程序只能从一个地方开始且只能从一个地方退出的代码块。三个方面：</p><ul><li>顺序编程：一组顺序执行的语句，典型的包括赋值和子程序调用</li><li>选择：只有一个被执行</li><li>重复：一组语句被执行多次</li></ul><p>降低程序复杂性 Mc Cabe，通过计算程序中的决定点的数目度量复杂性<br>1.从1 开始往下通过程序。<br>2.遇到下列关键词或同类词语 +1， if while repeat for and or<br>3 case 语句每一种情况都 +1，如果case 没有缺省情况再  +1</p><p>0-5表示程可能很好；6-10 得想办法简化；10以上需要把部分代码写成子程并在源程序里调用</p><h2 id="18章-布局和风格"><a href="#18章-布局和风格" class="headerlink" title="18章: 布局和风格"></a>18章: 布局和风格</h2><p>布局技巧：用空格提高可读性；分组；对齐；缩进；括号；</p><p>准确性、连续性、可读性、易维护性</p><h2 id="19章：文档"><a href="#19章：文档" class="headerlink" title="19章：文档"></a>19章：文档</h2><p>外部文档：综合资料；详细设计文档<br>注释分5类：<br>代码的重复:用不同的词语重申代码的内容<br>代码的解释: 解释复杂的有效的和灵敏的代码，通常有用但是尽可能修改代码使得代码本身更清晰<br>代码中标记： TODO 等<br>代码意图的描述：解释代码的目的。意图注释在问题一级上，而不是在答案一级，是一句利用答案的总结描述。</p><h2 id="20章：编程工具"><a href="#20章：编程工具" class="headerlink" title="20章：编程工具"></a>20章：编程工具</h2><p>设计工具：图形设计工具<br>源代码工具：编辑程序；文件比较工具；源码美化工具；模板；浏览程序；多文件字符串搜寻；互相引用参照工具；调用结构生成工具；代码质量分析工具；质量报告工具；重构程序；代码翻译工具；版本控制<br>执行代码工具：代码生成<br>环境：unix；case；批处理；拓扑观察</p><h2 id="21章：项目大小如何影响构建"><a href="#21章：项目大小如何影响构建" class="headerlink" title="21章：项目大小如何影响构建"></a>21章：项目大小如何影响构建</h2><p>项目大小：简化交流方法；<br>随着项目增大，创建活动减弱<br>大项目的生产率比小项目要低一些，每行错误数更多</p><h2 id="22章：创建管理"><a href="#22章：创建管理" class="headerlink" title="22章：创建管理"></a>22章：创建管理</h2><p>使用好的代码<br>配置管理：SCM。软件设计修改；软件代码改变；<br>评估创建计划：《软件工程经济》。设计、编码、调试和单元测试。<br>度量：错误率；行数等<br>程序员生产力：不同程序员效率差异会很大；工作环境影响生产力<br>如何对待上司：《怎样赢得朋友和影响他人》</p><h2 id="23章：软件质量概述"><a href="#23章：软件质量概述" class="headerlink" title="23章：软件质量概述"></a>23章：软件质量概述</h2><p>软件质量特点：</p><ul><li>外部特征：正确性、可用性、效率、可靠性、完整性、适应性、精确性、坚固性</li><li>内部特征：可维护性、灵活性、可移植性、可重用性、可读性、可测试性、可理解性</li></ul><p>提高软件质量的方法：最好的方法是控制开发过程。质量管理目标；确定质量保证活动(要让程序员明白质量是第一位的)；测试策略；可靠性评估；软件工程准则（设计、编码、调试、集成）；<br>非正式技术审查；正规技术审查；外部检查；开发过程；修改控制过程；结果的定量；结果的定量；原型；设置目标</p><p>各种方法效果:组合使用，任何使用单一测试方法效果不明显；通过阅读代码能发现较多的控制错误（相比直接调试）；</p><p>何时应作质量保证:贯穿整个项目计划</p><p>软件质量的一般原则：提高质量并减少花费。提高效率和质量的最好方法是减少代码再加工的时间，不论再加工是由于需求变更、设计修改或调试。软件产品的工业生产率仅为每人每天8-20行代码，大部分时间在调试。缩短软件开发时间最为明显的方法是提高产品质量，减少调试和再开发软件所需时间。</p><h2 id="24章：评审"><a href="#24章：评审" class="headerlink" title="24章：评审"></a>24章：评审</h2><p>评审在软件质量保证中的地位：基本思想：开发者对其工作中的一些故障点是一无所知的，而另外一些人则不存在这个盲区，所以让别人来检查你的工作是有意义的。评审是检查、初查、代码阅读及别人查看你的工作的总称。单元测试的检错比仅为25%，功能测试为35%，而集成测试为45%。相比之下，设计和代码检查的检错比平均为55%、60%。（这个结果有点出乎笔者意料）</p><p>检查：设计和代码检查的联合使用能去除产品中60%-90%的错误。过程：计划；总览；准备；检查会议；检查报告；再工作；执行；建立检查表(错误类型表)，让程序员有针对性地进行训练和得到帮助</p><p>其他评审方法：普查；代码阅读；软件演示。</p><h2 id="25章：单元测试"><a href="#25章：单元测试" class="headerlink" title="25章：单元测试"></a>25章：单元测试</h2><p>单元测试在软件质量中的作用：仅用测试不能提高质量；测试需要你假定能在代码中找到错误</p><p>单元测试的一般方法：对每个需求进行测试；对和设计有关的陈旭进行测试；<br>测试技巧：基于结构的测试（路径覆盖）；数据流测试；等效类划分；错误猜测（建立错误表积累经验和直觉、边界分析、检查表）<br>典型错误：错误排序。三个最常见错误源：贫乏的应用控制知识、需求的冲突和缺乏交流和协调。大多数实现错误来自程序员。拼写错误很常见，还有赋值和边界错误。<br>测试支持工具：建立脚手架；覆盖率检测；调试工具；系统测试；错误数据库<br>提高测试质量：计划测试；回归测试</p><h2 id="26章：调试"><a href="#26章：调试" class="headerlink" title="26章：调试"></a>26章：调试</h2><p>软件质量的基本原则：提高开发质量可以降低开发消耗。<br>使你有所收获的错误：</p><ul><li>了解错误类型。</li><li>从别人的角度了解代码质量</li><li>了解解决问题的方法。</li><li>了解如何改正：修改问题本身而不是补偿<br>调试的误区：靠猜测发现错误;不花费时间理解问题; 用最为明显的方式改正错误（你应该改正所发现的特定问题，而不是一些大的模糊不清的修改</li></ul><p>找错：发现并理解错误将耗费90%的时间。<br>科学的调试步骤：1.通过重复试验收集数据。2.建立假设以解释尽可能多的相关数据。3.设计实验正式或者否定假设。4.正式或者否定假设。5.按要求重复以上步骤。<br>发现错误的有效方法：1.固定错误 2.确定错误源 3.改正错误 4.测试修改 5.寻找类似错误<br>发现错误的诀窍：使用所有可能数据进行假设；精简错误测试用例；通过不同的方式再生错误；生成更多数据验证假设；使用否定测试的结果；提出尽可能多假设；缩小可以代码区域；细分和诊断整个程序；检查最近修改过的子程序；<br>逐步集成；耐心检查；为迅速调试设立最大时间（超过时间换个方法）；检查一般错误（检查表）；交谈调试(阐述问题和寻求帮助)；暂时终止对问题的考虑，焦虑的出现是应该暂停一下的信号</p><p>修改错误：改正问题之前真正了解其实质；理解整个程序而不知识了解某个问题；确诊错误；放松自己；修改错误问题而不是症状；检查你的修改；寻找相似错误；</p><p>调试心理因素：心理因素的两个影响：良好编程习惯的重要性；当初先错误时对部分程序的挑选上。比如经常混淆两个相近拼写的词语，尽量使用差别较大的单词命名。</p><p>调试工具：源码diff工具；编译警告；扩展语法和逻辑检查（pylint）；执行剖析程序；调试程序；调试和思考联合使用，都不可替代</p><h2 id="27章：系统集成"><a href="#27章：系统集成" class="headerlink" title="27章：系统集成"></a>27章：系统集成</h2><p>集成非常重要但常常被忽视<br>多数情况下，递增集成比分段集成更好<br>现在 devops 比较火，感觉这点内容稍微陈旧</p><h2 id="28章：代码调整策略"><a href="#28章：代码调整策略" class="headerlink" title="28章：代码调整策略"></a>28章：代码调整策略</h2><p>代码调整：有效的代码不一定是好的代码；代码必须通过测量来判断，不要轻易相信直觉<br>Pareto原理：80/20 定律<br>低效率的情况：输入输出操作（IO）；浮点操作；分页；系统调用</p><h2 id="29章：代码调试技术"><a href="#29章：代码调试技术" class="headerlink" title="29章：代码调试技术"></a>29章：代码调试技术</h2><p>循环：避免开关（移出循环）；合并循环体相同语句；<br>逻辑: 短路求值；根据频率确定逻辑表达式顺序；查表法替代逻辑判断；<br>数据转换：减少数组访问；索引结构；高速缓存<br>表达式：利用德摩根律简化逻辑；编译期间初始化；预先计算结果<br>程序：子程序；</p><h2 id="30章：软件优化"><a href="#30章：软件优化" class="headerlink" title="30章：软件优化"></a>30章：软件优化</h2><p>软件进化种类：根据质量判断进化方向<br>软件优化指南：</p><ul><li>多设计子程序，模块化</li><li>减少全局变量</li><li>改进编程风格</li><li>改变管理</li><li>重审修订后的程序</li><li>重测试：使用测试验证修改效果</li></ul><p>编写新程序：小的子程序要比加上注释的大程序好</p><h2 id="31章：个人性格"><a href="#31章：个人性格" class="headerlink" title="31章：个人性格"></a>31章：个人性格</h2><p>个人性格：一定程度可以改变性格；在成为高级程序员的过程中，性格更具有决定意义<br>聪明和谦虚：许多良好的编程风格的目的是减少你大脑的负担。<br>好奇心：建立自我意识；实验，快速试错；阅读解决问题的有关方法；行动之前进行分析和计划；学习成功项目的开发经验，向优秀程序员学习；阅读手册；阅读有关书籍和期刊<br>诚实：乐于承认自己的错误<br>交流合作：代码是与人交流的<br>创造力和纪律：一个杰出的程序员需要遵守许多规则<br>懒惰：用工具解放自己<br>不是你想象中那样起作用的性格：软件开发中坚持往往是顽固的意思；经验的价值比其他领域要小（软件领域变化太快，知识更新使得『经验』处在一个奇怪的位置上；计算机谜（警惕没日没夜工作的程序员的工作质量）<br>习惯：好的程序员一开始就养成好习惯；你一开始雪某件事的时候就应该按照正确的方式学好它；</p><h2 id="32章：软件开发方法的有关问题"><a href="#32章：软件开发方法的有关问题" class="headerlink" title="32章：软件开发方法的有关问题"></a>32章：软件开发方法的有关问题</h2><ul><li>克服复杂性：分解和模块化；良好的设计；编码约定；划分层次；抽象（类和子程序）</li><li>精选开发过程：对于多个程序员的项目组织特征比单个程序员技能更起作用。</li><li>首先为人编写程序，其次才是计算机。</li><li>注意约定的使用：用约定传递信息（比如变量名）；防范已知的危害；提高可读性；弥补语言不足</li><li>根据问题范围编程：处理复杂性的一个特定的方法是在高抽象级别上工作，根据问题而不是根据计算机编程。将问题分解成不同的抽象级别（计算机科学范围和问题范围）:高级语言结构；计算机科学结构；低级问题领域；高级问题领域</li><li>当心飞来横祸：程序编制是一门技艺，需要大量个人判断。警惕代码坏味道和警告信息</li><li>重复：逐步修改和提高</li><li>不要固执己见：不幸的是一些优秀人员容易偏执。选择和实验。保持开放的思想。构造个人工具箱</li></ul><p>如果你和笔者一样记性不好的话，可以尝试下建立一个代码清单(检查表)，每次提交代码之前对照清单检查一遍，比如命名是否合理、复杂度能否接受、有没有处理异常或者降级、有没有必要的文档和注释、有没有xss等安全问题，习惯了以后代码质量会慢慢有所提高。(说白了就是规范问题，性能问题，逻辑问题，安全问题，可维护性问题)。code review 也比较重要，眼睛足够多，bug 无处藏。笔者目前在知乎大家还是很重视 code review 的，经常一次提交要反复修改数次才能通过，并且至少要经过一个老司机的 review，如果上了一个 bug 后果还是非常严重的，会对很多用户造成影响。</p><hr><p>Ref:</p><p><a href="http://mindhacks.cn/2008/04/18/learning-from-polya/" target="_blank" rel="noopener">跟波利亚学解题(rev#3)</a>: 讲解思维过程的</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;软件构建的核心就是管理复杂度。 - 《Code Complete》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近笔者加入新公司，又开始一段新的程序员之旅。每次最头疼的还是上手已有的很多代码仓库，看别人的代码一直是一件痛苦的事情(理解最初的编程意图是最难的问题)，不过好处就是又学到了很多新东西，又了解到自己有多菜。最近又重新翻看了《代码大全》，摘抄了一点东西。如果说软件工程领域非得让我推荐一本书的话，无疑是这一本大而全的代码百科全书（虽然有点陈旧），汇集了很多编程技巧和工程领域的研究成果，很有启发，也正是这本书让我在编程上从野路子走向正规军。笔者一直感觉自己智商平庸，很想与高手程序员一起工作，看看别人是怎么解决问题的。我感觉高手和菜鸟最大的区别，除了智商、基础知识、自控能力以外，就是编程的习惯与思维方式的不同了。好在后面的特质都是可以学习和改善的，加入一个好团队就比较重要了。另外，对于团队而言，一个人的杰出能力往往不是那么重要的，开发流程和方法却会对产品质量产生很大影响。更反直觉的是，技术领域由于发展迅速过往经验有时候反倒是个阻碍。笔者现在写代码总有一种如履薄冰的感觉，生怕上线后出错跪了(在众多代码仓库中定位和修复 bug 也是个不小的挑战)。当然笔者也看到，很多厉害的技术老手也会犯一些低级错误，人的思维总是会有疏漏的，所以更要靠良好的习惯、规范和工作流程克服人的思维缺陷。工作的过程中也感觉到，自身的沟通能力、业务理解能力、主观能动性等还是有待提高啊。。。光会写点代码还是远远不够滴。&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://ningning.today/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://ningning.today/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用cookiecutter-flask快速生成python后端项目</title>
    <link href="http://ningning.today/2017/02/24/python/quick-start-backend-use-cookiecutter-flask/"/>
    <id>http://ningning.today/2017/02/24/python/quick-start-backend-use-cookiecutter-flask/</id>
    <published>2017-02-24T15:30:21.000Z</published>
    <updated>2017-02-24T16:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Write code that writes code. Code generators increase your productivity and help avoid duplication.</p></blockquote><hr><h2 id="天下武功，唯快不破"><a href="#天下武功，唯快不破" class="headerlink" title="天下武功，唯快不破"></a>天下武功，唯快不破</h2><p>每当我们启动一个新项目的时候，总有很多重复性工作，创建后端app模板就是其中之一。如果是使用django还好，django提供了生成项目app的命令直接创建，不过貌似现在很多pythoner都倾向于用flask这种微框架。虽然很多成功的项目是基于django（Instagram，Disqus，Pinterest等）构建，不过笔者还是更喜欢flask这种微框架。flask的好处在于你可以随意替换插件（ORM，模板等），相比django更加灵活。缺点就是有时候会选择困难，不知道如何组织大型项目，而且需要学习各种flask的插件，实际上把flask一套插件都整明白也需要一定的学习成本。今天笔者介绍的这个<a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="noopener">Cookiecutter</a>项目就是专门用来解决项目模板生成问题的，经过了python3.5.2生产环境的检验。</p><a id="more"></a><hr><h2 id="使用cookiecutter-flask生成模板"><a href="#使用cookiecutter-flask生成模板" class="headerlink" title="使用cookiecutter-flask生成模板"></a>使用cookiecutter-flask生成模板</h2><p>使用很简单(需要具备基本的flask框架知识)，<a href="https://github.com/sloria/cookiecutter-flask" target="_blank" rel="noopener">cookiecutter-flask</a>项目地址:</p><pre><code>$ pip install cookiecutter$ cookiecutter https://github.com/sloria/cookiecutter-flask.git</code></pre><p>执行完以后按照提示填写app名称（注意app名称符合python包名规范）就可以生成了，非常方便。后边注意了，有新手在github的issue里提出没有一个新手指引，实际上生成到README里了。</p><pre><code>===============================flaskapp===============================Test flask-cookiecutterQuickstart----------First, set your app&apos;s secret key as an environment variable. For example,add the following to ``.bashrc`` or ``.bash_profile``... code-block:: bash    export APP_SECRET=&apos;something-really-secret&apos;Before running shell commands, set the ``FLASK_APP`` and ``FLASK_DEBUG``environment variables ::    export FLASK_APP=/path/to/autoapp.py    export FLASK_DEBUG=1Then run the following commands to bootstrap your environment ::    git clone https://github.com/PegasusWang/app    cd app    pip install -r requirements/dev.txt    bower install    flask runYou will see a pretty welcome screen.Once you have installed your DBMS, run the following to create your app&apos;sdatabase tables and perform the initial migration ::    flask db init    flask db migrate    flask db upgrade    flask runDeployment----------In your production environment, make sure the ``FLASK_DEBUG`` environmentvariable is unset or is set to ``0``, so that ``ProdConfig`` is used.Shell-----To open the interactive shell, run ::    flask shellBy default, you will have access to the flask ``app``.Running Tests-------------To run all tests, run ::    flask testMigrations----------Whenever a database migration needs to be made. Run the following commands ::    flask db migrateThis will generate a new migration script. Then run ::    flask db upgradeTo apply the migration.For a full migration command reference, run ``flask db --help``.</code></pre><p>按照步骤执行一次就能看到效果了。你只需要新建自己的蓝图，开始填写自己的业务就行了。</p><hr><h2 id="添加flask-restful-redis，sentry，flask-admin等支持"><a href="#添加flask-restful-redis，sentry，flask-admin等支持" class="headerlink" title="添加flask_restful, redis，sentry，flask_admin等支持"></a>添加flask_restful, redis，sentry，flask_admin等支持</h2><p>项目自动生成的模板里头已经引入了很多插件了，不过还有几个比较常用的插件，比如redis支持，sentry支持（sentry记录异常信息非常好用），flask_admin(类似django的后台管理）等。最后笔者的extensions.py如下:</p><pre><code># -*- coding: utf-8 -*-&quot;&quot;&quot;Extensions module. Each extension is initialized in the app factory locatedin app.py.&quot;&quot;&quot;import osimport typesfrom flask_admin import Adminfrom flask_admin.contrib.sqla import ModelViewfrom flask_babel import Babelfrom flask_bcrypt import Bcryptfrom flask_caching import Cachefrom flask_debugtoolbar import DebugToolbarExtensionfrom flask_login import LoginManagerfrom flask_mail import Mailfrom flask_migrate import Migratefrom flask_redis import FlaskRedisfrom flask_restful import Apifrom flask_sqlalchemy import SQLAlchemyfrom flask_wtf.csrf import CsrfProtectfrom mockredis import MockRedisfrom raven.contrib.flask import Sentrybcrypt = Bcrypt()csrf_protect = CsrfProtect()login_manager = LoginManager()db = SQLAlchemy()migrate = Migrate()cache = Cache()debug_toolbar = DebugToolbarExtension()api = Api(decorators=[csrf_protect.exempt])mail = Mail()babel = Babel()    # 用babel处理时区转换问题admin = Admin()sentry = Sentry()    # settings里配置Setnry服务器地址def api_route(self, *args, **kwargs):    &quot;&quot;&quot; 给flask api加上route功能，避免直接调用api.add_resource函数了.    具体请参考crm_backend.employee.api里的使用    http://flask.pocoo.org/snippets/129/    &quot;&quot;&quot;    def wrapper(cls):        self.add_resource(cls, *args, **kwargs)        return cls    return wrapperapi.route = types.MethodType(api_route, api)class MockRedisWrapper(MockRedis):    &quot;&quot;&quot;A wrapper to add the `from_url` classmethod    https://github.com/underyx/flask-redis    &quot;&quot;&quot;    @classmethod    def from_url(cls, *args, **kwargs):        return cls(decode_responses=True)if os.environ.get(&apos;USE_CONFIG&apos;) == &apos;prod&apos;:    redis_store = FlaskRedis(decode_responses=True)else:    redis_store = FlaskRedis.from_custom_provider(MockRedisWrapper)</code></pre><p>当然也可以按照你自己的需求自己增删功能，最近的flask版本在DEBUG模式下支持自动检测重启，开发起来还是非常爽快的，笔者最近的几个后端项目都是用cookiecutter-flask生成后自己按需修改，感兴趣的可以试试。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/sloria/cookiecutter-flask" target="_blank" rel="noopener">cookiecutter-flask</a></p><p><a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="noopener">cookiecutter</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Write code that writes code. Code generators increase your productivity and help avoid duplication.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;天下武功，唯快不破&quot;&gt;&lt;a href=&quot;#天下武功，唯快不破&quot; class=&quot;headerlink&quot; title=&quot;天下武功，唯快不破&quot;&gt;&lt;/a&gt;天下武功，唯快不破&lt;/h2&gt;&lt;p&gt;每当我们启动一个新项目的时候，总有很多重复性工作，创建后端app模板就是其中之一。如果是使用django还好，django提供了生成项目app的命令直接创建，不过貌似现在很多pythoner都倾向于用flask这种微框架。虽然很多成功的项目是基于django（Instagram，Disqus，Pinterest等）构建，不过笔者还是更喜欢flask这种微框架。flask的好处在于你可以随意替换插件（ORM，模板等），相比django更加灵活。缺点就是有时候会选择困难，不知道如何组织大型项目，而且需要学习各种flask的插件，实际上把flask一套插件都整明白也需要一定的学习成本。今天笔者介绍的这个&lt;a href=&quot;https://github.com/audreyr/cookiecutter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cookiecutter&lt;/a&gt;项目就是专门用来解决项目模板生成问题的，经过了python3.5.2生产环境的检验。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://ningning.today/categories/python/"/>
    
    
      <category term="python" scheme="http://ningning.today/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>软件设计的一些基本原则</title>
    <link href="http://ningning.today/2017/02/16/design/software-design-principle/"/>
    <id>http://ningning.today/2017/02/16/design/software-design-principle/</id>
    <published>2017-02-16T01:20:39.000Z</published>
    <updated>2017-02-16T08:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Everything Should Be Made as Simple as Possible, But Not Simpler. - Albert Einstein</p></blockquote><p>我觉得编写软件的过程就是和和复杂度斗争的过程，无论是编写传统的pc软件还是web应用。对于python这种动态语言，很多问题是在运行时才暴露出来的，而且动态语言相对难以维护和重构。我一直感觉使用动态语言的时候要更加重视项目工程的管理，控制复杂度，防止代码仓库失控。了解一些常用原则降低复杂度还是有必要的。</p><a id="more"></a><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>软件天然错综复杂，当你衡量一个东西是否过于简单的时候，首先回答是对谁而言以及对什么时候而言。对于工程师而言，简单是让别的工程师以一种最容易的方式使用你的方案。</p><ul><li>隐藏复杂与构建抽象:软件变庞大之后很难一窥全貌，无法保持简单，但是可以保持局部简单。达到局部简单的主要方式实在设计和实现两个方面上，任何单个的类、模块、应用的设计目标和工作原理能被快速理解，而不需要深入到里头的细节。添加抽象层，隐藏复杂性。</li><li>避免过度设计：好的设计是能在后期不断添加新的功能特性，而不是一开始就开发一个大系统。每次进行软件设计的时候问题自己，这个设计是否可以更简单而且在将来依然可以保持弹性？斟酌权衡</li><li>尝试测试驱动开发：在某些方法上搞TDD可以获得一个全新的视角。TDD能然你避免写冗余的无用代码，同事单元测试用例可以被当做文档，暂时代码的意图、用法、期望结果等。同时TDD能然你以使用者的角度看待接口，从而简化API。无论是否使用TDD，你都要以用户（使用API）的人的视角思考，提高接口易用性。</li><li>从软件设计的简化范例中学习：Grails，Hadoop，Google Maps API。</li></ul><h2 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h2><p>低耦合对系统的健康和伸缩至关重要。</p><ul><li>促进低耦合：小心管理依赖，类之间、模块之间、应用之间的以依赖。类应该只有一个目的，是最小的抽象粒度，尽量少暴露类的内部信息。</li><li>避免不必要的耦合：尽可能多隐藏，少暴露。画系统设计图可以暴露循环依赖，一个良好的模块架构图应该看起来像一棵树（有向无环图），而不是社交网络图。</li><li>低耦合范式：通过阅读别人的代码吸取经验。比如unix的命令行及管道的设计。</li></ul><h2 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h2><p>软件开发工程中低效的地方有很多，代码重复、缺乏自动化的重复（部署、测试、配置等）、大量复制粘贴代码、不必要的重复发明轮子等，“代码不会用第二次就凑合一下”的态度</p><ul><li>复制粘贴代码：使用抽象，组合继承等消除重复，使用设计模式、共享类库等消除重复。</li></ul><h2 id="基于约定编程"><a href="#基于约定编程" class="headerlink" title="基于约定编程"></a>基于约定编程</h2><p>基于约定编程或者说基于接口编程，是将客户端代码和功能提供者代码解耦的重要方式。让客户端依赖于约定编程。 约定在不同层次有不同的意义，比如低层次就是方法和函数的签名，高层次可以是web服务的文档。HTTP协议就是个著名的例子。<br>另一个小例子就是参数校验，来自外部的参数(比如用户表单)都是不可信任的，必须做参数校验，但是内部接口如果我约定好了你就需要按照指定的参数和类型传给我（动态语言还有鸭子类型），而不是需要在所有内部接口到处做参数校验。</p><h2 id="画架构图"><a href="#画架构图" class="headerlink" title="画架构图"></a>画架构图</h2><p>有些时候需要做前期设计，可以帮助自己和他人更好了解设计。</p><ul><li>用例图：定义系统用户是谁，可以做哪些操作。</li><li>类图：接口、类、关键方法名和它们之间的关系，展现类、接口及其交互关系。</li><li>模块图：模块之间的依赖和交互，可以是一个包或者组件。</li></ul><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><p>类应该只有一个职责。<br>－改善单一职责：类的代码不过长，确保类的以来不超过５个接口／类，确保一个类有一个明确的目标，能用一句话总结类的职责作为注释。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>需求变更或者增加新功能时，你不需要修改现有代码。想扩展开放，对修改关关闭。MVC就是个好例子。重构代码分解任务并能复用。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>一种降低耦合并且改善开闭特性的技术。依赖注入对类需要创建的对象提供一个引用实例，而无需类自己创建依赖对象。一般是把类需要的对象当成一个参数传递进去。这样类就能聚焦自己的主要职责，无需知道谁来提供依赖的实例。比如我们要实现一个播放器类，播放器必须有CD才能播放，我们可以在构造函数中把CD的实例作为构造函数的参数传递进去。</p><h2 id="控制反转-IOC"><a href="#控制反转-IOC" class="headerlink" title="控制反转(IOC)"></a>控制反转(IOC)</h2><p>IOC是一种从类中移除职责的方法，从而使类更简单，与系统其他部分更少耦合。就是你的类实例不必知道自己何时被创建、被谁使用、自己的依赖又是如何被创建的。你的类是一个插件，外部决定这些类什么时候被创建，如何被使用。</p><h2 id="为伸缩性设计"><a href="#为伸缩性设计" class="headerlink" title="为伸缩性设计"></a>为伸缩性设计</h2><p>伸缩性方案可以被浓缩成三个基本设计方法：</p><ul><li>增加副本：同一组件重复部署到多态服务器，最适用于无状态的服务，有状态的服务难以用这种方式伸缩。该方案需要找个方法同步状态。</li><li>功能分割: 基于功能将系统分隔成独立的子系统，常用于底层。</li><li>数据分片: 在每台服务器上只部署一部分数据，无共享架构，每个节点完全自治，几乎有无限的伸缩性。但是也是代价最高、最昂贵的技术，难点在于要访问数据需要找到数据所在的分区服务器，如果一个查询在涉及分区，实现会变得低效和困难。</li></ul><h2 id="自愈设计"><a href="#自愈设计" class="headerlink" title="自愈设计"></a>自愈设计</h2><p>设计系统要考虑高可用和系统自愈能力，设计一个伸缩性架构必须把各种失效状态视为常态，而不是特殊对待，要不停地想哪里会出错，出错后怎么办。系统能在最短时间内恢复，并且能自动化完成，就是自愈。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://python-web-guide.readthedocs.io/zh/latest/codingstyle/codingstyle.html" target="_blank" rel="noopener">编码之前碎碎念</a> - 我在这里也列举了很多之前碰到的细节问题，上边提到的很多有点假大空，具体还要在代码里实践，大到一个模块，小到一个函数<br>《Web Scalability for Startup Engineers》 - 讲创业公司如何构建可伸缩的web应用的书</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Everything Should Be Made as Simple as Possible, But Not Simpler. - Albert Einstein&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得编写软件的过程就是和和复杂度斗争的过程，无论是编写传统的pc软件还是web应用。对于python这种动态语言，很多问题是在运行时才暴露出来的，而且动态语言相对难以维护和重构。我一直感觉使用动态语言的时候要更加重视项目工程的管理，控制复杂度，防止代码仓库失控。了解一些常用原则降低复杂度还是有必要的。&lt;/p&gt;
    
    </summary>
    
      <category term="design" scheme="http://ningning.today/categories/design/"/>
    
    
      <category term="design" scheme="http://ningning.today/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>Practical Vim</title>
    <link href="http://ningning.today/2017/02/13/tools/practical-vim/"/>
    <id>http://ningning.today/2017/02/13/tools/practical-vim/</id>
    <published>2017-02-13T11:38:10.000Z</published>
    <updated>2017-08-06T12:54:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Do one thing, and do it well. - A principle of Unix philosopy</p></blockquote><p>学习和使用vim有几年了，我的编辑器学习之路也该告一段落了，目前使用vim和一些插件基本能满足日常代码和文档(博客，笔记，代码文档)的编辑需求了，也无力折腾其他编辑器了。现在大部分时间都是在终端和vim里工作，我觉得在vim上花的时间还是值得的。本博客所有的文章都是在vim里写的，配合markdown插件可以在浏览器里即时预览。本博客是《Practical Vim》读书笔记，不是一本入门书，以一个个tip的形式组织，凝聚了作者的使用智慧，结合自己的使用经验做个简单的记录。</p><a id="more"></a><h2 id="CHAPTER-1-The-Vim-Way"><a href="#CHAPTER-1-The-Vim-Way" class="headerlink" title="CHAPTER 1: The Vim Way"></a>CHAPTER 1: The Vim Way</h2><ul><li>Tip1: Meet the Dot Command: 使用.重复上一个操作，可以视作宏。</li><li>Tip2: Don’t Repeat Yourself: 我们可以用A替代$a移动到行尾进行编辑。类似还有C,I,S,O等</li><li>Tip3: Take One Step Back, Then Three Forward: 适当组合键位可以充分发挥.重复的优势。我们可以用f{char}来查找字母，”;”可以用来重复上一次查找，之后用”.”重复上次一操作，”,”可以用来返回上一次查找</li><li>Tip4: Act, Repeat, Reverse: 善用undo操作。</li><li>Tip5: Find and Replace by Hand: 使用<code>*</code>和<code>#</code>查找下一个或者上一个匹配。</li><li>Tip6: Meet the Dot formula: One Keystroke to Move, One Keystroke to Execute.</li></ul><h2 id="CHAPTER2-Normal-Mode"><a href="#CHAPTER2-Normal-Mode" class="headerlink" title="CHAPTER2: Normal Mode"></a>CHAPTER2: Normal Mode</h2><ul><li>Tip7: Pause with Your Brush Off the Page: vim和其他编辑器一个显著不同就是默认不是编辑模式(insert mode)而是normal模式。实际上在编程中，大部分时间花在浏览，阅读，思考，组织和调整代码，而normal模式下众多命令能帮助我们大大提高效率。</li><li>Tip8: Chunk your Undos: u能帮助我们撤销操作，合理在insert模式和normal模式切换能让undo操作更高效</li><li>Tip9: Compose Repeatable Changes: vim is optimized for repetition。在vim里完成一个操作通常有多种方式，但是容易使用”.”来重复的是比较好的方式。</li><li>Tip10: Use Counts to Do Simple Arithmetic: vim很多命令都可以在前边加上数字表示重复几次命令，比如<code>&lt;C-a&gt;</code>对数字加1，如果用<code>10&lt;C-a&gt;</code>就是加上10。</li><li>Tip11: Don’t Count If You Can Repeat:  Keep your undo history clean.</li><li>Tip12: Combine and Conquer:  Operator + Motion = Action，vim的强大在于组合命令的威力。比如d{motion}，”daw”是”delete a word”，比如”gU{motion}”的意思是Make {motion} text uppercase, “gUaw” 就是把一个单词转成大写，”gUap”就是把一个段落大写</li></ul><h2 id="CHAPTER3-Insert-Mode"><a href="#CHAPTER3-Insert-Mode" class="headerlink" title="CHAPTER3: Insert Mode"></a>CHAPTER3: Insert Mode</h2><ul><li>Tip13: Make Corrections Instantly from Insert Mode: 快速修正错误，<code>&lt;C-h&gt;</code>删除一个字符，<code>&lt;C-w&gt;</code>删除一个单词,<code>&lt;C-u&gt;</code>删除一行。实际上这些快捷键在和终端里是一样的，刻意替代退格键。</li><li>Tip14: Get Back to Normal Mode: <code>&lt;ESC&gt;</code> 和 <code>&lt;C-[&gt;</code>都可以从insert模式切到normal模式，在insert模式下<code>&lt;C-o&gt;</code>是短暂切到normal模式之后切回insert模式，方便我们执行单个normal模式下的命令。配合上边快捷键我们就能在主键盘区域高效完成编辑操作。(把caps lock键改成ctrl)</li><li>Tip15: Paste from a Register Without Leabing Insert Mode: <code>&lt;C-r&gt;{register}</code>，实现在insert模式下粘贴</li><li>Tip16: Do Back-of-the-Envelope Calculations in Place:  vim的表达式寄存器(=)可以用来计算数值。<code>&lt;C-r&gt;=6*35&lt;CR&gt;</code>可以插入计算结果为210</li><li>Tip17: Insert Unusual Characters By Character Code: 在插入模式下，可以用unicode码插入，比如 <code>&lt;C-v&gt;065</code> 将插入字符A</li><li>Tip18: Insert Unusual Characters by Digraph: <code>:h digraph-table</code> ，也是用来插入特殊字符</li><li>Tip19: Overwrite Existing Text with Replace Mode: <code>R</code>进入replace mode，平常我使用<code>r</code>进行单个字符修改，使用<code>R</code>可以从当前字符开始覆盖。</li></ul><h2 id="CHAPTER4-Visual-Mode"><a href="#CHAPTER4-Visual-Mode" class="headerlink" title="CHAPTER4: Visual Mode"></a>CHAPTER4: Visual Mode</h2><ul><li>Tip20: Grok Visual Mode:  Visual Mode可以实现字符、行、块选择，结合其他命令实现多种操作。</li><li>Tip21: Define a Visual Selection: <code>v</code>字符选择, <code>V</code>行选择，<code>&lt;C-v&gt;</code>块选，<code>gv</code>重新执行最后一个visual mode的选择区域,<code>o</code>可以跳到选择的另一头，方便选择错误的时候两头调整。比如<code>vw</code>选中一个单词，<code>viw</code>无论你在单词的哪个位置都可以选中当前单词。<code>vi(</code>就更方便了，你可以在括号里的任何位置选中当前括号里所有内容，执行修改或者删除等操作，还有<code>vit</code>选中html标签里的内容，<code>vif</code>选中函数里的内容。</li><li>Tip22: Repeat Line-Wise Visual Commands: 笔者经常使用visual mode选中需要缩进的代码块，然后执行<code>&gt;</code>向右缩进，使用<code>.</code>重复缩进。</li><li>Tip23: Prefer Operators to Visual Commands Where Possible: 优先使用操作符命令方便使用<code>.</code>重复命令</li><li>Tip24: Edit Tabular Data with Visual-Block Mode:  vim的visual mode很适合编辑表格类文本。使用 tabular 插件能方便地书写 markdown 格式的表格。</li><li>Tip25: Change Columns of Text: 在笔者使用nerd-commenter插件之前，实现多行注释都是用的多列编辑。</li><li>Tip26: Append After a Ragged Visual Block: 结合$等，我们可以在vim里方便地实现给多行最后加上分号等功能。</li></ul><h2 id="CHAPTER5-Command-Line-Mode"><a href="#CHAPTER5-Command-Line-Mode" class="headerlink" title="CHAPTER5: Command-Line Mode"></a>CHAPTER5: Command-Line Mode</h2><ul><li>Tip27: Meet Vim’s Command Line: 命令模式允许我们执行一个ex命令，搜索模式或者表达式</li><li>Tip28: Execute a Command on One or More Consecutive Lines: ex模式下可以同时对多行进行操作，比如<code>:1,3p</code>打出前三行</li><li>Tip29: Duplicate or Move Lines Using <code>:t</code> and <code>:m</code> Commands: <code>:t</code>是<code>:c</code>的简化命令，执行一样的功能。比如<code>:6copy.</code>把第六行拷贝到当前行下边，能直接用<code>:6t.</code>。<code>:m</code>用来执行移动行的功能，语法形式<code>:[range]move {address}</code></li><li>Tip30: Run Normal Mode Commands Across a Range: 再来看之前的一个例子，如果想给多行最后添加分号，我们刻意操作一行<code>A,&lt;ESC&gt;</code>表示在行尾插入一个逗号，之后我们在visual模式下选中多行，执行<code>:normal.</code>就能用<code>.</code>对这些行执行相同命令，或者执行<code>:normal A,</code>，也能给多行末尾添加逗号。结合多行选择和normal模式下的命令我们可以实现很多有用的操作。</li><li>Tip31: Repeat the Last Ex Command: 我们经常使用<code>.</code>来重复normal模式的上一条命令，重复ex命令要使用<code>@:</code></li><li>Tip32: Tab-Complete Your Ex Commands: 和在shell里一样，可以使用tab补全ex命令，也可以使用<code>&lt;C-d&gt;</code>列出所有候选项，使用<code>&lt;S-Tab&gt;</code>回滚到上一个候选项。</li><li>Tip33: Insert the Current Word at the Command Prompt: 在命令模式下，vim依然知道光标位置，使用<code>&lt;C-r&gt;&lt;C-w&gt;</code>可以插入当前光标所在单词。我觉得这个命令在你想替换一个超长单词的时候比较有用，貌似对中文支持不行。</li><li>Tip34: Recall Commands from History: 使用<code>:</code>进入命令模式以后就能使用上下键或者<code>&lt;C-p&gt;&lt;C-n&gt;</code>上翻下翻命令，列出所有搜索历史命令执行<code>q/</code>，列出所有历史Ex命令执行<code>q:</code>，<code>C-f</code>从命令行模式切换到命令行窗口。</li><li>Tip35: Run Commands in the Shell: 命令行模式前边加上<code>!</code>就可以执行shell命令，比如<code>:!ls</code>，注意内置的<code>:ls</code>显示的是buffer列表。也可以用<code>:shell</code>启动交互式shell会话，exit退出。<code>:read !{cmd}</code>可以使shell的命令写到buffer,<code>:write {cmd}</code>把buffer里的内容作为shell命令的标准输入。</li></ul><h2 id="CHAPTER6-Manage-Multiple-Files"><a href="#CHAPTER6-Manage-Multiple-Files" class="headerlink" title="CHAPTER6: Manage Multiple Files"></a>CHAPTER6: Manage Multiple Files</h2><ul><li>Tip36: Track Open Files with the Buffer List: 在一次编辑会话中我们可以同时打开多个文件，vim使用buffer list管理他们。当我们在vim里编辑一个文件时，实际上是在编辑一个文件的内存表示，在vim术语里头叫做buffer。文件存储在硬盘，而buffers存在于内存中，大部分vim命令操作的是buffer，只有<code>:write</code>等少数命令会操作到硬盘中的文件。<code>:ls</code>列出所有buffer，<code>:bnext</code>或者<code>:bn</code>跳转到下一个buffer，<code>:bprev</code>或者<code>bp</code>跳到上一个，使用<code>C-^</code>来回切换，<code>:bd</code>移除当前buffer，同样还有<code>:bfirst</code>和<code>:blast</code>。如果觉得麻烦我可以可以映射命令<code>nnoremap &lt;silent&gt; [b :bprevious&lt;CR&gt;</code></li><li>Tip37: Group Buffers into a Collection with the ArgumentList: <code>:args</code>代表传入给vim命令的待编辑文件列表，我们也可以使用<code>:args file1 file2</code>命令组织待编辑的文件buffer。</li><li>Tip38: Manage Hidden Files: 如果我们修改了buffer里的文件，必须保存才能切换到下一个文件，否则vim提示 “No write since last change (add ! to override)”。我们可以使用<code>:w</code>保存或者<code>:e!</code>放弃所有更改重新加载文件。</li><li>Tip39: Divide Your Workspace into Split Windows: 分屏是笔者平常写代码的时候最最常用的功能，能让你同时浏览多个文件快速输理逻辑（所以平常写代码不要太长，限定80或者120列，否则分屏看起来比较痛苦）。可以用<code>&lt;C-w&gt;s</code>横分屏或者<code>&lt;C-w&gt;v</code>竖分屏，或者<code>:sp {file}</code>横分屏<code>:vsp {file}</code>竖分屏 。分频后，用<code>&lt;C-w&gt;h</code> <code>&lt;C-w&gt;j</code>等切换窗口，hjkl和移动命令对应，<code>&lt;C-w&gt;</code>循环切换。使用<code>&lt;C-w&gt;c</code>或者<code>:cl[ose]</code>关闭当前窗口，使用<code>&lt;C-w&gt;o</code>或<code>:on[ly]</code>只保留当前窗口。还有几个调整窗口大小的命令:<code>&lt;C-w&gt;=</code>重置所有窗口相等大小,<code>&lt;C-w&gt;_</code>当前窗口高度最大化，<code>&lt;C-w&gt;|</code>当前窗口宽度最大化。嗯，是不是命令太多头都大了，记住常用的几个天天使用就好，我现在就慢慢都习惯了，效率还是挺高的。</li><li>Tip40: Organize Your Window Layouts with Tab Pages: buffer+分屏+tab组合起来实现了vim强大的多文件编辑功能。vim的tab和其他常用的编辑器有很大不同，大多数编辑器每打开一个文件就会生成一个tab，但是当我们用<code>:edit {file}</code>打开一个文件时，vim并不会自动创建新标签，而是使用新的buffer加载文件。这样的好处就是我们可以使用vim的tab来组织工作区，举个例子，笔者有时用一个vim开了三个tab（工作区），每个tab下我又分屏打开了多个文件，最多的时候能打开十来个文件。一个工作区编写后端代码，一个工作区查看前端代码，一个工作区用来修改测试脚本。当然这种情况比较少，打开这么多文件大脑负担会比较重，其实有了ctrlP等插件后定位和打开文件已经相当迅速了，在一个工作区中也能快速切换，而且开多了可能还会有性能问题。使用<code>:tabedit {filename}</code>打开新标签页，没有文件名打开一个包含空buffer的标签页。如果打开了多个窗口，使用<code>&lt;C-w&gt;T</code>会把当前窗口移到一个新的标签页，如果只使用一个窗口，使用<code>:close</code>关闭当前标签和窗口，或者<code>:tabclose</code>关闭当前标签页（不管有几个窗口），<code>:tabonly</code>只保留当前标签页面。使用<code>gt</code>和<code>gT</code>来回在标签页跳转，或者用<code>:tabn</code>和<code>:tabp</code></li></ul><h2 id="CHAPTER7-Open-Files-and-Save-Them-to-Disk"><a href="#CHAPTER7-Open-Files-and-Save-Them-to-Disk" class="headerlink" title="CHAPTER7: Open Files and Save Them to Disk"></a>CHAPTER7: Open Files and Save Them to Disk</h2><ul><li>Tip41: Open a File by Its Filepath Using <code>:edit</code> : 可以使用<code>:e {filepath}</code>在vim里打开文件。</li><li>Tip42: Open a File by Its Filename Using <code>:finded {filename}</code> : 我更推荐ctrlP插件来查找文件，相当强大快捷。</li><li>Tip43: Explore the File System with newtrw: 我更推荐nerdTree插件来实现文件树浏览。</li><li>Tip44: Save Files to Nonexistent Directories: <code>:mkdir -p %:h</code>之后<code>:w</code></li><li>Tip45: Save a File as the Super User: 我们经常忘记sudo去编辑一个文件，结果保存的时候会提示readonly无法保存。<code>:w !sudo tee % &gt; /dev/null</code></li></ul><h2 id="CHAPTER8-Navigate-inside-Fileds-with-Motions"><a href="#CHAPTER8-Navigate-inside-Fileds-with-Motions" class="headerlink" title="CHAPTER8: Navigate inside Fileds with Motions"></a>CHAPTER8: Navigate inside Fileds with Motions</h2><ul><li>Tip46: Keep your Fingers on the Home Row: vim的很多设计让我们集中在主键盘区，从而避免的手指的来回移动。最明显的就是不使用上下左右，而是使用”hjkl”，习惯了以后效率会很高。</li><li>Tip47: Distinguish Betwween Real Lines and Display Lines: 当一行过长时，vim会分几行显示，实际上这几行叫做显示行，看起来是多行实际上没有换行符。我们用<code>j</code>和<code>k</code>在真实行之间向下或者向上移动，而对于显示行，我们使用<code>gj</code>和<code>gk</code>来移动。实际上还有几个类似的命令都可以在前面加上g来操作显示行。比如<code>g0</code>和g<code>g&amp;</code>移动到显示行的行首和行尾</li><li>Tip48: Move Word-Wise: 文本编辑一个常用操作就是在单词之间移动，最常用的几个<ul><li>w: 移到下一个单词首部, 助记(for-)Word</li><li>b: 移到上一个单词首部, 助记(Back-)word</li><li>e: 移到下一个单词尾部</li><li>ge: 移到上一个单词尾部</li></ul></li><li>Tip49: Find by Character: 一个常用操作是搜索一行里的字符<code>f{char}</code>，<code>;</code>重复搜索跳转到下一个相同字符，<code>,</code>跳转到上一个搜索字符位置。<ul><li>f{char}: 移到char的下一次出现</li><li>F{char}: 移到char的上一次出现</li><li>t{char}: 移到(To)char出现的位置的前一个字符，我们可以用<code>dt{char}</code>删除直到字符char的下一次出现，比如我经常用来删除一个括号里的内容，<code>dt)</code>我经常用来删除右括号前的所有字符</li><li>T{char}: 移到上一个char的前一个字符位置</li></ul></li><li>Tip50: Search to Navigate: <code>/{word}&lt;CR&gt;</code>我们可以用命令模式中的<code>/</code>来执行搜索</li><li>Tip51: Trace your Selection with Precision Text Objects: “Text objects”允许哦我们直接和括号，引用，xml标签等直接交互。比如我们想直接选定括号里的内容，使用<code>vi}</code>，”Text objects”通常用来操作结构化的数据，</li><li><p>Tip52: Delete Around, or Change Inside: 使用text objects我们能实现在一个单词内部实现操作当前单词的需求，而不用移到单词首部</p><ul><li>iw: current word</li><li>aw: current word plus one space, 比如我们可以用<code>daw</code>在一个单词的任意位置删除当前单词，而不用移到首部</li><li>is: current sentence</li><li>as: current sentence plus one space</li><li>ip: current paragraph</li><li>ap: current paragraph plus one blank line</li></ul></li><li><p>Tip53: Mark Your Place and snap Back to it :  在vim里可以给位置做标记从而快速跳转。<code>m{mark}</code>和 `mark  分别标记和跳转。有几个常用的跳转:</p><ul><li><code></code>    当前文件的上一个跳转</li><li>`.    Location of Last change</li><li>`^    Location of last insertion</li></ul></li><li><p>Tip54: Jump Between Matching Parentheses: 最常用的就是使用%在括号之间跳转，我们还可以用vim插件matchit增强功能</p></li></ul><h2 id="CHAPTER-9-Navigate-Betwween-Files-With-Jumps"><a href="#CHAPTER-9-Navigate-Betwween-Files-With-Jumps" class="headerlink" title="CHAPTER 9: Navigate Betwween Files With Jumps"></a>CHAPTER 9: Navigate Betwween Files With Jumps</h2><ul><li><p>Tip55: Traverse the Jump List: <code>:jumps</code>能列出跳转历史，<code>&lt;C-o&gt;</code>和<code>&lt;C-i&gt;</code>能切换跳转</p><ul><li>[count]G     跳转到行数</li><li>%     跳转到对应的括号</li><li>( / )     跳转到上一个/下一个句子</li><li>{ / }    跳转到上一个/下一个段落</li><li>H/M/L    H/M/L分别跳转到屏幕顶部/中间/尾部</li><li>gf      跳转到文件，如果在 vim 中引入了某个文件路径可以直接跳转</li><li>&lt;C-]&gt;    跳转到当前关键字的第一次出现，经常用来查找定义</li><li><code>{mark}</code>   跳转到标记</li></ul></li><li><p>Tip56: Traverse the Change List: vim会记录当前buffer所有改变，用<code>:changes</code>查看。一般用diff工具我觉得更好看点。有写插件可以记录整个文件变更。</p></li><li><p>Tip57: Jump to the Filename Under the Cursor:  不如直接用ctrlP插件快速打开文件，不用记忆命令了，vim命令够多了.</p></li><li><p>Tip58: Snap Betwween Files Global Marks: 全局标记可以在文件中来回跳转，<code>m{char}</code>char为大写就是全局标记。</p></li></ul><h2 id="CHAPTER-10-Copy-and-Paste"><a href="#CHAPTER-10-Copy-and-Paste" class="headerlink" title="CHAPTER 10: Copy and Paste"></a>CHAPTER 10: Copy and Paste</h2><ul><li><p>Tip59: Delete, Yank, and Put with Vim’s Unnamed Register: 我们可以用<code>xp</code>来反转字母，用<code>ddp</code>反转两行，这些都是使用的无名寄存器。</p></li><li><p>Tip60: Grok Vim’s Registers: vim提供了多个寄存器，我们可以用<code>&quot;{register}</code>指定使用哪个寄存器，否则使用无名寄存器(“”)，所以使用<code>&quot;&quot;p</code>等价直接用p命令。System Clipboard(“+)和Selection(“*) Registers</p></li><li><p>Tip61: Replace a Visual Selection with a Register: 直接visual选中后使用粘贴命令p</p></li><li><p>Tip62: Paste from a Register: 在insert模式下可以用<code>&lt;C-r&gt;&quot;</code></p></li><li><p>Tip63: Interact with the System Clipboard: 粘贴的时候使用<code>:paste</code>能避免自动缩进，映射一个命令<code>:set pastetoggle=&lt;F2&gt;</code>比较方便，最好放到你的vimrc里。</p></li></ul><h2 id="CHAPTER-11-Macros"><a href="#CHAPTER-11-Macros" class="headerlink" title="CHAPTER 11: Macros"></a>CHAPTER 11: Macros</h2><ul><li><p>Tip64: Record and Execute a Macro: 宏经常用来对多行执行相同操作，我们可以录制宏并执行它。<code>q{register}</code>录制宏，之后q退出录制，用<code>:reg {register}</code>查看宏内容，用<code>@{register}</code>执行宏，使用<code>:[range]norm! @a</code>对多行执行宏。</p></li><li><p>Tip65: Normalize, Strike, Abort: 黄金法则：录制宏的时候，保证每个命令都是可重复的。</p></li><li><p>Tip66: Play Back with a Count; <code>.</code>重复命令的缺陷是无法指定次数，这个缺陷可以使用宏解决。</p></li><li><p>Tip67: Repeat a Change on Contiguous Lines: 可以用块选择后执行<code>normal @a</code>针对多行执行宏。</p></li><li><p>Tip68: Append Commands to a Macro: <code>q{char}</code>当char是大写的时候会把命令append到已经存在的对应的小写字母寄存器中。</p></li><li><p>Tip69: Act Upon a Collection of Files: 需要结合argdo命令针对多个文件执行宏，笔者没用过。</p></li><li><p>Tip70: Evaluate an Iterator to number Items in a List: 结合简单的vim脚本语句和宏能实现类似于给每行加上自增行号的需求。</p></li><li><p>Tip71: Edit the Contents of a Macro: <code>put {register}</code>可以输出当前宏命令，编辑以后yank到寄存器里。</p></li></ul><h2 id="CHAPTER-12-Matching-Patterns-and-Literals"><a href="#CHAPTER-12-Matching-Patterns-and-Literals" class="headerlink" title="CHAPTER 12: Matching Patterns and Literals"></a>CHAPTER 12: Matching Patterns and Literals</h2><ul><li>Tip72: Tune the Case Sensitivity of Search Patterns: 全局设定忽略大小写<code>:set ignorecase</code>，对于单独的搜索在最后加上<code>\c</code>忽略大小写，</li><li><p>Tip73: Use the \v Pattern Switch for Regex Searches: vim的正则语法接近POSIX而不是Perl的。使用<code>\v</code>后缀能切换vim的正则引擎更接近Perl,Python or Ruby.</p></li><li><p>Tip74: Use the \V Literal Switch for Verbatim Searches: 使用<code>\V</code>意味着其后的pattern只有反斜线有特殊含义。如果你想匹配正则，使用 <code>\v</code>，如果你想精确匹配文本，使用<code>\V</code></p></li><li><p>Tip75: Use Parentheses to Capture Submatches: 使用括号匹配子组。<code>/\v&lt;(\w+)\_s+\1&gt;</code>可以匹配重复单词</p></li><li><p>Tip76: Stake the Boundaries of a Word: <code>&lt;</code>和<code>&gt;</code>作为单词分界符，比如可以用<code>\&lt;hello\&gt;</code>精确匹配hello</p></li><li><p>Tip77: Stake the Boundaries of a Match: 可以使用<code>\zs</code>和<code>\ze</code>截断匹配，只高亮需要的部分。</p></li><li><p>Tip78: Escape Problem Characters: vim提供了escape函数来实现重复的转义操作</p></li></ul><h2 id="CHAPTER-13-Search"><a href="#CHAPTER-13-Search" class="headerlink" title="CHAPTER 13: Search"></a>CHAPTER 13: Search</h2><ul><li><p>Tip79: Meet the Search Command: 命令模式输入<code>/</code>进入搜索模式并从当前光标位置往后搜索，<code>?</code>反向搜索。n和N分别是跳转到下一个和上一个搜索位置</p></li><li><p>Tip80: Highlight Search Matches: 高亮搜索结果<code>:set hlsearch</code>，静默搜索<code>:se nohlsearch</code></p></li><li><p>Tip81: Preview the First Match Before Execution: <code>:set incsearch</code>增量搜索，每按下一个字符就会显示搜索到的单词。搜索中使用<code>&lt;C-r&gt;&lt;C-w&gt;</code>补全。</p></li><li><p>Tip82: Count the Matches for the Current Pattern:  <code>:% s/words//gn</code> 可以统计出有多少匹配到的words，实际上就是使用的替换模式加上标志n</p></li><li><p>Tip83: Offset the Cursor to the End of a Search Match: 使用<code>/words/e&lt;CR&gt;</code>可以把光标放到搜索匹配的结尾</p></li><li><p>Tip84: Operate on a Complete Search Match: vim没有自带比较好的实现，不过能通过插件textobj-lastpat实现。</p></li><li><p>Tip85: Create Complex Patterns by Iterating upon Search History: 可以编辑search历史不断修正search的结果</p></li><li><p>Tip86: Search for the Current Visual Selection: 在normal模式下可以用 * 找到下一个匹配，这个不支持块选的区域，可以通过脚本实现</p></li></ul><h2 id="CHAPTER-14-Substitution"><a href="#CHAPTER-14-Substitution" class="headerlink" title="CHAPTER 14: Substitution"></a>CHAPTER 14: Substitution</h2><ul><li><p>Tip87: Meet the Substitute Command: 语法形式<code>:[range]s[ubstitute]/{pattern}/{string}/[flags]</code>，flags包含g(全局)，c(确认提示)，n(次数提示)，&amp;(复用上一个flag)</p></li><li><p>Tip88: Find and Replace Every Match in a File: 默认搜索只操作当前行第一个搜索，加flag g以后可以操作所有当前行的匹配，加上range之后我们可以操作所有当前文件的匹配。</p></li><li><p>Tip89: Eyeball Each Substitution: 替换过程中使用flag c每次替换vim都会有提示，比较安全</p></li><li><p>Tip90: Reuse the Last Search Pattern: Pressing <c-r>/ at the command line pastes the contents of the last search register in place.</c-r></p></li><li><p>Tip91: Replace with the Contents of a Register: We can insert the contents of a register by typing <c-r>{register}。如果待搜索的内容过长，实际上可以在normal模式下复制到寄存器里，然后插入到替换命令里头。</c-r></p></li><li><p>Tip92: Repeat the Previous Substitute Command:  We can always specify a new range and replay the substitution using the :&amp;&amp; command.</p></li><li><p>Tip93: Rearrange CSV Fields Using Submatches: 可以用<code>\{num}</code>在替换语句里使用<code>/</code>搜索命令捕获的分组。</p></li><li><p>Tip94: Perform Arithmetic on the Replacement: 这个是比较高级的用法，替换语句可以是一个vim脚本的表达式。</p></li><li><p>Tip95: Swap Two or More Words : 我们可以创建一个vim脚本变量字典来执行替换操作。Abolish.vim插件提供了非常便捷的语法支持替换操作: <code>:%S/{man,dog}/{dog,man}/g</code></p></li><li><p>Tip96: Find and Replace Across Multiple Files: 需要结合argdo命令多文件操作，我觉得不如用sed命令方便点。</p></li></ul><h2 id="CHAPTER-15-Global-Commands"><a href="#CHAPTER-15-Global-Commands" class="headerlink" title="CHAPTER 15: Global Commands"></a>CHAPTER 15: Global Commands</h2><ul><li><p>Tip97: Meet the Global Command: The :global command allows us to run an Ex command on each line that matches a particular pattern. <code>:[range] global[!] /{pattern}/ [cmd]</code></p></li><li><p>Tip98: Delete Lines Containing a Pattern: <code>/\v\&lt;\/?\w+&gt;</code> <code>:g//d</code>可以删除文件中的html标签行，</p></li><li><p>Tip99: Collect TODO Items in a Register: <code>:g/TODO</code>打出所有含有TODO的行，global模式命令执行echo。</p></li><li><p>Tip100:  Alphabetize the Properties of Each Rule in a CSS File: <code>:g/{/ .+1,/}/-1 sort</code></p></li></ul><h2 id="CHAPTER-16-Index-and-Navigate-Source-Code-with-ctags"><a href="#CHAPTER-16-Index-and-Navigate-Source-Code-with-ctags" class="headerlink" title="CHAPTER 16: Index and Navigate Source Code with ctags"></a>CHAPTER 16: Index and Navigate Source Code with ctags</h2><ul><li><p>Tip101: Meet ctags: ubuntu install ctags <code>sudo apt-get install exuberant-ctags</code>, mac <code>brew install ctags</code></p></li><li><p>Tip102: Configure Vim to Work with ctags:  生成tag命令<code>:!ctags -R</code>,映射一个<code>:nnoremap &lt;f5&gt; :!ctags -R&lt;CR&gt;</code>。</p></li><li><p>Tip103: Navigate Keyword Definitions with Vim’s Tag Navigation Commands: 有了tags文件就可以用<code>&lt;C-]&gt;</code>跳转了。笔者目前写python居多，使用的是python-mode里集成的rope插件，用来跳转，查找定义等非常方便。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Do one thing, and do it well. - A principle of Unix philosopy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习和使用vim有几年了，我的编辑器学习之路也该告一段落了，目前使用vim和一些插件基本能满足日常代码和文档(博客，笔记，代码文档)的编辑需求了，也无力折腾其他编辑器了。现在大部分时间都是在终端和vim里工作，我觉得在vim上花的时间还是值得的。本博客所有的文章都是在vim里写的，配合markdown插件可以在浏览器里即时预览。本博客是《Practical Vim》读书笔记，不是一本入门书，以一个个tip的形式组织，凝聚了作者的使用智慧，结合自己的使用经验做个简单的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="http://ningning.today/categories/tools/"/>
    
    
      <category term="vim" scheme="http://ningning.today/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Mysql</title>
    <link href="http://ningning.today/2017/02/13/database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/"/>
    <id>http://ningning.today/2017/02/13/database/深入浅出mysql/</id>
    <published>2017-02-13T11:34:11.000Z</published>
    <updated>2017-02-13T11:44:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A SQL query walks into a bar and sees two tables. He walks up to them and asks, “Can I join you?”</p></blockquote><p>最近看了一本小书，网易技术部的《深入浅出MySQL数据库开发、优化与管理维护》，算是回顾一下mysql基础知识。数据库一直是笔者比较薄弱的地方，结合自己的使用经验(python+sqlalchemy)等做个记录，笔者比较喜欢使用ORM，一直感觉拼sql是一件比较痛苦的事情(主要是不擅长sql)，以前维护项的目中也遇到过一些数据库的坑，比如编码问题，浮点数精度损失等，防止以后重复踩坑。</p><a id="more"></a><h2 id="1章：使用帮助"><a href="#1章：使用帮助" class="headerlink" title="1章：使用帮助"></a>1章：使用帮助</h2><p>使用mysql内置的帮助命令</p><ul><li><code>msyql&gt; ? data types</code> : 查看数据类型</li><li><code>mysql&gt; ? int</code></li><li><code>mysql&gt; ? create table</code></li></ul><h2 id="2章：表类型（存储引擎）的选择"><a href="#2章：表类型（存储引擎）的选择" class="headerlink" title="2章：表类型（存储引擎）的选择"></a>2章：表类型（存储引擎）的选择</h2><p>最常用的两种引擎:</p><ol><li><p>Myisam是Mysql的默认存储引擎,当create创建新表时,未指定新表的存储引擎时,默认使用Myisam。 每个MyISAM 在磁盘上存储成三个文件。文件名都和表名相同,扩展名分别是 .frm (存储表定义) 、.MYD (MYData,存储数据)、.MYI (MYIndex,存储索引)。数据文件和 索引文件可以放置在不同的目录,平均分布io,获得更快的速度。</p></li><li><p>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 Myisam 的存储引擎,InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</p></li></ol><p>常用环境:</p><ol><li>MyISAM: 默认的 MySQL 插件式存储引擎, 它是在 Web、 数据仓储和其他应用环境下最常<br>使用的存储引擎之一</li><li>InnoDB:用于事务处理应用程序,具有众多特性,包括 ACID 事务支持。</li></ol><h2 id="3章：选择合适的数据类型"><a href="#3章：选择合适的数据类型" class="headerlink" title="3章：选择合适的数据类型"></a>3章：选择合适的数据类型</h2><p>首先选择合适的存储引擎，根据指定的存储引擎确定合适的数据类型。</p><ul><li>MyISAM: 最好使用固定长度的数据列代替可变长度的数据列。</li><li>InnoDB: 建议使用varchar</li></ul><p>需要注意的一些数据类型：</p><ul><li><p>char与varchar: 保存和检索方式不同，最大长度和是否尾部空格被保留也不同。char固定长度，长度不够用空格填充，获取时如果没有设置 PAD_CHAR_TO_FULL_LENGTH默认去除尾部空格。<br>varchar变长字符串，检索时尾部空格会被保留。注意查询时候不区分大小写，如果用sqlalchemy区分大小写不要用func.binary函数。</p></li><li><p>text和blob: text和blob执行大量的更新或者删除的时候会留下很大『空洞』，建议定期用OPTIMIZE TABLE功能对这类表碎片整理。避免检索大型的blob或text值 。把text和blob列分离到单独的表中。</p></li><li><p>浮点数float与定点数decimal: 注意几个点：</p><ul><li>1.浮点数虽然能表示更大的数据范围，但是有误差问题。</li><li>2.对货币等精度敏感的问题，应使用定点数存储。之前项目踩过坑，结果不得不用放大和缩小倍数的方法解决，比较ugly。</li><li>3.编程如果遇到浮点数，注意误差问题，尽量避免浮点数比较（比较浮点数需要作差小于一个特定精度），python3.5中可以这么比较：<code>float_eq = partial(math.isclose, rel_tol=1e-09, abs_tol=0.0)</code></li><li>4.注意浮点数中一些特殊值的处理。</li></ul></li></ul><h2 id="4章：字符集"><a href="#4章：字符集" class="headerlink" title="4章：字符集"></a>4章：字符集</h2><p>一开始要选择合适的字符集，否则后期更换代价很高。python2中字符集就是个老大难问题，困然很多新手。之前维护过的项目使用了msyql默认的latin1字符集，导致每次写入的时候都要对字符串手动encode成utf8。最近用python3.5+flask做项目直接使用utf8，再也没碰到过编码问题：</p><ul><li>创建数据库使用utf8，CREATE DATABASE IF NOT EXISTS my_db default charset utf8 COLLATE utf8_general_ci;</li><li>sqlalchemy连接url使用mysql://root:<a href="mailto:root@127.0.0.1" target="_blank" rel="noopener">root@127.0.0.1</a>:3306/my_db?charset=utf8。不用担心乱码问题了</li></ul><h2 id="5章：索引的设计和使用"><a href="#5章：索引的设计和使用" class="headerlink" title="5章：索引的设计和使用"></a>5章：索引的设计和使用</h2><p>所有mysql列类型都可以被索引，对相关列使用索引是提高select操作性能的最佳途径。索引设计的原则:</p><ul><li>1.搜索的索引列，不一定是所要选择的列。最适合的索引的列是出现在where子句中的列，或连接子句中指定的列，而不是出现在select关键字之后的选择列表中的列。</li><li>2.使用唯一索引。对于唯一值的列，索引效果较好，而有多个重复值的列，索引效果差。</li><li>3.使用短索引。如果对字符串列进行索引，应指定一个前缀长度，只要有可能就应该这样做。</li><li>4.利用最左前缀。在创建一个n列索引时，实际上创建了mysql可利用的n个索引。多列索引可以起到几个索引的作用，因为可利用索引中的最左边的列集来匹配行，这样的列集成为最左前缀。</li><li>5.不要过度索引。索引会浪费磁盘空间，降低写入性能。</li><li>6.考虑在列上进行的比较类型。</li></ul><h2 id="6章：锁机制和事务控制"><a href="#6章：锁机制和事务控制" class="headerlink" title="6章：锁机制和事务控制"></a>6章：锁机制和事务控制</h2><p>InnoDB引擎提提供行级锁，支持共享锁和排他锁两种锁定模式，以及四种不同的隔离级别。mysql通过AUTOCOMIT, START TRANSACTIONS, COMMIT和ROLLBACK等语句支持本地事务。</p><h2 id="7章：SQL中的安全问题"><a href="#7章：SQL中的安全问题" class="headerlink" title="7章：SQL中的安全问题"></a>7章：SQL中的安全问题</h2><ul><li>SQL注入：利用某些数据库的外部接口把用户数据插入到实际的数据库操作语音（sql）中，从而达到入侵数据库甚至操作系统的目的。产生原因主要是因为程序堆用户输入的数据没有进行严格的过滤，导致非法数据库查询语句的执行，防范措施：<ul><li>prepareStatement = Bind-variable，不要使用拼接的sql</li><li>使用应用程序提供的转换函数</li><li>自定义函数校验（表单校验等）</li></ul></li></ul><h2 id="8章：SQL-Mode及相关问题"><a href="#8章：SQL-Mode及相关问题" class="headerlink" title="8章：SQL Mode及相关问题"></a>8章：SQL Mode及相关问题</h2><p>更改默认的mysql执行模式，比如严格模式下列的插入或者更新不正确时mysql会给出错误，并放弃操作。<code>set session sql_mode=&#39;STRICT_TRANS_TABLES&#39;</code>。设置sql_mode需要应用人员权衡各种得失，做一个合适的选择。</p><h2 id="9章：常用SQL技巧"><a href="#9章：常用SQL技巧" class="headerlink" title="9章：常用SQL技巧"></a>9章：常用SQL技巧</h2><ul><li>检索包含最大/最小值的行：MAX([DISTINCE] expr), MIN([DISTINCE] expr)</li><li>巧用rand()/rand(n)提取随机行</li><li>利用group by和with rollup子句做统计</li><li>用bit group functions做统计</li></ul><h2 id="10章：其他需要注意的问题"><a href="#10章：其他需要注意的问题" class="headerlink" title="10章：其他需要注意的问题"></a>10章：其他需要注意的问题</h2><ul><li>数据库名、表名大小写问题：不同平台和系统，是否区分大小写是不同的。建议就是始终统一使用小写名。</li><li>使用外键需要注意的地方：mysql中InnoDB支持对外部关键字约束条件的检查。</li></ul><h2 id="11章：SQL优化"><a href="#11章：SQL优化" class="headerlink" title="11章：SQL优化"></a>11章：SQL优化</h2><h4 id="优化SQL的一般步骤："><a href="#优化SQL的一般步骤：" class="headerlink" title="优化SQL的一般步骤："></a>优化SQL的一般步骤：</h4><ul><li>1.使用show status和应用特点了解各种SQL的执行频率，了解各种SQL大致的执行比例。比如InnoDB的的参数Innode_rows_read查询返回的行数，Innodb_rows_inserted执行insert插入的行数，Innodb_rows_updated更新的行数。还有一下几个参数：Connections试图连接mysql服务器嗯出书，Uptime服务器的工作时间，Slow_queries慢查询的次数。</li><li>2.定位执行效率低的SQL语句。两种方式：一种是通过慢查询日志定位执行效率低的语句,使用–log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。另一种是show processlist查看当前mysql在进行的线程，包括线程的状态，所否锁表等，可以实时查看SQL执行情况，同时对一些锁表操作进行优化。</li><li><p>3.通过EXPLAIN分析低效SQL的执行计划：explain可以知道什么时候必须为表假如索引以得到一个使用索引来寻找记录的更快的SELECT，以下是EXPLAIN执行后得到的结果说明：</p><ul><li>select_type: select类型</li><li>table: 输出结果集的表</li><li>type: 表示表的连接类型。当表中仅有一行是type的值为system是最佳的连接类型；当select操作中使用索引进行表连接时type值为ref；当select的表连接没有使用索引时，经常看到type的值为ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引提高表连接效率。</li><li>possible_keys: 表示查询时，可以使用的索引列。</li><li>key： 表示使用的索引</li><li>key_len: 索引长度</li><li>rows: 扫描范围</li><li>Extra: 执行情况的说明和描述</li></ul></li><li><p>4.确定问题，并采取相应优化措施。</p></li></ul><h4 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h4><ul><li><p>索引的存储分类: myisam表的数据文件和索引文件自动分开，innodb的数据和索引放在同一个表空间里面。myisam和innodb的索引存储类型都是btree</p></li><li><p>Mysql如何使用索引: 索引用于快速查找某个列中特定值的行。查询要使用索引最主要的条件是要在查询条件中使用索引关键子，如果是多列索引，那么只有查询条件中使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</p></li><li><p>查看索引的使用情况：Handler_read_key的值代表一个行被索引次数，值低表示索引不被经常使用。Handler_read_rnd_next值高意味着查询运行低效，应该建立索引补救。<code>show status like &#39;Handler_read%&#39;;</code></p></li></ul><h4 id="两个简单实用的优化方法"><a href="#两个简单实用的优化方法" class="headerlink" title="两个简单实用的优化方法"></a>两个简单实用的优化方法</h4><ul><li>定期分析表：ANALYZE TABLE, CHECK TABLE, CHECKSUM TABLE</li><li>使用OPTIMIZE table;</li></ul><h4 id="从客户端（代码端）角度优化"><a href="#从客户端（代码端）角度优化" class="headerlink" title="从客户端（代码端）角度优化"></a>从客户端（代码端）角度优化</h4><ul><li>使用持久的连接数据库以避免连接开销。代码中我们一般使用连接池</li><li>检查所有的插叙确实使用了必要的索引。</li><li>避免在频繁更新的表上执行复杂的select查询，以避免与锁表有关的由于读，写冲突发生的问题。</li><li>充分利用默认值，只有插入值不同于默认值才明确插入值。减少mysql需要做的语法分析从而提高插入速度。</li><li>读写分离提高性能</li><li>表字段尽量不用自增长变量，防止高并发情况下该字段自增影响效率，推荐通过应用实现字段的自增。</li></ul><h2 id="12章-优化数据库对象"><a href="#12章-优化数据库对象" class="headerlink" title="12章: 优化数据库对象"></a>12章: 优化数据库对象</h2><ul><li>优化表的数据类型：PROCEDURE ANALYZE()对当前表类型的判断提出优化建议。实际可以通过统计信息结合应用实际优化。</li><li><p>通过拆分，提高表的访问效率：这里拆分主要是针对Myisam类型的表。</p><ul><li>纵向拆分：按照应用访问的频度，将表中经常访问的字段和不经常访问的字段拆分成两个表，经常访问的字段尽量是定长的。</li><li>横向拆分：按照应用情况，有目的地将数据横向拆分成几个表或者通过分区分到多个分区中，这样可以有效避免Myisam表的读取和更新导致的锁问题。</li></ul></li><li><p>逆规范化：规范化设计强调独立性，数据尽可能少冗余，更多冗余意味着占用更多物理空间，同事也对数据维护和一致性检查带来问题。适当冗余可以减少多表访问，查询效率明显提高，这种情况可以考虑适当通过冗余提高效率。</p></li><li>使用冗余统计表：使用create temporary table做统计分析</li><li>选择更合适的表类型：1.如果应用出现比较严重的锁冲突，请考虑是否刻意更改存储引擎到InnoDB,行锁机制可以有效减少锁冲突出现。2.如果应用查询操作很多，且对事务完整性要求不严格，可以考虑使用Myisam。</li></ul><h2 id="13章：锁问题"><a href="#13章：锁问题" class="headerlink" title="13章：锁问题"></a>13章：锁问题</h2><ul><li>获取锁的等待情况：table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺。检查Innode_row_lock分析行锁的争夺情况。</li></ul><h2 id="14章：优化Mysql-Server"><a href="#14章：优化Mysql-Server" class="headerlink" title="14章：优化Mysql Server"></a>14章：优化Mysql Server</h2><h4 id="查看Mysql-Server当前参数"><a href="#查看Mysql-Server当前参数" class="headerlink" title="查看Mysql Server当前参数"></a>查看Mysql Server当前参数</h4><ul><li>查看服务器参数默认值：<code>mysqld --verbose --help</code></li><li>查看服务器参数实际值：<code>shell&gt; mysqladmin variables</code> or <code>mysql&gt; SHOW VARIABLES</code></li><li>查看服务器运行状态值：<code>mysqladmin extended-status</code> or <code>mysql&gt;SHOW STATUS</code></li></ul><h4 id="影响Mysql性能的重要参数"><a href="#影响Mysql性能的重要参数" class="headerlink" title="影响Mysql性能的重要参数"></a>影响Mysql性能的重要参数</h4><ul><li>key_buffer_size: 键缓存</li><li>table_cache: 数据库中打开的缓存数量</li><li>innode_buffer_pool_size: 缓存InnoDB数据和索引的内存缓冲区的大小</li><li>innodb_flush_log_at_trx_commit: 推荐设成1，在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新。</li></ul><h2 id="15章：I-O问题"><a href="#15章：I-O问题" class="headerlink" title="15章：I/O问题"></a>15章：I/O问题</h2><p>磁盘搜索是巨大的性能瓶颈。</p><ul><li>使用磁盘阵列或虚拟文件卷分布I/O</li><li>使用Symbolic Links分布I/O</li></ul><h2 id="16章：应用优化"><a href="#16章：应用优化" class="headerlink" title="16章：应用优化"></a>16章：应用优化</h2><ul><li>使用连接池：建立连接代价比较高，通过建立连接池提高访问性能。</li><li>减少对Mysql的访问：1.避免对同意数据重复检索。2使用mysql query cache</li><li>增加cache层</li><li>负载均衡：1.利用mysql复制分流查询操作。2分布式数据库架构</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A SQL query walks into a bar and sees two tables. He walks up to them and asks, “Can I join you?”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近看了一本小书，网易技术部的《深入浅出MySQL数据库开发、优化与管理维护》，算是回顾一下mysql基础知识。数据库一直是笔者比较薄弱的地方，结合自己的使用经验(python+sqlalchemy)等做个记录，笔者比较喜欢使用ORM，一直感觉拼sql是一件比较痛苦的事情(主要是不擅长sql)，以前维护项的目中也遇到过一些数据库的坑，比如编码问题，浮点数精度损失等，防止以后重复踩坑。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://ningning.today/categories/database/"/>
    
    
      <category term="mysql" scheme="http://ningning.today/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>python generators, coroutines, native coroutines and async/await</title>
    <link href="http://ningning.today/2017/02/06/python/python-generators-coroutines-native-coroutines-and-async-await/"/>
    <id>http://ningning.today/2017/02/06/python/python-generators-coroutines-native-coroutines-and-async-await/</id>
    <published>2017-02-06T03:46:07.000Z</published>
    <updated>2017-02-08T13:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Abstraction is not about vagueness, it is about being precise at a new semantic level. - Dijkstra</p></blockquote><p>笔者之前学习python的时候就对这几个概念有些困惑，尤其是python3之后又不断添加了<code>yield from, async, await</code>等关键字用来支持异步编程。最近看到一篇比较好的博客就结合自己的理解翻译并解释一下这些概念，包括生成器，协程，原生协程和python3.5引入的async/await。 请使用python3.5运行代码示例。</p><a id="more"></a><hr><h2 id="Generators-生成器"><a href="#Generators-生成器" class="headerlink" title="Generators(生成器)"></a>Generators(生成器)</h2><p>python中生成器是用来生成值的函数。通常函数使用<code>return</code>返回值然后作用域被销毁，再次调用函数会重新执行。但是生成器可以<code>yield</code>一个值之后暂停函数执行，然后控制权交给调用者，之后我们可以恢复其执行并且获取下一个值，我们看一个例子：</p><pre><code>def simple_gen():    yield &apos;hello&apos;    yield &apos;world&apos;gen = simple_gen()print(type(gen))    # &lt;class &apos;generator&apos;&gt;print(next(gen))    # &apos;hello&apos;print(next(gen))    # &apos;world&apos;</code></pre><p>注意生成器函数调用的时候不会直接返回值，而是返回一个类似于可迭代对象(iterable)的生成器对象(generator object)，我们可以对生成器对象调用<code>next()</code>函数来迭代值，或者使用<code>for</code>循环。<br>生成器常用来节省内存，比如我们可以使用生成器函数yield值来替代返回一个耗费内存的大序列:</p><pre><code>def f(n):    res = []    for i in range(n):        res.append(i)    return resdef yield_n(n):    for i in range(n):        yield i</code></pre><hr><h2 id="Coroutines-协程"><a href="#Coroutines-协程" class="headerlink" title="Coroutines(协程)"></a>Coroutines(协程)</h2><p>上一节讲到了使用使用生成器来从函数中获取数据(pull data)，但是如果我们想发送一些数据呢（push data）?这时候协程就发挥作用了。<code>yield</code>关键字既可以用来获取数据也可以在函数中作为表达式(在=右边的时候)。我们可以对生成器对象使用<code>send()</code>方法来给函数发送值。这叫做『基于生成器的协程』(generator based coroutines)，下边是一个示例:</p><pre><code>def coro():    hello = yield &apos;hello&apos;    # yield关键字在=右边作为表达式，可以被send值    yield helloc = coro()print(next(c))    # 输出 &apos;hello&apos;print(c.send(&apos;world&apos;))    # 输出 &apos;world&apos;</code></pre><p>这里发生了什么？和之前一样我们先调用了<code>next()</code>函数，代码执行到<code>yield &#39;hello&#39;</code>然后我们得到了’hello’之后我们使用了<code>send</code>函数发送了一个值’world’, 它使<code>coro</code>恢复执行并且赋了参数’world’给hello这个变量，接着执行到下一行的yield语句并将hello变量的值’world’返回。所以我们得到了<code>send()</code>方法的返回值’world’。</p><p>当我们使用基于生成器的协程(generator based coroutines)时候，术语”generator”和”coroutine”通常表示一个东西，尽管实际上不是。而python3.5以后增加了async/await关键字用来支持原生协程(native coroutines)，我们在后边讨论。</p><hr><h2 id="Async-I-O-and-the-asyncio-module-（异步IO和asyncio模块）"><a href="#Async-I-O-and-the-asyncio-module-（异步IO和asyncio模块）" class="headerlink" title="Async I/O and the asyncio module （异步IO和asyncio模块）"></a>Async I/O and the <code>asyncio</code> module （异步IO和asyncio模块）</h2><p>python3.4以后标准库增加了新的asyncio模块来支持更加简洁的异步编程。我们可以在asyncio模块使用协程轻松实现异步IO，下边是一个来自官方文档的示例：</p><pre><code>import asyncioimport datetimeimport random@asyncio.coroutinedef display_date(num, loop):    end_time = loop.time() + 50.0    while True:        print(&apos;Loop: {} Time: {}&apos;.format(num, datetime.datetime.now()))        if (loop.time() + 1.0) &gt;= end_time:            break        yield from asyncio.sleep(random.randint(0, 5))loop = asyncio.get_event_loop()asyncio.ensure_future(display_date(1, loop))asyncio.ensure_future(display_date(2, loop))loop.run_forever()</code></pre><p>我们创建了一个协程display_date(num, loop)，它接收一个数字和event loop作为参数，然后持续输出当前时间。然后使用<code>yield from</code>关键字来await从<code>asyncio.sleep()</code>执行的结果。<code>asyncio.sleep()</code>是一个协程，在指定时间以后完成。之后我们在默认的事件循环(event loop)中使用<code>asyncio.ensure_future()</code>来调度协程的执行，最后通知事件循环一直执行下去。</p><p>如果我们执行这段代码，可以看到两个协程是并发执行的。当我们用<code>yield from</code>的时候，事件循环知道它将(这里指sleep函数)将会忙碌一段时间然后暂停这个协程的执行转而执行另一个协程。所以这两个协程能够并发执行（注意并发不是并行，因为event loop是单线程的，所以不是真正意义上的『同时执行』）。</p><p>这里只需要知道<code>yield from</code>是一个语法糖用来替代下边这种形式的写法，这种形式使代码更加简洁。</p><pre><code># yield from 等价方式 yield from asyncio.sleep(random.randint(0, 5))for x in asycio.sleep(random.randint(0, 5)):    yield x</code></pre><hr><h2 id="Native-Coroutines-and-async-await-原生线程与async-await"><a href="#Native-Coroutines-and-async-await-原生线程与async-await" class="headerlink" title="Native Coroutines and async/await (原生线程与async/await)"></a>Native Coroutines and async/await (原生线程与async/await)</h2><p>记住到目前为止，我们仍然使用的是 基于生成器的协程(generators based coroutines)，在python3.5中，python增加了使用async/await语法的原生协程(native coroutines)。之前的函数用async/await语法可以这么写:</p><pre><code>import asyncioimport datetimeimport randomasync def display_date(num, loop):    end_time = loop.time() + 50.0    while True:        print(&apos;Loop: {} Time: {}&apos;.format(num, datetime.datetime.now()))        if (loop.time() + 1.0) &gt;= end_time:            break        await asyncio.sleep(random.randint(0, 5))loop = asyncio.get_event_loop()asyncio.ensure_future(display_date(1, loop))asyncio.ensure_future(display_date(2, loop))loop.run_forever()</code></pre><p>你能看出变化吗？实际上就是去掉了装饰器<a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a><code>，然后在定义前加上</code>async<code>关键字，之后把</code>yield from<code>替换成</code>await`。写法是不是更加简洁了？</p><hr><h2 id="Native-vs-Generator-Based-Coroutines-Interoperability-（原生协程-vs-基于生成器的协程）"><a href="#Native-vs-Generator-Based-Coroutines-Interoperability-（原生协程-vs-基于生成器的协程）" class="headerlink" title="Native vs Generator Based Coroutines: Interoperability （原生协程 vs 基于生成器的协程）"></a>Native vs Generator Based Coroutines: Interoperability （原生协程 vs 基于生成器的协程）</h2><p>实际上除了语法之外原生协程(async/await)和基于生成器的协程(@asyncio.coroutine/yield from)并没有功能上的区别。但是注意，这两种写法不能混用，就是说你不能在generator based coroutines里使用<code>await</code>，或者在naive coroutines里头使用<code>yield</code>或者<code>yield from</code>。</p><p>除此之外，两种写法是互通的，我们可以同时使用，比如我们可以在原生协程里<code>await</code>一个基于生成器的协程，也可以在基于生成器的协程里<code>yield from</code>一个使用<code>async</code>定义的原生协程。<br>比如我们同时在一个时间循环里使用两种协程:</p><pre><code>import asyncioimport datetimeimport randomimport types@types.coroutinedef my_sleep_func():    yield from asyncio.sleep(random.randint(0, 5))    # 注意这里就不能用 awaitasync def display_date(num, loop):    end_time = loop.time() + 50.0    while True:        print(&apos;Loop: {} Time: {}&apos;.format(num, datetime.datetime.now()))        if (loop.time() + 1.0) &gt;= end_time:            break        await my_sleep_func()    # 注意这里就不能用 asyncloop = asyncio.get_event_loop()asyncio.ensure_future(display_date(1, loop))asyncio.ensure_future(display_date(2, loop))loop.run_forever()</code></pre><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html#comment-307394" target="_blank" rel="noopener">python: generators, coroutines, native coroutines and async/await</a></p><p><a href="https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="noopener">How the heck does async/await work in Python 3.5?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Abstraction is not about vagueness, it is about being precise at a new semantic level. - Dijkstra&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者之前学习python的时候就对这几个概念有些困惑，尤其是python3之后又不断添加了&lt;code&gt;yield from, async, await&lt;/code&gt;等关键字用来支持异步编程。最近看到一篇比较好的博客就结合自己的理解翻译并解释一下这些概念，包括生成器，协程，原生协程和python3.5引入的async/await。 请使用python3.5运行代码示例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python, coroutine" scheme="http://ningning.today/tags/python-coroutine/"/>
    
  </entry>
  
  <entry>
    <title>《High Performance Python》</title>
    <link href="http://ningning.today/2017/02/05/python/high-performance-python/"/>
    <id>http://ningning.today/2017/02/05/python/high-performance-python/</id>
    <published>2017-02-05T10:41:26.000Z</published>
    <updated>2017-02-05T10:50:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Optimization hinders evolution. - Alan Perlis</p></blockquote><p>最近扫了一本《High Performance Python》，该书从多个角度比如性能度量(profile)，内置数据结构调优，并发，多进程，多线程，使用C加速，异步，分布式，内存调优，其他网站使用经验等介绍了python优化经验，看得出几位作者的计算机体系结构和python功底很深。笔者非计算机科班出身，有些知识点超出了我的能力范围，不过多了解一些东西对于以后技术调研和选型还是很有帮助的，简要记录下涉及到的一些东西。</p><a id="more"></a><hr><h2 id="1章：-Understanding-Performant-Python"><a href="#1章：-Understanding-Performant-Python" class="headerlink" title="1章： Understanding Performant Python"></a>1章： Understanding Performant Python</h2><p>第一张介绍了计算机体系结构，从计算单元，内存单元，通信层次三个角度（我看起来稍微吃力，还是英文版）。最后介绍了下为什么我们选择python？虽然Cpython实现的解释器执行慢，但是python较低的学习成本，高生产力和丰富的生态还是能够解决大部分常见的问题。</p><hr><h2 id="2章：-Profiling-to-Find-Bottlenecks"><a href="#2章：-Profiling-to-Find-Bottlenecks" class="headerlink" title="2章： Profiling to Find Bottlenecks"></a>2章： Profiling to Find Bottlenecks</h2><p>本章介绍了很多性能度量工具，性能优化的第一步就是度量了，很多书上都说不要过早优化，而且优化之前不要仅仅靠猜测，使用profile工具我们可以对程序性能进行分析，找出瓶颈以后再有针对性地进行优化。较为常见的有以下几个</p><ul><li>time.time: 最直接的就是用time函数计时。</li><li>cProfile: 内置性能分析模块。</li><li>line_profiler: 以行为单位度量代码性能问题。</li><li>memory_profiler: 分析内存使用。</li><li>heapy: 以对象Objects为单位分析</li><li>dowser: 生成变量的分析图</li><li>dis: 分析字节码。</li><li>unittest: 性能优化的前提是不改变代码行为，需要有足够的单元测试保证优化以后的代码行为正确。</li></ul><hr><h2 id="3章：List-and-Tuples"><a href="#3章：List-and-Tuples" class="headerlink" title="3章：List and Tuples"></a>3章：List and Tuples</h2><p>最简单和容易实现的优化方式就是选用合适的数据结构和算法了，了解python内置的数据类型和实现方式能让我们避免一些常见的坑。</p><ul><li>list: 可变数组，O(1)访问.</li><li>tuple: 不可变。O(1)访问，相比list更节省内存。caching resource: python对于小于20个元素的tuple会缓存下来， 不会立即进行内存回收。对于固定长度的数组元素，应该优先考虑使用tuple。</li></ul><p>这两种内置数据结构非常常用，需要注意的是list的内存分配。当append操作超过原始分配的内存大小时，会重新开辟内存，把之前的数据复制过去，所以多次调用append有可能会有性能和内存浪费问题。</p><p>元素查找有线性查找(list.index)(On)和有序数组的二分查找(bisect模块)(Ologn)</p><hr><h2 id="4章-Dict-and-Sets"><a href="#4章-Dict-and-Sets" class="headerlink" title="4章:Dict and Sets"></a>4章:Dict and Sets</h2><p>作为dict或者set的键要求是可hash的，可以hash指的是实现了 <strong>hash</strong>和<strong>eq</strong>(或<strong>cmp</strong>)，list这种可变类型的数据结构就无法作为key，dict和set的内部实现都是哈希表。</p><p>对于自定义类型，我们需要实现<strong>has</strong>和<strong>eq</strong>来获得期望的结果:</p><pre><code>class Point:    def __init__(self, x, y):        self.x, self.y = x, y    def __hash__(self):        &quot;&quot;&quot;hash函数尽量保证较少的键冲突&quot;&quot;&quot;        return hash((self.x, self.y))    def __eq__(self, other):        return self.x == other.x and self.y == other.y</code></pre><ul><li>dict: 键值对.插入和查找都是O(1)，但是比较浪费内存。</li><li>set: 类似数学上的集合。插入和查找O(1)，但是当超过原先分配内存的2/3时，为了维持插入和查找效率，重新分配内存。对于固定长度的集合，最好使用frozenset节省内存。</li></ul><hr><h2 id="5章：Iterators-and-Generators"><a href="#5章：Iterators-and-Generators" class="headerlink" title="5章：Iterators and Generators"></a>5章：Iterators and Generators</h2><p>使用生成器可以帮助我们节省内存使用。 在python2中，有range和xrange两个函数，区别在于range函数返回list，xrange返回迭代器，非常节省内存。python3的一大改进就是将很多内置返回整个序列的函数改成了返回迭代器。</p><pre><code>def range(start, stop, step=1):    nums = []    while start &lt; stop:        nums.append(start)        start += step    return numsdef xrange(start, stop, step=1):    while start &lt; stop:        yield start        start += step</code></pre><p>for 语句的原理:</p><pre><code>object_iterator = iter(object)while True:    try:        i = object_iterator.next()        do_work(i)    except StopIteration:        break</code></pre><p>使用itertools模块，内置的itertools模块提供了很多方便的函数处理生成器序列：</p><pre><code>itertools.islice: 对生成器切片操作itertools.chain: 连接多个生成器itertools.takewhile: 给生成器加上终结条件itertools.cycle: 生成循环的的序列</code></pre><hr><h2 id="6章：Matrix-and-Vector-Computation"><a href="#6章：Matrix-and-Vector-Computation" class="headerlink" title="6章：Matrix and Vector Computation"></a>6章：Matrix and Vector Computation</h2><p>这一章举得例子有点高深，涉及到比较多计算机体系的问题，以及perf工具分析程序的执行。简单来说就是涉及到向量或者矩阵运算的时候，还是使用numbpy,pandas等比较成熟优化过的库。笔者公司报表的处理就是使用pandas来处理的，pandas提供了很多方便的结构来操作Excel。</p><hr><h2 id="7章：Compling-to-C"><a href="#7章：Compling-to-C" class="headerlink" title="7章：Compling to C"></a>7章：Compling to C</h2><p>本章介绍了很多使用C语言来加速python的方案，适合cpu密集的代码。不过笔者的职业生涯还没见过使用c来加速代码的项目，因为做的是web应用，一般性能瓶颈出现在IO或者数据库访问上，用c语言的话维护成本也会大大增加。</p><ol><li>Profile to understand program’s behavior</li><li>Improve algorithm based on evidence</li><li>Use a compiler to achieve quick wins</li><li>Beware diminishing returns with extedned effort</li></ol><p>对于一些CPU密集的代码，我们可以用Cython将python代码转成c代码提高执行效率或者使用PyPy来执行。书中还提到了其他几个小众的玩意Shed Skin, Numba，Pythran，不过似乎生产环境下不怎么用，甚至Cython和PyPy生成环境下使用的也很少，之前clone过reddit的代码，发现他们在一些计算密集的小函数上使用了Cython。</p><hr><h2 id="8章：Concurrency"><a href="#8章：Concurrency" class="headerlink" title="8章：Concurrency"></a>8章：Concurrency</h2><p>本章介绍了提升程序并发性能的几种方案，包括使用gevent，tornado，asyncio等，不过目前貌似异步框架在web应用中使用的比例仍然不高。python3引入的asyncio或许是python异步的未来，已经有基于asyncio和aiohttp的异步web框架<a href="https://github.com/channelcat/sanic/" target="_blank" rel="noopener">sanic</a>，性能接近Golang，非常强悍， 不过目前生态圈和案例太少，没有生产环境下的经验能借鉴。异步数据库orm我搜了一下貌似只有一个async-peewee，貌似也没多少人用，感觉python异步web框架还有很多路要走。Instagram，Reddit，Youtube等没有使用异步框架也能撑起巨大的访问，可能有时候可扩展的架构更加重要。</p><p>异步编程中的一些概念:</p><p>Event Loop: 实质上就是一系列需要被执行的函数列表</p><pre><code>from Queue import Queueeventloop = Noneclass EventLoop(Queue):    def start(self):        while True:            function = self.get()            function()def do_hello():    global eventloop    print(&apos;Hello&apos;)    eventloop.put(do_world)def do_world():    global eventloop    print(&apos;world&apos;)    eventloop.put(do_hello)if __name__ == &quot;__main__&quot;:    eventloop = EventLoop()    eventloop.put(do_hello)    eventloop.start()</code></pre><p>我们可以将事件循环和异步IO操作结合，这些操作是非阻塞的，意味着如果我们在一个异步函数上做IO写操作，它会立即返回，即使写操作还没完成。当写操作完成时，事件通知程序写操作完成。这允许我们可以在IO等待时做其他操作。<br>一般实现事件循环有两种形式，callbacks或futures.</p><pre><code># callbacks实现from functools import partialdef save_value(value, callback):    print(&apos;Saving {} to datavase&apos;.format(value))    # save_result_to_db是一个异步函数，立即返回    save_result_to_db(result, callback)def print_response(db_response):    print(&apos;Response from database: {}&apos;.format(db_response))if __name__ == &apos;__main__&apos;:    eventloop.put(        partial(save_value, &quot;Hello world&quot;, print_response)    )</code></pre><p>对于future实现，一个异步函数返回一个future结果的promise而非真正的结果。我们必须等待future完成填充我们需要的结果，期间可以进行其他计算。。</p><pre><code>@coroutinedef save_value(value, callback):    print(&apos;Saving {} to database&apos;.format(value))    db_response = yield save_result_to_db(result, callback)    print(&apos;Response from database: {}&apos;.format(db_response))</code></pre><p>这种实现下save_result_to_db返回future对象，通过yield我们可以暂停它执行直到返回值准备好了恢复它的执行。python里协程使用生成器实现的，因为生成器是python内置的并且支持暂停和恢复操作。我们需要做的就是yield一个future对象，然后事件循环等待它计算完成。一旦完成，事件循环将恢复函数的执行，发送结果到future对象。<br>在python2里边基于future实现的协程有点不优雅，因为我们试图将协程作为真正的函数使用，但是实现协程的生成器是无法返回值的，例如在tornado里python2要 <code>raise gen.Return(json_decode(response.body))</code> 来返回值。从python3.4以后允许协程直接返回值。</p><p>通过爬虫的例子来演示gevent，tornado，asyncio实现异步操作。一个线性运行的爬虫:</p><pre><code>import requestsimport stringimport randomdef generate_urls(base_url, num_urls):    &quot;&quot;&quot;    We add random characters to the end of the URL to break any caching    mechanisms in the requests library or the server    &quot;&quot;&quot;    for i in xrange(num_urls):        yield base_url + &quot;&quot;.join(random.sample(string.ascii_lowercase, 10))def run_experiment(base_url, num_iter=500):    response_size = 0    for url in generate_urls(base_url, num_iter):        response = requests.get(url)        response_size += len(response.text)    return response_sizeif __name__ == &quot;__main__&quot;:    import time    delay = 100    num_iter = 50    base_url = &quot;http://127.0.0.1:8080/add?name=serial&amp;delay={}&amp;&quot;.format(delay)    start = time.time()    result = run_experiment(base_url, num_iter)    end = time.time()    print(&quot;Result: {}, Time: {}&quot;.format(result, end - start))</code></pre><p>gevent: monkey-patch标准IO函数使之变成异步的。，它有一个被称为『Greenlet』的对象用来执行并发操作。gevent使用事件循环在IO等待期间对greenlet进行调度，直到所有greenlet执行完成。</p><pre><code>from gevent import monkeymonkey.patch_socket()import geventfrom gevent.coros import Semaphoreimport urllib2from contextlib import closingimport stringimport randomdef generate_urls(base_url, num_urls):    for i in xrange(num_urls):        yield base_url + &quot;&quot;.join(random.sample(string.ascii_lowercase, 10))def download(url, semaphore):    with semaphore, closing(urllib2.urlopen(url)) as data:        return data.read()def chunked_requests(urls, chunk_size=100):    semaphore = Semaphore(chunk_size)    # 用来控制并发数    requests = [gevent.spawn(download, u, semaphore) for u in urls]    for response in gevent.iwait(requests):    # 事件循环只在iwait调用时执行        yield responsedef run_experiment(base_url, num_iter=500):    urls = generate_urls(base_url, num_iter)    response_futures = chunked_requests(urls, 100)    response_size = sum(len(r.value) for r in response_futures)    return response_sizeif __name__ == &quot;__main__&quot;:    import time    delay = 100    num_iter = 500    base_url = &quot;http://127.0.0.1:8080/add?name=gevent&amp;delay={}&amp;&quot;.format(delay)    start = time.time()    result = run_experiment(base_url, num_iter)    end = time.time()    print(&quot;Result: {}, Time: {}&quot;.format(result, end - start))</code></pre><p>下边是使用tornado的异步HTTPClient爬虫示例:</p><pre><code>from tornado import ioloopfrom tornado.httpclient import AsyncHTTPClientfrom tornado import genfrom functools import partialimport stringimport randomAsyncHTTPClient.configure(    &quot;tornado.curl_httpclient.CurlAsyncHTTPClient&quot;, max_clients=100)def generate_urls(base_url, num_urls):    for i in xrange(num_urls):        yield base_url + &quot;&quot;.join(random.sample(string.ascii_lowercase, 10))@gen.coroutinedef run_experiment(base_url, num_iter=500):    http_client = AsyncHTTPClient()    urls = generate_urls(base_url, num_iter)G    responses = yield [http_client.fetch(url) for url in urls]    response_sum = sum(len(r.body) for r in responses)    raise gen.Return(value=response_sum)if __name__ == &quot;__main__&quot;:    import time    delay = 100    num_iter = 500    _ioloop = ioloop.IOLoop.instance()    run_func = partial(        run_experiment,        &quot;http://127.0.0.1:8080/add?name=tornado&amp;delay={}&amp;&quot;.format(delay),        num_iter)    start = time.time()    result = _ioloop.run_sync(run_func)    end = time.time()    print result, (end - start)</code></pre><p>最后一个是使用asyncio的示例，不过asyncio提供的api比较偏低层，我们使用aiphttp来发送http请求:</p><pre><code>#!/usr/bin/env python3import asyncioimport aiohttpimport randomimport stringdef generate_urls(base_url, num_urls):    for i in range(num_urls):        yield base_url + &quot;&quot;.join(random.sample(string.ascii_lowercase, 10))def chunked_http_client(num_chunks):    semaphore = asyncio.Semaphore(num_chunks)    @asyncio.coroutine    def http_get(url):        nonlocal semaphore        with (yield from semaphore):            response = yield from aiohttp.request(&apos;GET&apos;, url)            body = yield from response.content.read()            yield from response.wait_for_close()        return body    return http_getdef run_experiment(base_url, num_iter=500):    urls = generate_urls(base_url, num_iter)    http_client = chunked_http_client(100)    tasks = [http_client(url) for url in urls]    responses_sum = 0    for future in asyncio.as_completed(tasks):        data = yield from future        responses_sum += len(data)    return responses_sumif __name__ == &quot;__main__&quot;:    import time    loop = asyncio.get_event_loop()    delay = 100    num_iter = 500    start = time.time()    result = loop.run_until_complete(        run_experiment(            &quot;http://127.0.0.1:8080/add?name=asyncio&amp;delay={}&amp;&quot;.format(delay),            num_iter))    end = time.time()    print(&quot;{} {}&quot;.format(result, end - start))</code></pre><hr><h2 id="9章：The-Multiprocessing-Module"><a href="#9章：The-Multiprocessing-Module" class="headerlink" title="9章：The Multiprocessing Module"></a>9章：The Multiprocessing Module</h2><p>本章主要介绍多进程模块multiprocessing，它提供了以下几个主要的部分：</p><ul><li>Process: 当前进程的复刻(fork)</li><li>Pool: 封装了Process或者threading.Thread API到一个方便的工作池（进程池）</li><li>Queue: 支持多个生产者和消费者的队列</li><li>Pipe: 在两个进程之间单向或者双向通信的管道</li><li>Manager: 进程之间共享python对象的高级接口</li><li>ctypes: 允许在进程被forked后共享原始类型(integers, floats and bytes等)</li><li>Synchronization primitives: 同步原语,Locks或者semaphores</li></ul><p>python3.2以后引入了concurrent.futures模块，提供了更加简洁的api来操作进程或者线程，但是不如multiprocessing灵活一些。</p><pre><code># Monte Carlo方法来模拟pi的计算import mathimport randomimport timedef y_is_in_circle(x, y):    &quot;&quot;&quot;Test if x,y coordinate lives within the radius of the unit circle&quot;&quot;&quot;    circle_edge_y = math.sin(math.acos(x))    return y &lt;= circle_edge_ydef estimate_nbr_points_in_circle(nbr_samples):    nbr_in_circle = 0    for n in xrange(nbr_samples):        x = random.uniform(0.0, 1.0)        y = random.uniform(0.0, 1.0)        if y_is_in_circle(x, y):            nbr_in_circle += 1    return nbr_in_circlenbr_samples = int(1e7)t1 = time.time()nbr_in_circle = estimate_nbr_points_in_circle(nbr_samples)print &quot;Took {}s&quot;.format(time.time() - t1)pi_estimate = float(nbr_in_circle) / nbr_samples * 4print &quot;Estimated pi&quot;, pi_estimateprint &quot;Pi&quot;, math.piimport mathimport randomimport time#from multiprocessing.dummy import Poolfrom multiprocessing import Pooldef y_is_in_circle(x, y):    &quot;&quot;&quot;Test if x,y coordinate lives within the radius of the unit circle&quot;&quot;&quot;    circle_edge_y = math.sin(math.acos(x))    return y &lt;= circle_edge_ydef estimate_nbr_points_in_circle(nbr_samples):    nbr_in_circle = 0    for n in xrange(nbr_samples):        x = random.uniform(0.0, 1.0)        y = random.uniform(0.0, 1.0)        if y_is_in_circle(x, y):            nbr_in_circle += 1    return nbr_in_circlepool = Pool()nbr_samples = int(1e7)nbr_parallel_blocks = 4map_inputs = [nbr_samples] * nbr_parallel_blockst1 = time.time()results = pool.map(estimate_nbr_points_in_circle, map_inputs)# pool.close()print resultsprint &quot;Took {}s&quot;.format(time.time() - t1)nbr_in_circle = sum(results)combined_nbr_samples = sum(map_inputs)pi_estimate = float(nbr_in_circle) / combined_nbr_samples * 4print &quot;Estimated pi&quot;, pi_estimateprint &quot;Pi&quot;, math.pi</code></pre><hr><h2 id="10章：Clusters-and-Job-Queues"><a href="#10章：Clusters-and-Job-Queues" class="headerlink" title="10章：Clusters and Job Queues"></a>10章：Clusters and Job Queues</h2><p>本章介绍了python实现集群的几种方案，笔者并没有使用经验，不过等业务场景需要的时候可以再去深入调研，现在就先了解一下。上一章讨论了多进程只能利用一台计算机的资源，如果有多台计算机就需要用到集群方案，下边是本章介绍的三个方案：</p><ul><li>Parallel Python Module: for simple local clusters</li><li>IPython Parallel: support research</li><li>NSQ: for robust production clustering</li></ul><p>其他集群工具:</p><ul><li>Celery: 一个广泛使用的异步消息队列。</li><li>Gearman： 支持多个平台的任务处理系统</li><li>PyRes：python和redis实现的轻量级任务管理器</li><li>Amazon’s Simple Queue Service(SQS): 亚马逊云服务提供的任务处理系统</li></ul><hr><h2 id="11章：Using-Less-RAM"><a href="#11章：Using-Less-RAM" class="headerlink" title="11章：Using Less RAM"></a>11章：Using Less RAM</h2><p>本章介绍的一些技术帮助我们减少内存使用：</p><ul><li>分块加载，如使用 memory-mapped file</li><li>使用array模块相比list存储原生类型（integers, floats, characters等，not complex numbers or classses）能节省很多内存使用，或者使用numpy的array</li><li>使用memit(ipython)，memory_profiler衡量内存使用, 内置的sys.getsizeof对于容器类型的计算不准确</li><li>python2里的unicode对象比较耗费内存，在python3中没有这个问题</li><li>如果需要存储大量字符串到内存：使用DAWG(Directed asyclic word graph)和trie(Marisa trie,Datrie,HAT trie)等结构比存储到list或者set里节省大量内存，DAWG等结构通过公用字符串前缀或后缀节省存储，github上有相应实现。</li><li>嵌入式系统可以用”Micro Python”, <a href="http://micropython.org" target="_blank" rel="noopener">http://micropython.org</a></li></ul><p>Probabilistic Data Structures:如果允许一定概率的精度损失，我们可以使用一些概率数据结构</p><ul><li>Morris Counter: 仅使用一个字节完成近似计数</li><li>K-minimum Values: 只用很少内存完成集合操作</li><li>Bloom Filters: 固定内存完成判重操作，比如写爬虫的时候有海量url需要判重，就可以使用Bloom Filters节省内存</li><li>LogLog Counter: 限定内存计数</li></ul><hr><h2 id="12章：Lessons-from-the-Field"><a href="#12章：Lessons-from-the-Field" class="headerlink" title="12章：Lessons from the Field"></a>12章：Lessons from the Field</h2><p>本章汇集了一些公司使用python的成功案例和经验，其实看看Instagram的技术博客有不少干货</p><pre><code>- lyst.com(fashion recommendation engine):django/Amazon EC2/Redis/PyRes/supervisord/Elasticsearch/Graphite/Sentry/Jenkins/Cython/numpy/scipy/- sme.sh(social media analytics):django/flask/pyramid/celery/Boto/PyMongo/MongoEngine/redis-py/Pyscopy/Graphite/Sentry/docker/- adaptivelab.com(social media analytics): Elasticsearch/Celery/redis/Mozilla&apos;s Circus(替代crontab)/SaltStack/Fabric/Vagrant/敏捷/Amazon&apos;s Elastic Compute Cloud(EC2)/- radimrehurek.com(Deep Learning): Stream your data, watch your memory./ Take advantage of Python&apos;s rich ecosystem. / Profile and compile hotspots./ Parallelization and multiple cores. /Static memory allocations. / Problem-specific optimizations.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Optimization hinders evolution. - Alan Perlis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近扫了一本《High Performance Python》，该书从多个角度比如性能度量(profile)，内置数据结构调优，并发，多进程，多线程，使用C加速，异步，分布式，内存调优，其他网站使用经验等介绍了python优化经验，看得出几位作者的计算机体系结构和python功底很深。笔者非计算机科班出身，有些知识点超出了我的能力范围，不过多了解一些东西对于以后技术调研和选型还是很有帮助的，简要记录下涉及到的一些东西。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《刻意练习》</title>
    <link href="http://ningning.today/2017/01/28/psychology/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/"/>
    <id>http://ningning.today/2017/01/28/psychology/刻意练习/</id>
    <published>2017-01-28T02:18:25.000Z</published>
    <updated>2017-05-07T06:11:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看一场，教一场，做一场。    -外科手术先驱 William Halsted</p></blockquote><p>其实我觉得刻意练习挺适合编程领域的，一直很好奇那些编程领域的牛人们是如何思维的，不过一直没多少机会接触。用一定的方法练习虽然成不了牛人，但是至少能做到一个合格的工程师。我觉得这本书最好的思想就是让我们用一种『成长性』思维看待问题，不断用合适的方法磨练专业技能。</p><a id="more"></a><hr><h2 id="1章-有目的的练习"><a href="#1章-有目的的练习" class="headerlink" title="1章 有目的的练习"></a>1章 有目的的练习</h2><p>任何行业或领域中，最有效和强大的那类练习，都通过充分利用身体与大脑的适应能力，来逐步塑造和提升他们的技能，以做到一些过去不可能的事情。</p><ul><li>天真的练习：反复做某件事，并指望只靠那种反复，就能提高表现水平</li></ul><p>有目的的练习的四个特点：</p><ul><li>具有明确定义的特定目标</li><li>专注，注意力集中在你的任务上</li><li>有目的的联系包含反馈：通过反馈来准确辨别你在哪些方面还有不足，以及为什么会存在这些不足</li><li>需要走出舒适区</li></ul><p>遇到瓶颈怎么办？</p><ul><li>试着做不同的事情，而不是更难的事情</li></ul><p>并非达到极限，而是动机不足。有意义的正面反馈是保持动机的关键要素之一。<br>简单总结:走出你的舒适区，但要以专注的方式制定明确的目标，为达到目标制定一个计划，并且想出监测你进步的方法。还要想办法保持你的动机。</p><p>有目的的练习还不够，改变心理结构。</p><hr><h2 id="2章-大脑的适应能力"><a href="#2章-大脑的适应能力" class="headerlink" title="2章 大脑的适应能力"></a>2章 大脑的适应能力</h2><p>大脑的结构与运行都会为了应对各种不同的心理训练而改变。<br>我们到底在试图提升大脑的什么？</p><hr><h2 id="3章-心理表征"><a href="#3章-心理表征" class="headerlink" title="3章 心理表征"></a>3章 心理表征</h2><p>心理表征：一种与我们大脑正在思考的某个物体、某个观点、某些信息、或者其他任何事物相对因的心理结构，或具体或抽象。<br>刻意练习包括创建更加有效的心理表征，杰出人物和其他人区别开来的因素，正是前者心理表征质量和数量。他们经过一年又一年的练习，已经改变了大脑中的神经回路，以创建高度专业化的心理表征，这些心理表征<br>反过来使得令人难以置信的记忆、规律的识别、问题的解决等成为可能，也使得他们能够培养和发展各种高级的能力，以便在特定的专业领域表现卓越。</p><p>无意识决策<br>出色的信息组织</p><hr><h2 id="4章-黄金标准"><a href="#4章-黄金标准" class="headerlink" title="4章 黄金标准"></a>4章 黄金标准</h2><p>刻意练习的特点：</p><ul><li>拥有一整套行之有效的训练方法的技能。有导师或者教练设计和监管，他们既熟悉杰出人物的能力，也熟悉怎样才能最好地提高那种能力。</li><li>发生在人们的舒适区之外，要求学生持续不断地尝试那些刚好超出他当前能力范围的事。</li><li>包含良好定义的特定目标，实现一系列微小的改变。</li><li>有意而为，完全的关注和有意识的行动。学生必须紧跟他的练习的特定的目标，以便能够做出适当调整，控制练习。</li><li>刻意练习包含反馈，以及为应对那些反馈而进行调整的努力。自我检测，需要高效的心理表征。</li><li>刻意练习既产生有效的心理表征，又依靠有效的心理表征。</li><li>着重关注过去获取的技能的某些特定方面，致力于有针对性地提高那些方面，并且几乎总是包含构建或修改那些过去已经获取的技能。随着时间的推移，<br>逐步的改进最终将造就卓越的表现。新技能的学习是建立在现有技能基础之上的，导师为初学提供正确的基本技能，使学生后来能在更高层面上学习那些基本的技能。</li></ul><p>步骤：</p><ul><li>确定谁是杰出人物。推测出什么使得他们变得如此杰出，接着再提出训练方法，这些方法使你也能像他们那样表现卓越。</li><li>找出杰出人物和其他人的差别。模仿他们所用的方法，管用就继续，不管用马上停下来。</li><li>最佳方法是找到优秀导师。优秀的导师可以为你提供宝贵的反馈，提出建议。</li></ul><hr><h2 id="5章-在工作中运用刻意练习原则"><a href="#5章-在工作中运用刻意练习原则" class="headerlink" title="5章 在工作中运用刻意练习原则"></a>5章 在工作中运用刻意练习原则</h2><ul><li>让练习变成日常工作的一部分。</li></ul><p>三种错误思想:</p><ul><li>认为某人的能力通常受到基因特征的限制。人人可以通过正确的训练大幅提高，我们可以塑造自己的潜力。</li><li>第二种错误思想认为，如果你足够长时间做某件事，一定会擅长。</li><li>第三种错误思想认为，要想提高，只需要努力。除非你运用一些专门用来提升那些特定技能的练习方法，否则即使加倍努力，也无法让你有很大进步。</li></ul><p>知识与技能之间的区别，正是发展专业技能的传统路径与刻意练习方法之间的核心差别。大部分在职业领域和商业世界中的训练都不重视技能，过于重视知识。主要的原因是传统和方便：向一大群人介绍知识，比起创造条件让人们可以通过练习来提升技能，要容易得多。</p><p>知识与技能对抗中的终极信仰告白。人们一般认为，如果掌握了知识，也就能相对容易地熟练掌握技能。结果，当大学生进入职场时，通常发现自己需要大量的时间来提升工作中需要的技能。</p><p>制定致力于改进技能的培训计划，这些计划将补充或者完全替代那些致力于传授知识的、在如今很多行业和领域中经常使用的方法。</p><ul><li>辨别谁是杰出的人</li><li>及时反馈的重要性，通过纠正错误和精进技巧精益求精</li><li>杰出的表现背后到底隐藏着什么</li></ul><hr><h2 id="6章-在生活中运用刻意练习原则"><a href="#6章-在生活中运用刻意练习原则" class="headerlink" title="6章 在生活中运用刻意练习原则"></a>6章 在生活中运用刻意练习原则</h2><ul><li>首先，找一位好导师并向他请教。不停地向前，向前</li><li>专注和投入至关重要，制定提高与进步的清晰目标</li><li>更短的练习，更好的注意力，在较短时间内专注比起在长时间内只投入70%的努力来练习，效果更好。保证睡眠以便最大限度集中精力练习。</li><li><p>没有导师，自己设计练习方法。有目的练习或者说刻意练习，其标志是你努力去做一些你无法做到的事情，去完成一些处在你舒适区以外的任务，而且你一而再再而三地联系，着重关注到底可以怎么做好它，哪些方面还有缺陷，以及你怎样可以进步。毫无目的地一遍又一遍做同一件事情，并不是好办法，反复做一件事情，目的是找出你在那些方面存在不足，并且聚焦在那些方面取得进步，试着采用不同的方法来提高，直到你最终找出适合自己的方法。</p></li><li><p>没有导师？自我训练：用三个F来创建有效的心理表征：专注（focus），反馈（feedback），纠正（fix it）。将技能分解成一些组成部分，一边反复练习，并且有效分析、确定你的不足之处，然后想出各种办法来解决他们。</p></li><li>跨越停滞阶段:以新的方式挑战你的大脑或身体，主动变换训练模式</li><li>攻克特定的弱点：稍微逼一下你自己，不要逼太狠，只要使自己稍稍超出正常状态便可以，这通常会帮助你搞清楚自己的停滞点在什么地方？首先搞清楚是什么让你停滞不前，你犯了写什么错？什么时候犯错的？逼自己走出舒适区，看看是什么拦住你前进的路？其次，设计一种练习方法，专门来改进那个特定的弱点。一旦你弄请问题是什么，你也许能够纠正。或者可以向经验丰富的教练或导师寻求建议。练习的时候要重点关注发生了什么；如果依然没有进步，那就需要再试试其他方法。</li><li>保持动机，如何保持投入？</li><li>新年决心效应：有目的的练习是一项艰巨的任务，难以坚持，你可以做什么来改变呢？</li><li>意志力根本不存在:没有证据表明世间存在一种任何情形中运用的一般『意志力』,也没有证据表明大师级人物有取得成功必备的基因。</li><li>保持动机的两个组成部分(强化继续前行的理由，弱化停下脚步的理由)。动机与意志力是两码事。那些长期保持有目的训练或刻意练习的人们，他们通常培养了各种习惯，帮助自己继续前行。所以希望提高在某一行业或领域中的技能水平的人，应当每天花一个小时或者更多的时间，专心练习那些需要全神贯注才能做好的事情。</li><li>弱化停下脚步的理由：留出固定时间来练习，不要受其他义务或者分心的事情干扰，远离干扰。两件有益处的事情：身体保养（充足的睡眠并保持健康）；将练习的时间限制在一个小时左右，人无法保持长时间的专注（番茄工作法）</li><li>增强继续前行的倾向：专心提高自己的技能，那么进一步的练习给你的感觉更像是一种投资，而不是一种代价。相信自己可以成功（内在动机）。外部动机（外部的认可与崇拜），让周围的人支持你，找到和你有相似目标的团队。</li><li>精心设置目标，以便你能持续不断地看到进步的实质性信号，尽管并不总是会出现重大的进步。将漫长的旅程分解成一系列可控的目标，并且每次只关心它们中的一个，甚至可以在每次达到一个目标时，给自己的小小的奖励。大胆去尝试。</li></ul><hr><h2 id="7章-成为杰出人物路线图"><a href="#7章-成为杰出人物路线图" class="headerlink" title="7章 成为杰出人物路线图"></a>7章 成为杰出人物路线图</h2><ul><li>一阶段：产生兴趣。杰出人物成长三阶段：第一个阶段，大人以一种好玩的方式向孩子介绍他们最终从事的领域或行业。父母给孩子大量时间，关注和鼓励。父母往往会以成就为导向，并教孩子一些重要的价值观。比如自律、刻苦，负责任，以及建设性地运用时间。一旦孩子对某个领域感兴趣了，他有望以同样的态度来追求成功，如自律、刻苦、成就等。杰出人物往往遵循一般规律，到了他们成长过程中的某个时刻，他们对某一个特定领域的行业格外感兴趣，并且表现地比其他同龄孩子更有希望成就一番事业。</li><li>第二阶段：变得认真。</li><li>第三阶段：全力投入。动机完全靠学生自己保持，家人依然能发挥重要的支持作用。年龄与适应能力的关系：身体适应能力受年龄的影响大。心理适应能力比身体更强。成年人和未成年人的学习通过少有不同的机制发生。</li><li>第四极端：开拓创新。创新的过程总是一个漫长、缓慢、反复的过程。</li></ul><hr><h2 id="8章-怎样解释天生才华"><a href="#8章-怎样解释天生才华" class="headerlink" title="8章 怎样解释天生才华"></a>8章 怎样解释天生才华</h2><p>这种能力的特点是什么？<br>什么样的训练使那些能力成为可能<br>天才的背后是练习（与人们口耳相传的不同）<br>自闭症奇才：他们更注重细节，而且更倾向于反复的行为，更有可能在某些方面培养和发展技能。<br>相信天生才华具有危险性，它往往使人们假设，有些人生来就具有某些方面的天赋，而另一些人不具备，而你可以很早就分辨他们之间的这些差别。如果你相信这种观点，那么，你就是在鼓励和支持『有天赋』的那些人，并打击其他的人，从而制造自我实现的预言（指我们对待他人的方式会影响到他们的行为，并最终影响到他们对自己的评价）。最好的办法是意识到我们每个人都有自己的潜力，并努力想办法去开发这些潜力。</p><hr><h2 id="9章-用刻意练习创造全新的世界"><a href="#9章-用刻意练习创造全新的世界" class="headerlink" title="9章 用刻意练习创造全新的世界"></a>9章 用刻意练习创造全新的世界</h2><p>物理教学：先以正确方式理解问题，然后想出可以运用哪些概念，接着再从那些概念推断出答案。<br>改变教育与学习：一般而言，几乎在每一个教育领域，最有益的学习目标是那些帮助学生创建有效心理表征的目标，而不是简单把数字嵌入到公式中。<br>成为练习人：我们可以有意识地改造自己，以我们选择的方式来提高自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看一场，教一场，做一场。    -外科手术先驱 William Halsted&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实我觉得刻意练习挺适合编程领域的，一直很好奇那些编程领域的牛人们是如何思维的，不过一直没多少机会接触。用一定的方法练习虽然成不了牛人，但是至少能做到一个合格的工程师。我觉得这本书最好的思想就是让我们用一种『成长性』思维看待问题，不断用合适的方法磨练专业技能。&lt;/p&gt;
    
    </summary>
    
      <category term="psychology" scheme="http://ningning.today/categories/psychology/"/>
    
    
      <category term="思维" scheme="http://ningning.today/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用python编写vim插件</title>
    <link href="http://ningning.today/2017/01/26/python/use-python-write-vim-plugin/"/>
    <id>http://ningning.today/2017/01/26/python/use-python-write-vim-plugin/</id>
    <published>2017-01-26T15:05:19.000Z</published>
    <updated>2017-01-26T15:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Use a single editor well. The editor should be an extension of your hand; make sure your editor is configurable, extensible, and programmable. - Andrew Hunt</p></blockquote><p>平常总是用那些大神们写的vim插件，今天闲来无事学写了一下vim插件，顺便写一个简单的教程。<br>先来看下我一个旺盛的<strong>需求</strong>：平常总会遇到分享本机或者服务器代码的情况，我经常使用<a href="http://paste.ubuntu.com/" target="_blank" rel="noopener">paste.ubuntu.com</a>网站粘贴代码(我记性不好总是忘记scp咋使的)，然后把链接分享给别人。类似github的gist服务，不过比较简单，而且gist国内用户访问有时候会出现奇奇怪怪的问题，所以一般我用ubuntu的pastebin多一些。但是步骤麻烦点，我写这个插件就是要一个命令帮我完成在vim里直接贴代码到paste.ubuntu.com的功能。</p><a id="more"></a><p>步骤如下:<br>看了一个youtube视频讲怎么用python写vim插件的，笔者以前的经验只限于使用vim，并不会vim脚本。现学现卖，同想写插件的可以看看，即使不用深入理解，照葫芦画瓢也不难。简单的插件从学习到实现大概只会花你半天到一天左右的时间，以后你就可以定制你的vim编辑器了。<br><a href="https://www.youtube.com/watch?v=vMAeYp8mX_M" target="_blank" rel="noopener">Writing Vim plugins with Python</a></p><hr><h2 id="让vim支持python函数"><a href="#让vim支持python函数" class="headerlink" title="让vim支持python函数"></a>让vim支持python函数</h2><p>首先确认你的vim编译时支持python或者python3，用<code>vim --version | grep +python</code>查看输出，否则你可能要重新编译安装vim。 笔者之前没有写过vim脚本，由于对python比较熟悉，现在用python实现。这里举个简单的例子，vim example.vim</p><pre><code>function! HelloVim()    echo &quot;Hello Vim&quot;endfunction</code></pre><p>然后在vim里执行 <code>:source %</code>，之后在 <code>:call HelloVim()</code> 就能看到函数执行结果了。</p><p>怎么在vim脚本里使用python函数呢？这里有个简单的文档 <a href="http://vimdoc.sourceforge.net/htmldoc/if_pyth.html" target="_blank" rel="noopener">Vim documentation: if_pyth</a><br>来用python实现一个类似的Hello函数</p><pre><code>&quot; vim sript functionfunction! HelloVim()    echo &quot;Hello Vim&quot;endfunction&quot; use python function, vim compiled with +python or +python3function! HelloPython()python3 &lt;&lt; endOfPythonprint(&apos;Hello Python&apos;)endOfPythonendfunction</code></pre><p>我的vim使用+python3编译的，你可能需要把上边的python3换成python。然后在vim里执行 <code>:source %</code>，之后在 <code>:call HelloVim()</code> 就能看到函数执行结果了。</p><hr><h2 id="vim插件的目录结构"><a href="#vim插件的目录结构" class="headerlink" title="vim插件的目录结构"></a>vim插件的目录结构</h2><p>我们直接偷懒使用项目生成框架starter kit(就和我直接偷懒用flask-cookitecutter一样)，项目仓库在这里<a href="https://github.com/JarrodCTaylor/vim-plugin-starter-kit" target="_blank" rel="noopener">vim-plugin-starter-kit</a> 如果你有兴趣也可以看看这个项目的wiki，有一些教程。 直接克隆项目，进入文件夹以后执行python create_plugin_scaffold.py然后填写一下项目名称就好了，直接帮助你生成一个项目模板。我的项目树如下:</p><pre><code>vim-ubuntu-pastebin├── README.md├── doc│   └── vim-ubuntu-pastebin.txt└── plugin    ├── __init__.py    ├── test.txt    ├── tests    │   ├── __init__.py    │   └── vim_ubuntu_pastebin_tests.py    ├── vim_ubuntu_pastebin.py    └── vim_ubuntu_pastebin.vim</code></pre><hr><h2 id="编写简单的vim插件"><a href="#编写简单的vim插件" class="headerlink" title="编写简单的vim插件"></a>编写简单的vim插件</h2><p>我的需求有两个，一个是把当前的文本发送到 paste.ubuntu.com ，还有一个是把该功能集成到vim里。第一个功能我们使用python完成，功能也比较简单。我们去网站上随便粘贴一段文本用浏览器开发者工具观察发送的post请求就好了，之后用requests模拟提交（也可以用python内置的urllib，不过这里还要兼容python2和python3，所以直接用requests方便很多），编辑vim_ubuntu_pastebin_tests.py文件如下:</p><pre><code># -*- coding: utf-8 -*-import osimport requestsimport webbrowsertry:    from urllib import urlencode    # py2except ImportError:    from urllib.parse import urlencode   # py3PASTEBIN_SUPPORT_TYPE = frozenset([    &apos;text&apos;, &apos;Cucumber&apos;, &apos;abap&apos;, &apos;ada&apos;, &apos;ahk&apos;, &apos;antlr&apos;, &apos;antlr-as&apos;, &apos;antlr-cpp&apos;, &apos;antlr-csharp&apos;, &apos;antlr-java&apos;, &apos;antlr-objc&apos;, &apos;antlr-perl&apos;, &apos;antlr-python&apos;, &apos;antlr-ruby&apos;, &apos;apacheconf&apos;, &apos;applescript&apos;, &apos;as&apos;, &apos;as3&apos;, &apos;aspx-cs&apos;, &apos;aspx-vb&apos;, &apos;asy&apos;, &apos;basemake&apos;, &apos;bash&apos;, &apos;bat&apos;, &apos;bbcode&apos;, &apos;befunge&apos;, &apos;blitzmax&apos;, &apos;boo&apos;, &apos;c&apos;, &apos;c-objdump&apos;, &apos;cfm&apos;, &apos;cfs&apos;, &apos;cheetah&apos;, &apos;clojure&apos;, &apos;cmake&apos;, &apos;coffee-script&apos;, &apos;common-lisp&apos;, &apos;console&apos;, &apos;control&apos;, &apos;cpp&apos;, &apos;cpp-objdump&apos;, &apos;csharp&apos;, &apos;css&apos;, &apos;css+django&apos;, &apos;css+erb&apos;, &apos;css+genshitext&apos;, &apos;css+mako&apos;, &apos;css+myghty&apos;, &apos;css+php&apos;, &apos;css+smarty&apos;, &apos;cython&apos;, &apos;d&apos;, &apos;d-objdump&apos;, &apos;delphi&apos;, &apos;diff&apos;, &apos;django&apos;, &apos;dpatch&apos;, &apos;duel&apos;, &apos;dylan&apos;, &apos;erb&apos;, &apos;erl&apos;, &apos;erlang&apos;, &apos;evoque&apos;, &apos;factor&apos;, &apos;felix&apos;, &apos;fortran&apos;, &apos;gas&apos;, &apos;genshi&apos;, &apos;genshitext&apos;, &apos;glsl&apos;, &apos;gnuplot&apos;, &apos;go&apos;, &apos;gooddata-cl&apos;, &apos;groff&apos;, &apos;haml&apos;, &apos;haskell&apos;, &apos;html&apos;, &apos;html+cheetah&apos;, &apos;html+django&apos;, &apos;html+evoque&apos;, &apos;html+genshi&apos;, &apos;html+mako&apos;, &apos;html+myghty&apos;, &apos;html+php&apos;, &apos;html+smarty&apos;, &apos;html+velocity&apos;, &apos;hx&apos;, &apos;hybris&apos;, &apos;ini&apos;, &apos;io&apos;, &apos;ioke&apos;, &apos;irc&apos;, &apos;jade&apos;, &apos;java&apos;, &apos;js&apos;, &apos;js+cheetah&apos;, &apos;js+django&apos;, &apos;js+erb&apos;, &apos;js+genshitext&apos;, &apos;js+mako&apos;, &apos;js+myghty&apos;, &apos;js+php&apos;, &apos;js+smarty&apos;, &apos;jsp&apos;, &apos;lhs&apos;, &apos;lighty&apos;, &apos;llvm&apos;, &apos;logtalk&apos;, &apos;lua&apos;, &apos;make&apos;, &apos;mako&apos;, &apos;maql&apos;, &apos;mason&apos;, &apos;matlab&apos;, &apos;matlabsession&apos;, &apos;minid&apos;, &apos;modelica&apos;, &apos;modula2&apos;, &apos;moocode&apos;, &apos;mupad&apos;, &apos;mxml&apos;, &apos;myghty&apos;, &apos;mysql&apos;, &apos;nasm&apos;, &apos;newspeak&apos;, &apos;nginx&apos;, &apos;numpy&apos;, &apos;objdump&apos;, &apos;objective-c&apos;, &apos;objective-j&apos;, &apos;ocaml&apos;, &apos;ooc&apos;, &apos;perl&apos;, &apos;php&apos;, &apos;postscript&apos;, &apos;pot&apos;, &apos;pov&apos;, &apos;prolog&apos;, &apos;properties&apos;, &apos;protobuf&apos;, &apos;py3tb&apos;, &apos;pycon&apos;, &apos;pytb&apos;, &apos;python&apos;, &apos;python3&apos;, &apos;ragel&apos;, &apos;ragel-c&apos;, &apos;ragel-cpp&apos;, &apos;ragel-d&apos;, &apos;ragel-em&apos;, &apos;ragel-java&apos;, &apos;ragel-objc&apos;, &apos;ragel-ruby&apos;, &apos;raw&apos;, &apos;rb&apos;, &apos;rbcon&apos;, &apos;rconsole&apos;, &apos;rebol&apos;, &apos;redcode&apos;, &apos;rhtml&apos;, &apos;rst&apos;, &apos;sass&apos;, &apos;scala&apos;, &apos;scaml&apos;, &apos;scheme&apos;, &apos;scss&apos;, &apos;smalltalk&apos;, &apos;smarty&apos;, &apos;sourceslist&apos;, &apos;splus&apos;, &apos;sql&apos;, &apos;sqlite3&apos;, &apos;squidconf&apos;, &apos;ssp&apos;, &apos;tcl&apos;, &apos;tcsh&apos;, &apos;tex&apos;, &apos;text&apos;, &apos;trac-wiki&apos;, &apos;v&apos;, &apos;vala&apos;, &apos;vb.net&apos;, &apos;velocity&apos;, &apos;vim&apos;, &apos;xml&apos;, &apos;xml+cheetah&apos;, &apos;xml+django&apos;, &apos;xml+erb&apos;, &apos;xml+evoque&apos;, &apos;xml+mako&apos;, &apos;xml+myghty&apos;, &apos;xml+php&apos;, &apos;xml+smarty&apos;, &apos;xml+velocity&apos;, &apos;xquery&apos;, &apos;xslt&apos;, &apos;yaml&apos;, ])def post_buffer_to_ubuntu_pastebin(buffer, filetype, open_in_borwser=True):    &quot;&quot;&quot; post current file buffer content to http://paste.ubuntu.com/    and return url.    Args:        buffer (vim.current.buffer)        filetype (str)    Returns:        url (str)    &quot;&quot;&quot;    lines = os.linesep.join(list(buffer))    url = &apos;http://paste.ubuntu.com/&apos;    data = urlencode(        {            &apos;poster&apos;: os.environ.get(&apos;USER&apos;, &apos;anonymous&apos;),            &apos;syntax&apos;: filetype if filetype in PASTEBIN_SUPPORT_TYPE else &apos;text&apos;,            &apos;content&apos;: lines        }    ).encode(&apos;utf-8&apos;)    r = requests.post(url, data=data, allow_redirects=True)    if open_in_borwser:        webbrowser.open_new_tab(r.url)    return r.url</code></pre><p>这样发送文本内容到 paste.ubuntu.com 的需求就完成了，还差一步就是怎么在vim里能够使用这段python代码。接下来编辑 vim_ubuntu_pastebin.vim文件，看着也挺简单:</p><pre><code>&quot; --------------------------------&quot; Add our plugin to the path&quot; --------------------------------if !(has(&apos;python3&apos;) || has(&apos;python&apos;))    echo &quot;Error: Required vim compiled with +python or +python3&quot;    finishendifif has(&apos;python3&apos;)python3 import syspython3 import vimpython3 sys.path.append(vim.eval(&apos;expand(&quot;&lt;sfile&gt;:h&quot;)&apos;))function! Pastebin()python3 &lt;&lt; endOfPythonfrom vim_ubuntu_pastebin import post_buffer_to_ubuntu_pastebinfiletype = vim.eval(&apos;&amp;filetype&apos;)    &quot; 获取文件类型url = post_buffer_to_ubuntu_pastebin(vim.current.buffer, filetype)print(url)endOfPythonendfunctionendif&quot; 下边代码仅仅是&apos;python3&apos;替换成了&apos;python&apos;if has(&apos;python&apos;)python import syspython import vimpython sys.path.append(vim.eval(&apos;expand(&quot;&lt;sfile&gt;:h&quot;)&apos;))function! Pastebin()python &lt;&lt; endOfPythonfrom vim_ubuntu_pastebin import post_buffer_to_ubuntu_pastebinfiletype = vim.eval(&apos;&amp;filetype&apos;)url = post_buffer_to_ubuntu_pastebin(vim.current.buffer, filetype)print(url)endOfPythonendfunctionendif&quot; 定义一个命令Pastebin就可以在终端command! -nargs=0 Pastebin call Pastebin()</code></pre><p>我们直接在这个vim脚本里调用上边的python函数就可以了，使用list(vim.current.buffer)就能获取当前buffer里每行的内容，用换行符拼起来，之后把内容发送出去就好了。这样就实现了一个简单的vim插件了，是不是挺容易的。把当前项目推到github上，别人就可以使用Bundle等工具使用你的插件了。亲测有效，以后贴代码方便多了，在你的vim里头执行命令 <code>:Pastebin</code> 当前文件就自动贴到 paste.ubuntu.com 上并且输出url了，如果是桌面版操作系统还会自动帮你打开页面。</p><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://github.com/PegasusWang/vim-ubuntu-pastebin" target="_blank" rel="noopener">vim-ubuntu-pastebin</a> - 上边小项目的代码<br><a href="http://vimdoc.sourceforge.net/htmldoc/if_pyth.html" target="_blank" rel="noopener">Vim documentation: if_pyth</a> - 你需要看一下python操作vim buffer的接口</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Use a single editor well. The editor should be an extension of your hand; make sure your editor is configurable, extensible, and programmable. - Andrew Hunt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平常总是用那些大神们写的vim插件，今天闲来无事学写了一下vim插件，顺便写一个简单的教程。&lt;br&gt;先来看下我一个旺盛的&lt;strong&gt;需求&lt;/strong&gt;：平常总会遇到分享本机或者服务器代码的情况，我经常使用&lt;a href=&quot;http://paste.ubuntu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;paste.ubuntu.com&lt;/a&gt;网站粘贴代码(我记性不好总是忘记scp咋使的)，然后把链接分享给别人。类似github的gist服务，不过比较简单，而且gist国内用户访问有时候会出现奇奇怪怪的问题，所以一般我用ubuntu的pastebin多一些。但是步骤麻烦点，我写这个插件就是要一个命令帮我完成在vim里直接贴代码到paste.ubuntu.com的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://ningning.today/categories/python/"/>
    
    
      <category term="vim, python" scheme="http://ningning.today/tags/vim-python/"/>
    
  </entry>
  
  <entry>
    <title>『简单』的python元类</title>
    <link href="http://ningning.today/2017/01/25/python/simple-python-metaclass/"/>
    <id>http://ningning.today/2017/01/25/python/simple-python-metaclass/</id>
    <published>2017-01-25T00:44:48.000Z</published>
    <updated>2017-05-14T14:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Metaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why). - Tim Peters</p></blockquote><p>平常都是写业务逻辑，从来没有使用过元类这种黑魔法（好吧，目前的编码规范是不推荐在业务逻辑当中使用元类的，不好维护并且一般来说并无这个必要）。不过貌似只有造轮子的时候才会用到，就像上边的引用里说的，当你不知道为什么要使用元类时，你是没必要使用它的,大部分时间python灵活的特性已经可以应付几乎所有业务问题。最近重新看了下元类，突然有了一种霍然开朗的感觉，用几个简单的例子介绍一些元类(使用python3.5)。</p><a id="more"></a><hr><h2 id="什么是元类？"><a href="#什么是元类？" class="headerlink" title="什么是元类？"></a>什么是元类？</h2><p>元类是创建类的类。这么说很绕口。 在python中，一切皆对象，类也不例外。 当我们用class关键字定义类的时候，python实际上会执行它然后生成一个对象。既然是对象，就可以进行赋值，拷贝，添加属性，作为函数参数等。使用元类允许我们控制类的生成，比如修改类的属性，检查属性的合法性等。</p><pre><code>class MyClass:    # python2中新式类要显示继承object    pass</code></pre><p><img src="https://i.stack.imgur.com/QQ0OK.png" alt="metaclass"></p><hr><h2 id="类的创建方式"><a href="#类的创建方式" class="headerlink" title="类的创建方式"></a>类的创建方式</h2><p>在Python中，有两种创建类的方式，一种是平常我们使用的使用class关键字创建类:</p><pre><code>class MyClass:    # python2中新式类要显示继承object    pass</code></pre><p>还有一种方式是使用type函数创建，type的描述如下，平常我们一般使用type查看对象的类型，实际上type还有一个重要的功能就是创建类</p><pre><code>Docstring:type(object_or_name, bases, dict)type(object) -&gt; the object&apos;s typetype(name, bases, dict) -&gt; a new type</code></pre><p>上边MyClass的定义用type创建可以这么写: <code>MyClass = type(&#39;Myclass&#39;, (), {})</code></p><p>对于有继承关系和属性的类来说，可以使用如下等价定义:</p><pre><code># 加上继承class Base:    passclass Child(Base):    pass# 等价定义Child = type(&apos;Child&apos;, (Base,), {})      # 注意Base后要加上逗号否则就不是tuple了# 加上属性class ChildWithAttr(Base):    bar = True# 等价定义ChildWithAttr = type(&apos;ChildWithAttr&apos;, (Base,), {&apos;bar&apos;: True})# 加上方法class ChildWithMethod(Base):    bar = True    def hello(self):        print(&apos;hello&apos;)def hello(self):    print(&apos;hello&apos;)# 等价定义ChildWithMethod = type(&apos;ChildWithMethod&apos;, (Base,), {&apos;bar&apos;: True, &apos;hello&apos;: hello})</code></pre><p>看懂了上边的等价定义对于理解元类的创建很重要。</p><h2 id="创建一个元类"><a href="#创建一个元类" class="headerlink" title="创建一个元类"></a>创建一个元类</h2><p>什么时候需要创建元类呢？当我想控制类的创建，比如校验或者修改类的属性的时候，就可以使用元类。元类通过继承type实现，在python2和python3中略有不同</p><pre><code>class Meta(type):    pass# python2class Base(object):    __metaclass__ = Meta# python3class Base(metaclass=Meta):    pass# 如果写兼容2和3的代码可以使用six模块from six import with_metaclassclass Meta(type):    passclass Base(metaclass=Meta):    passclass MyClass(with_metaclass(Meta, Base)):    pass</code></pre><p>我们使用几个很简单的例子来演示元类的创建，第一个例子我们实现一个修改类的属性名为小写的元类:</p><pre><code>class LowercaseMeta(type):    &quot;&quot;&quot; 修改类的属性名称为小写的元类 &quot;&quot;&quot;    def __new__(mcs, name, bases, attrs):        lower_attrs = {}        for k, v in attrs.items():            if not k.startswith(&apos;__&apos;):    # 排除magic method                lower_attrs[k.lower()] = v            else:                lower_attrs[k] = v        return type.__new__(mcs, name, bases, lower_attrs)class LowercaseClass(metaclass=LowercaseMeta):    BAR = True    def HELLO(self):        print(&apos;hello&apos;)print(dir(LowercaseClass))    # 你会发现&quot;BAR&quot;和&quot;HELLO&quot;都变成了小写LowercaseClass().hello()    # 用一个类的实例调用hello方法，神奇的地方就是这里，我们修改了类定义时候的属性名!!!</code></pre><p>第二个例子是给类添加一个add属性，比如我经常手误使用list.add而不是写list.append方法:</p><pre><code>class ListMeta(type):    &quot;&quot;&quot; 用元类实现给类添加属性 &quot;&quot;&quot;    def __new__(mcs, name, bases, attrs):        attrs[&apos;add&apos;] = lambda self, value: self.append(value)        return type.__new__(mcs, name, bases, attrs)class MyList(list, metaclass=ListMeta):    passl = MyList()l.add(1)print(l)# 但实际上给类动态添加属性用类装饰器反而更简单def class_decorator(cls):    cls.add = lambda self, value: self.append(value)    return cls@class_decoratorclass MyList(list):    passl = MyList()l.append(1)print(l)</code></pre><hr><h2 id="元类的-new-和-init"><a href="#元类的-new-和-init" class="headerlink" title="元类的__new__和__init__"></a>元类的<code>__new__</code>和<code>__init__</code></h2><p>一般在python里<code>__new__</code>方法创建实例，<code>__init__</code>负责初始化一个实例。<code>__new__</code>方法返回创建的对象，而<code>__init__</code>方法禁止返回值(必须返回None)。有一个简单的原则来判断什么使用使用<code>__init__</code>和<code>__new__</code>：</p><ul><li>如果需要修改类的属性，使用元类的<code>__new__</code>方法</li><li>如果只是做一些类属性检查的工作，使用元类的<code>__init__</code>方法</li></ul><p>之前的示例都是使用<code>__new__</code>方式，我们来看个使用<code>__init__</code>方法的元类。假如我们有这样一个需求，很多懒痴汉程序员不喜欢给类的方法写docstring，怎么办呢？我们可以定义一个元类，强制让所有人使用这个元类。如果哪个家伙偷懒没给方法写docstring，咱就让他连类的定义都不能通过。</p><pre><code>class LazybonesError(BaseException):    &quot;&quot;&quot; 给懒虫们的提示 &quot;&quot;&quot;    passclass MustHaveDocMeta(type):    def __init__(cls, name, bases, attrs):        for attr_name, attr_value in attrs.items():            if attr_name.startswith(&apos;__&apos;):    # skip magic or private method                continue            if not callable(attr_value):    # skip non method attr                continue            if not getattr(attr_value, &apos;__doc__&apos;):                raise LazybonesError(                    &apos;Hi Lazybones, please write doc for your &quot;{}&quot; method&apos;.format(attr_name)                )        type.__init__(cls, name, bases, attrs)class ClassByLazybones(metaclass=MustHaveDocMeta):    &quot;&quot;&quot; 这个类的定义是无法通过的，直接会报异常，让你不给方法写docstring &quot;&quot;&quot;    def complicate(self):        pass</code></pre><hr><h2 id="何时使用元类"><a href="#何时使用元类" class="headerlink" title="何时使用元类?"></a>何时使用元类?</h2><p>嗯，其实我没啥经验，还没在业务代码中使用过。使用元类可以拦截和修改类的创建，我们也使用使用别的技术来实现类属性的修改，比如</p><ul><li>monkey patching: 猴子补丁，实际上就是『运行时动态替换属性』</li><li>class decorators: 类装饰器，可以实现给类动态修改属性。</li></ul><p>有时候使用元类反而是最麻烦的技术。不过使用元类也有一下一些好处:</p><ul><li>意图更加明确。当然你的metaclass名字要起好。</li><li>面向对象。可以隐式继承到子类。</li><li>可以更好地组织代码，更易读。</li><li>可以用<code>__new__，__init__,__call__</code>等方法更好地控制。<br>我们最好选择容易理解和维护的方式来实现。</li></ul><hr><h2 id="元类的一些应用（单例，ORM-abc模块等"><a href="#元类的一些应用（单例，ORM-abc模块等" class="headerlink" title="元类的一些应用（单例，ORM, abc模块等)"></a>元类的一些应用（单例，ORM, abc模块等)</h2><h4 id="单例模式：元类经常用来实现单例模式"><a href="#单例模式：元类经常用来实现单例模式" class="headerlink" title="单例模式：元类经常用来实现单例模式"></a>单例模式：元类经常用来实现单例模式</h4><pre><code># 拦截(intercepting)class的创建class Singleton(type):    instance = None    def __call__(cls, *args, **kw):        # 通过重写__call__拦截实例的创建,(实例通过调用括号运算符创建的)        if not cls.instance:            cls.instance = super().__call__(*args, **kw)        return cls.instanceclass ASingleton(metaclass=Singleton):    passclass BSingleton(metaclass=Singleton):    passa = ASingleton()aa = ASingleton()b = BSingleton()bb = BSingleton()assert a is aaassert b is bb</code></pre><h4 id="ORM框架："><a href="#ORM框架：" class="headerlink" title="ORM框架："></a>ORM框架：</h4><p>ORM是”Object Relational Mapping”的缩写，叫做对象-关系映射，用来把关系数据的一行映射成一个对象，一个表对应成一个类，这样就免去了直接使用SQL语句的麻烦，使用起来更加符合程序员的思维习惯。ORM框架里所有的类都是动态定义的，由使用类的用户决定有哪些字段，这个时候就只能用元类来实现了。感兴趣的可以看看廖雪峰的python教程，里边有个简单的orm实现。我在这里重新巩固一下。<br>orm有两个重要的类，一个是Model表示数据库中的表，一个是Field表示数据库中的字段。通常通过以下方式使用(py3.5):</p><pre><code>class User(Model):    id = IntegerField(&apos;id&apos;)    name = StringField(&apos;name&apos;)u = User(id=1, name=&apos;laowang&apos;)u.save()</code></pre><p>接下来定义Field类，Model的元类和基类:</p><pre><code>class Field:    &quot;&quot;&quot; 负责保存数据库表的字段名和字段类型 &quot;&quot;&quot;    def __init__(self, name, column_type):        self.name = name        self.column_type = column_type    def __str__(self):        return &apos;&lt;%s:%s&gt;&apos; % (self.__class__.__name__, self.name)class IntegerField(Field):    def __init__(self, name):        super().__init__(name, &apos;bigint&apos;)class StringField(Field):    def __init__(self, name):        super().__init__(name, &apos;varchar(100)&apos;)# 编写ModelMetaclass元类class ModelMetaclass(type):    def __new__(mcs, name, bases, attrs):        if name == &apos;Model&apos;:            return type.__new__(mcs, name, bases, attrs)        print(&apos;Found model: %s&apos; % name)        mappings = {}    # 保存field        for attr_name, attr_value in attrs.items():            if isinstance(attr_value, Field):                print(&apos;Found maping: %s ==&gt; %s&apos; % (attr_name, attr_value))                mappings[attr_name] = attr_value        for k in mappings.keys():            attrs.pop(k)    # 去除field属性        # 把所有的Field移到__mappings__里，防止实例的属性覆盖类的同名属性        attrs[&apos;__mappings__&apos;] = mappings        attrs[&apos;__tablename__&apos;] = name.lower()  # 使用类名小写作为表名        return type.__new__(mcs, name, bases, attrs)# 编写基类Modelclass Model(dict, metaclass=ModelMetaclass):    def __init__(self, **kwargs):        super().__init__(**kwargs)    def __getattr__(self, key):    # 为了实现可以用&quot;.&quot;访问属性        try:            return self[key]        except KeyError:            raise AttributeError(&quot;&apos;Model&apos; object has no attribute &apos;%s&apos;&quot; % key)    def __setattr__(self, k, v):        self[k] = v    def save(self):        fields = []        params = []        args = []        for field_name, field in self.__mappings__.items():            fields.append(field.name)            params.append(&apos;?&apos;)            args.append(getattr(self, field_name, None))        # 拼成sql语句        sql = &apos;inset into %s (%s) values (%s)&apos; % (            self.__tablename__, &apos;,&apos;.join(fields), &apos;,&apos;.join(params)        )        print(&apos;SQL: %s&apos; % sql)        print(&apos;ARGS: %s&apos; % str(args))# python3.5class User(Model):    id = IntegerField(&apos;id&apos;)    name = StringField(&apos;name&apos;)u = User(id=1, name=&apos;laowang&apos;)u.save()&quot;&quot;&quot; 输出如下Found model: UserFound maping: id ==&gt; &lt;IntegerField:id&gt;Found maping: name ==&gt; &lt;StringField:name&gt;SQL: inset into user (id,name) values (?,?)ARGS: [1, &apos;laowang&apos;]&quot;&quot;&quot;</code></pre><h4 id="abc模块-抽象基类支持"><a href="#abc模块-抽象基类支持" class="headerlink" title="abc模块:抽象基类支持"></a>abc模块:抽象基类支持</h4><p>抽象基类就是包含一个或者多个抽象方法的类，它本身不实现抽象方法，强制子类去实现，同时抽象基类自己不能被实例化，没有实现抽象方法的子类也无法实例化。python内置的abc(abstract base class)来实现抽象基类。</p><pre><code># 为了实现这两个特性，我们可以这么写class Base:    def foo(self):        raise NotImplementedError()    def bar(self):        raise NotImplementedError()class Concrete(Base):    def foo(self):        return &apos;foo() called&apos;    # Oh no, we forgot to override bar()...    # def bar(self):    #     return &quot;bar() called&quot;</code></pre><p>但是这么写依然可以实例化Base，python2.6以后引入了abc模块帮助我们实现这个功能。</p><pre><code>from abc import ABCMeta, abstractmethodclass Base(metaclass=ABCMeta):    @abstractmethod    def foo(self):        pass    @abstractmethod    def bar(self):        passclass Concrete(Base):    def foo(self):        pass    # We forget to declare bar() again...</code></pre><p>使用这种方式如果没有在子类里实现bar方法你是没有办法实例化子类的。合理使用抽象基类定义明确的接口。另外应该优先使用collections定义的抽象基类，比如要实现一个容器我们可以继承 collections.Container</p><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Metaclasses are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why). - Tim Peters&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平常都是写业务逻辑，从来没有使用过元类这种黑魔法（好吧，目前的编码规范是不推荐在业务逻辑当中使用元类的，不好维护并且一般来说并无这个必要）。不过貌似只有造轮子的时候才会用到，就像上边的引用里说的，当你不知道为什么要使用元类时，你是没必要使用它的,大部分时间python灵活的特性已经可以应付几乎所有业务问题。最近重新看了下元类，突然有了一种霍然开朗的感觉，用几个简单的例子介绍一些元类(使用python3.5)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://ningning.today/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>注重细节:代码排版，命名与注释</title>
    <link href="http://ningning.today/2017/01/22/python/python-coding-details/"/>
    <id>http://ningning.today/2017/01/22/python/python-coding-details/</id>
    <published>2017-01-22T13:52:38.000Z</published>
    <updated>2017-02-04T08:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.” – Martin Fowler, “Refactoring: Improving the Design of Existing Code”</p></blockquote><p>可能又要被说吹毛求疵或者有代码洁癖了，但是最近协作的时候感觉代码风格不统一，看代码的时候很不方便。实际上良好的代码排版，包括何时分行，何时使用括号都是有讲究的。<br>良好的代码排版给人看下去的欲望，同时还能让人分清主次重点，方便快速理解代码。讲一下自己对一些编程细节的看法。</p><a id="more"></a><h2 id="为什么版式是重要的"><a href="#为什么版式是重要的" class="headerlink" title="为什么版式是重要的?"></a>为什么版式是重要的?</h2><blockquote><p>因为太丑的版式我压根不想看啊！！！</p></blockquote><p>我们看一个简单的例子就明白了:</p><pre><code># 分行之前的一行代码，我经常见过一个屏幕装不下一行的daily_report_data = db.session.query(FinanceData.event_date, func.sum(FinanceData.revenue).label(&apos;revenue&apos;), func.sum(FinanceData.payout).label(&apos;payout&apos;)).filter(FinanceData.tag != FinanceData.TagEnum.arbitrage).filter(FinanceData.event_date &lt; self._next_month_date).filter(FinanceData.event_date &gt;= self._this_month_date).filter(FinanceData.finance_type == FinanceData.TypeEnum.normal).group_by(FinanceData.event_date).all()# 分行之后daily_report_data = db.session.query(    FinanceData.event_date,    func.sum(FinanceData.revenue).label(&apos;revenue&apos;),    func.sum(FinanceData.payout).label(&apos;payout&apos;)).filter(    FinanceData.tag != FinanceData.TagEnum.arbitrage).filter(    FinanceData.event_date &lt; self._next_month_date).filter(    FinanceData.event_date &gt;= self._this_month_date).filter(    FinanceData.finance_type == FinanceData.TypeEnum.normal).group_by(    FinanceData.event_date).all()if a_long_variable_name and b_long_variable_name and c_variable_name:</code></pre><p>你看看大概各需要几秒才能分别理解上边的代码。这些都是真实的例子，只是想说明一下为什么排版有时候是很重要的。第一行你光是移动编辑器指针就得花上几秒时间，你用vim，emacs等还好，有些编辑器还需要你用鼠标啪啪点击下。下边短代码就能迅速理解代码的大致意图，大大降低理解成本。而且有些程序员很喜欢分屏（比如我），经常一个大屏幕会打开多个文件，碰见这种超长的代码就很无语。而且长代码还有个缺点，对于合并代码来说很不友好，你要来回左右切换找代码的diff。下边是我个人一点经验:</p><ul><li>不要使用太长的行(尽量别超出120列)，否则分屏查看或合并代码的时候很不方便 ，你得来回移动编辑器指针，对笔者这种喜欢分屏的简直就是灾难。</li><li>尽量遵守pep8，除了行长度可以适当放宽，比如django使用120列。</li><li>合理使用 换行和括号 使代码更易理解，同时更美观。</li><li>合理使用 空行 对代码块逻辑进行分隔，使层次清晰。</li></ul><p>下边是我一些常用的分行方式，对于长代码你可以试试:</p><pre><code>daily_report_data = db.session.query(    FinanceData.event_date,    func.sum(FinanceData.revenue).label(&apos;revenue&apos;),    func.sum(FinanceData.payout).label(&apos;payout&apos;)).filter(    FinanceData.tag != FinanceData.TagEnum.arbitrage).filter(    FinanceData.event_date &lt; self._next_month_date).filter(    FinanceData.event_date &gt;= self._this_month_date).filter(    FinanceData.finance_type == FinanceData.TypeEnum.normal).group_by(    FinanceData.event_date).all()from some_module import (    a_long_variable_name, b_long_variable_name, c_long_variable_name,    d_long_variable_name)if a_long_variable_name and b_long_variable_name and c_variable_name \        and d_variable:    # 更推荐使用括号而不是反斜线来分行    passif (a_long_variable_name and b_long_variable_name    and c_long_variable_name and d_long_variable_name):    passa_long_list_comprehension = [person.name                            for person in db.session.query(Person.name)]a_long_dict_comprehension = {    person.id: person.name    for person in db.session.query(Person.name, Person.id)}employee_id_list = [    ins.id for ins in Employee.get_role_team_members(        role_int, team_int, [&apos;id&apos;]    )]def long_variable_function_name_and_function_params(a_long_variable_name,                                                    b_long_variable_name,                                                    c_long_variable_name,                                                    d_long_variable_name):    passdef long_variable_function_name_and_function_params(    a_long_variable_name,    b_long_variable_name,    c_long_variable_name,    d_long_variable_name):    passreturn {    &apos;code&apos;: ErrorCode.OPERATOR_FAILED_NEED_TOKEN,    &apos;msg&apos;: ErrorCode.OPERATOR_FAILED_NEED_TOKEN_MSG,    &apos;data&apos;: {}}, status_codes.unauthorizednew_employee = Employee.get_by_id(new_employee_id)(    changed_advertiser_ids,    changed_account_ids) = assign_employee_advertiser_and_account(employee, new_employee)result = a_very_very_very_very_very_very_very_very_long_function_name(    a_long_variable_name, b_long_variable_name,    c_long_variable_name, d_long_variable_name)</code></pre><hr><h2 id="为什么命名是重要的"><a href="#为什么命名是重要的" class="headerlink" title="为什么命名是重要的?"></a>为什么命名是重要的?</h2><blockquote><p>因为我经常看代码的时候搞不清当前变量的含义和类型啊！！！</p></blockquote><p>首先你要遵守pep8的规定，使用惯用法来命名。或者根据你们公司的python编码规范（如果你们公司有的话）</p><ul><li>joined_lower for functions, methods, attributes</li><li>ALL_CAPS for constants</li><li>StudlyCaps for classes</li></ul><p>另外注意动态语言因为没有类型声明，所以在阅读源代码的时候，如果名称起的不好，很难推测出代码中间变量的数据结构，给阅读代码带来障碍。比如一个字典列表，或者嵌套字典等，笔者维护过python代码，深感其中坑太多。我个人的经验就是适度在命名中加入一些类型提示，比如使用nums, cnts等作为后缀很容易知道是数值类型，复数单词或者some_list等很容易知道是序列，some_mapper或者some_dict, some_set等基本从命名就知道什么数据类型了。当然这只是我的经验，有些人会反对这种命名方式，老实说如果代码写得是自解释的，可以不用这么来，但是我个人感觉这种方式虽然冗余，但是确实给我维护和阅读代码带来了便利。</p><p>python3中加入了type hint特性，所以我觉得类型声明对于维护代码来说还是非常便利的。但是注意，动态语言有鸭子类型的概念，所以有时候名称中的类型提示并不代表就是该类型，很可能造成歧义，这也是很多人反对在python中使用类似匈牙利命名法的原因。老实说我不怎么使用鸭子类型，我感觉鸭子类型是很多错误的来源，如果它真的很有用，python3也不用加上类型注解了，甚至mypy都加上类型检测了（python3中的注解只是为IDE工具提供便利，并没有真正的类型检查）。我觉得对于软件工程重视不够的团队最好不要使用动态语言开发后台，坑比较多。</p><ul><li>注意词性。比如函数用动词，数据变量使用名词，布尔数据经常使用is等作为前缀。这样很容易推断出变量含义，给阅读代码带来便利</li><li>适当使用”匈牙利”命名法。比如一个变量明显是字典或者集合，加上后缀可能会更易理解。（个人经验，有争议，不过我确实感觉这种代码更容易阅读理解）</li><li>含义精确。不要使用诸如data，info等概念太广泛的词汇给变量命名。</li></ul><hr><h2 id="为什么注释与docstring是重要的"><a href="#为什么注释与docstring是重要的" class="headerlink" title="为什么注释与docstring是重要的?"></a>为什么注释与docstring是重要的?</h2><blockquote><p>因为你代码写的不好看我连传入参数是啥类型都不知道啊！！！</p></blockquote><pre><code>def function_with_types_in_docstring(param1, param2):&quot;&quot;&quot;Example function with types documented in the docstring.`PEP 484`_ type annotations are supported. If attribute, parameter, andreturn types are annotated according to `PEP 484`_, they do not need to beincluded in the docstring:Args:    param1 (int): The first parameter.    param2 (str): The second parameter.Returns:    bool: The return value. True for success, False otherwise... _PEP 484:    https://www.python.org/dev/peps/pep-0484/&quot;&quot;&quot;</code></pre><p>这个是google的docstring示例,是我比较推崇的一种格式。还是那个问题，动态语言没有类型声明，所以复杂函数要在docstring里写清楚传入参数和返回值的描述和类型。良好的docstring能让维护代码的人一眼就看明白这个函数是怎么使用的，即使内部很复杂，也尽量保持接口简单，容易使用。经常有人传出个嵌套字典（dict的key是主键，每个key对应的value里还有字典），这种相对复杂的数据结构还不注释，每次看这种函数都要打断点看返回结构。这种就是典型的接口易用性差，只在意实现功能，完全不管别人使用，合作起来比较心累。</p><ul><li>Docstrings = How to use code</li><li>Comments = Why &amp; how code works</li></ul><p>Docstring应该包括什么?接口易用性</p><ul><li>意图(目的)。解释为什么需要它？有些对你来说很明显的东西对其他人来说不一定很明显。</li><li>描述参数，返回值和会抛出的异常。我举个简单的例子， <code>def f(date): pass</code> ，仅仅看date这个参数你不知道传入str还是datetime.date，如果传入字符串又有很多格式的字符串，需要哪种格式？所以这个时候一个简单的描述 <code>date (str): &#39;YYYY-MM-DD&#39;</code> 就能让使用函数的人一下子明白了。当然如果有单元测试实际上测试代码也是很好的文档，我们通过单元测试就知道怎么传值。另外使用了 <code>**kwargs</code> 如果都不说明就太不厚道了</li><li>使用注意事项。复杂的使用可以有demo示例说明。</li><li>需求文档或者github, stackoverflow等链接。比如有个很trick的实现是你查阅 stackoverflow解决的，可以附上地址帮助阅读代码的人找到出处。</li></ul><p>注释怎么写?</p><ul><li>当然，好代码 &gt; 差代码+好注释，自解释的代码最好。</li><li>适当注释，仔细衡量，不要隐晦也不要多余。</li><li>及时更新。</li><li>注释代码中一些tricky的技巧或者特殊的业务逻辑。</li></ul><p>很多东西都需要自己斟酌，不要矫枉过正，比如说需要注释你就写一堆没必要的冗余的注释，说遵守pep8尽量不超过80列你连url都要拆成两行，我。。。。。。如果有些规范相冲突，你就以代码的可读性为标准，所有标准都是为了良好的代码设计的。我最怕和随意的程序员一起干活，随意就是写个函数print下就觉得正确了，没有docstring和注释，写的接口让别人难以使用。公司项目毕竟不是自己过家家，我现在就是自己的小项目也会注重规范（自己维护起来也方便，不要相信你的记忆力）。很多用python的小公司就是很不规范，维护起来真心累。也希望所有看到这里的python学习者可以把规范重视起来(很多知名开源项目文档都相当不错)，这也是一个职业程序员应该具备的素养。毕竟大部分人不是造轮子的人，能把业务逻辑实现地简单优雅易维护也是一种能力。代码就是一点一滴的小细节组成的，尽量在细节之处做好提升代码的易读性和可维护性。</p><hr><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="http://python-web-guide.readthedocs.io/zh/latest/codingstyle/codingstyle.html" target="_blank" rel="noopener">《编码之前碎碎念》</a> - 没事我就更(tu)新(cao)点</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.” – Martin Fowler, “Refactoring: Improving the Design of Existing Code”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能又要被说吹毛求疵或者有代码洁癖了，但是最近协作的时候感觉代码风格不统一，看代码的时候很不方便。实际上良好的代码排版，包括何时分行，何时使用括号都是有讲究的。&lt;br&gt;良好的代码排版给人看下去的欲望，同时还能让人分清主次重点，方便快速理解代码。讲一下自己对一些编程细节的看法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://ningning.today/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Getting Started with Pyparsing</title>
    <link href="http://ningning.today/2017/01/06/python/getting-started-with-pyparsing/"/>
    <id>http://ningning.today/2017/01/06/python/getting-started-with-pyparsing/</id>
    <published>2017-01-06T12:09:42.000Z</published>
    <updated>2017-01-08T04:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The grammar specification should be a natural-looking part of the Python program, easy-to-read, and familiar in style and format to Python programmers. - Zen of Pyparsing.</p></blockquote><p>上篇博客在讲设计模式解释器模式的时候提到了pyparsing库，当时用该库处理命令从而实现了很简单的DSL，这次详细介绍下该库。 <a href="http://infohost.nmt.edu/tcc/help/pubs/pyparsing/web/index.html" target="_blank" rel="noopener">pyparsing</a>是一个文本处理库，可以用来处理html，日志文件，复杂数据结构或者命令的解析等。比如去除源码中的注释，或者写个简单的DSL等。</p><a id="more"></a><p>编程中处理文本的需求还是很多的，比如处理json串(各种json库)，爬虫解析html(re, bs，lxml)等。对于简单的字符串一般用str内置的split(),index(),startswith()等方法就能处理，对于源文件有lex/yacc工具。正则对于文本处理也是个强大的工具，但是大部分人不是正则表达式专家，对于复杂的文本处理写好正则是很难的，而且正则表达式也不是很直观，举个例子，我们写个处理ip地址后边跟个美国电话号码格式的字符串：</p><pre><code># 正则pat = &apos;(\d{1,3}(?:\.\d{1,3}){3})\s+(\(\d{3}\)\d{3}-\d{4})&apos;# 使用 pyparsing，虽然代码写得多，但是从可读性可维护性和扩展性来说更好ipField = Word(nums, max=3)ipAddr = Combine( ipField + &quot;.&quot; + ipField + &quot;.&quot; + ipField + &quot;.&quot; + ipField )phoneNum = Combine( &quot;(&quot; + Word(nums, exact=3) + &quot;)&quot; +                    Word(nums, exact=3) + &quot;−&quot; + Word(nums, exact=4) )userdata = ipAddr + phoneNum</code></pre><p>pyparsing有以下特点：</p><ul><li>纯python实现，兼容2，3。易于开发和维护。</li><li>内置了很多处理模式。<ul><li>C,C++,Java,Pypthon, HTML 注释处理</li><li>引号字符串</li><li>HMLT和XML标签</li><li>逗号等任意界定符表达式</li></ul></li><li>只有一个python源文件，容易移植和使用</li><li>MIT协议</li></ul><hr><h2 id="使用pyparsing的正确姿势"><a href="#使用pyparsing的正确姿势" class="headerlink" title="使用pyparsing的正确姿势"></a>使用pyparsing的正确姿势</h2><h4 id="1-导入需要的函数或者类"><a href="#1-导入需要的函数或者类" class="headerlink" title="1. 导入需要的函数或者类"></a>1. 导入需要的函数或者类</h4><h4 id="2-定义语法和hepler函数"><a href="#2-定义语法和hepler函数" class="headerlink" title="2. 定义语法和hepler函数:"></a>2. 定义语法和hepler函数:</h4><ul><li>比如定义变量名<code>identifier = Word(alphas, alphanums + &#39;_&#39;)</code></li><li>定义整数或者浮点数<code>number = Word(nums+ &quot;.&quot;)</code></li><li>定义个赋值语句<code>assignmentExpr = identifier + &quot;=&quot; + (identifier | number)</code></li></ul><pre><code># 利用我们定义的 assignmentExpr 可以解析下边的所有赋值语句a = 10a_2=100pi=3.14159goldenRatio = 1.61803E = mc2</code></pre><p>我们只使用<a href="http://en.wikipedia.org/wiki/backus-naur_form" target="_blank" rel="noopener">Backus-Naur Form (BNF)</a>这些缩写标记:</p><ul><li>::=  表示 “is defined as”</li><li>+ 表示 “1 or more”</li><li>* 表示 “0 or more”</li><li>在[]中的项目表示可选的</li><li>一连串项 表示要匹配的串必须出现在序列里</li><li>| 表示或许会出现</li></ul><h4 id="3-使用定义的语法处理输入文本"><a href="#3-使用定义的语法处理输入文本" class="headerlink" title="3. 使用定义的语法处理输入文本"></a>3. 使用定义的语法处理输入文本</h4><ul><li>parseString: 把定义的语法应用到输入文本上</li><li>scanString: 扫描输入文本寻找匹配</li><li>searchString: 封装了scanString,返回所有匹配token的list</li><li>transformString: 也是封装了scanString, 简化了匹配token并且修改文本的操作</li></ul><h4 id="4-处理parsing文本得到的结果"><a href="#4-处理parsing文本得到的结果" class="headerlink" title="4. 处理parsing文本得到的结果"></a>4. 处理parsing文本得到的结果</h4><p>pyparsing可以返回list或者 ParseResults</p><pre><code># 输出listassignemntToken = assignmentExpr.parseString(&quot;pi=3.14159&quot;)print(assignemntToken)    # 输出 [&apos;pi&apos;, &apos;=&apos;, &apos;3.14159&apos;]# 根据attributes输出assignmentExpr = identifier.setResultsName(&quot;lhs&quot;) + &quot;=&quot; + \    (identifier | number).setResultsName(&quot;rhs&quot;)assignmentTokens = assignmentExpr.parseString(&quot;pi=3.14159&quot;)# 输出 3.14159 is assigned to piprint(assignmentTokens.rhs, &quot;is assigned to&quot;, assignmentTokens.lhs)</code></pre><hr><h2 id="“Hello-World-”-例子"><a href="#“Hello-World-”-例子" class="headerlink" title="“Hello World!” 例子"></a>“Hello World!” 例子</h2><p>我们通过解析”Hello World!” 来说明pyparsing的使用。”Hello, World!”的形式表示如下”word, word !”</p><pre><code>Hello, World!Hi, Mom!Good morning, Miss Crabtree!Yo, Adrian!Whattup, G?How&apos;s it goin&apos;, Dude?Hey, Jude!Goodbye, Mr. Chips!</code></pre><p>我们用BNF来定义这个字符串表示 （这个例子有点杀鸡用牛刀，不过基本覆盖了pyparsing使用）</p><pre><code>greeting ::= salutation comma greetee endpuncsalutation ::= word+comma ::= ,greetee ::= word+word ::= a collection of one or more characters, which are any alpha or &apos; or .endpunc ::= ! | ?</code></pre><p>可以把上面这个BNF直接翻译到pyparsing表示，使用pyparsing定义的Word, Literal, OneOrMore和helper方法 onOf。BNF使用自顶向下，<br>翻译到pyparsing我们用自底向上方法:</p><pre><code>word = Word(alphas + &quot;&apos;.&quot;)salutation = OneOrMore(word)comma = Literal(&quot;,&quot;)greetee = OneOrMore(word)endpunc = oneOf(&quot;! ?&quot;)    # oneOf可以避免这种麻烦的写法 Literal(&quot;!&quot;) | Literal(&quot;?&quot;)greeting = salutation + comma + greetee + endpunc</code></pre><p>完整代码如下:</p><pre><code>from pyparsing import *    # 偷个懒tests = &quot;&quot;&quot;\Hello, World!Hi, Mom!Good morning, Miss Crabtree!Yo, Adrian!Whattup, G?How&apos;s it goin&apos;, Dude?Hey, Jude!Goodbye, Mr. Chips!&quot;&quot;&quot;word = Word(alphas + &quot;&apos;.&quot;)salutation = Group(OneOrMore(word))comma = Literal(&quot;,&quot;)greetee = Group(OneOrMore(word))endpunc = oneOf(&quot;! ?&quot;)    # oneOf可以避免这种麻烦的写法 Literal(&quot;!&quot;) | Literal(&quot;?&quot;)greeting = salutation + comma + greetee + endpuncfor test_str in tests.splitlines():    # print(test_str)    print(greeting.parseString(test_str))</code></pre><p>输出结果如下:</p><pre><code>[&apos;Hello&apos;, &apos;,&apos;, &apos;World&apos;, &apos;!&apos;][&apos;Hi&apos;, &apos;,&apos;, &apos;Mom&apos;, &apos;!&apos;][&apos;Good&apos;, &apos;morning&apos;, &apos;,&apos;, &apos;Miss&apos;, &apos;Crabtree&apos;, &apos;!&apos;][&apos;Yo&apos;, &apos;,&apos;, &apos;Adrian&apos;, &apos;!&apos;][&apos;Whattup&apos;, &apos;,&apos;, &apos;G&apos;, &apos;?&apos;][&quot;How&apos;s&quot;, &apos;it&apos;, &quot;goin&apos;&quot;, &apos;,&apos;, &apos;Dude&apos;, &apos;?&apos;][&apos;Hey&apos;, &apos;,&apos;, &apos;Jude&apos;, &apos;!&apos;][&apos;Goodbye&apos;, &apos;,&apos;, &apos;Mr.&apos;, &apos;Chips&apos;, &apos;!&apos;]</code></pre><p>注意问候语被拆分长了多个，我们修改下定义:</p><pre><code>salutation = Group( OneOrMore(word) )greetee = Group( OneOrMore(word) )</code></pre><p>结果如下:</p><pre><code>[[&apos;Hello&apos;], &apos;,&apos;, [&apos;World&apos;], &apos;!&apos;][[&apos;Hi&apos;], &apos;,&apos;, [&apos;Mom&apos;], &apos;!&apos;][[&apos;Good&apos;, &apos;morning&apos;], &apos;,&apos;, [&apos;Miss&apos;, &apos;Crabtree&apos;], &apos;!&apos;][[&apos;Yo&apos;], &apos;,&apos;, [&apos;Adrian&apos;], &apos;!&apos;][[&apos;Whattup&apos;], &apos;,&apos;, [&apos;G&apos;], &apos;?&apos;][[&quot;How&apos;s&quot;, &apos;it&apos;, &quot;goin&apos;&quot;], &apos;,&apos;, [&apos;Dude&apos;], &apos;?&apos;][[&apos;Hey&apos;], &apos;,&apos;, [&apos;Jude&apos;], &apos;!&apos;][[&apos;Goodbye&apos;], &apos;,&apos;, [&apos;Mr.&apos;, &apos;Chips&apos;], &apos;!&apos;]</code></pre><p>我们再修改下输出的结果显示：</p><pre><code>salutation, dummy, greetee, endpunc = greeting.parseString(t)print(salutation, greetee, endpunc)</code></pre><p>输出如下：</p><pre><code>[&apos;Hello&apos;] [&apos;World&apos;] ![&apos;Hi&apos;] [&apos;Mom&apos;] ![&apos;Good&apos;, &apos;morning&apos;] [&apos;Miss&apos;, &apos;Crabtree&apos;] ![&apos;Yo&apos;] [&apos;Adrian&apos;] ![&apos;Whattup&apos;] [&apos;G&apos;] ?[&quot;How&apos;s&quot;, &apos;it&apos;, &quot;goin&apos;&quot;] [&apos;Dude&apos;] ?[&apos;Hey&apos;] [&apos;Jude&apos;] ![&apos;Goodbye&apos;] [&apos;Mr.&apos;, &apos;Chips&apos;] !</code></pre><p>对于不感兴趣的内容可以压缩：</p><pre><code>comma = Suppress(Literal(&quot;,&quot;))    #  压缩不感兴趣的for test_str in tests.splitlines():    salutation, greetee, endpunc = greeting.parseString(test_str)    print(salutation, greetee, endpunc)</code></pre><p>我们收集下所有的问候语：</p><pre><code>salutation_list = []for test_str in tests.splitlines():    salutation, greetee, endpunc = greeting.parseString(test_str)    salutation_list.append((&quot; &quot;.join(salutation)))print(salutation_list)# 输出 [&apos;Hello&apos;, &apos;Hi&apos;, &apos;Good morning&apos;, &apos;Yo&apos;, &apos;Whattup&apos;, &quot;How&apos;s it goin&apos;&quot;, &apos;Hey&apos;, &apos;Goodbye&apos;]</code></pre><hr><h2 id="pyparsing有什么特别的？"><a href="#pyparsing有什么特别的？" class="headerlink" title="pyparsing有什么特别的？"></a>pyparsing有什么特别的？</h2><h4 id="Class-names-are-easier-to-read-and-understand-than-specialized-typography"><a href="#Class-names-are-easier-to-read-and-understand-than-specialized-typography" class="headerlink" title="Class names are easier to read and understand than specialized typography."></a>Class names are easier to read and understand than specialized typography.</h4><p>用pyparsing可以让代码更易维护，更加易读。之前介绍的时候举过例子，再举个例子，比如我们想匹配c语言中的函数调用，包含0或者多个参数:</p><pre><code># 匹配c函数调用的正则, 看起来很不直观(\w+)\((((\d+|\w+)(,(\d+|\w+))*)?)\)# 使用 pyparsingWord(alphas)+ &quot;(&quot; + Group(Optional(Word(nums)|Word(alphas) + ZeroOrMore(&quot;,&quot; + Word(nums)|Word (alphas)))) + &quot;)&quot;# x + ZeroOrMore(&quot;,&quot;+x) is so common 这种形式pyparsing提供了helper函数delimitedList# 还可以进一步简化成一下形式Word(alphas)+ &quot;(&quot; + Group( Optional(delimitedList(Word(nums)|Word(alphas)))  ) + &quot;)&quot;</code></pre><h4 id="Whitespace-markers-clutter-and-distract-from-the-grammar-definition"><a href="#Whitespace-markers-clutter-and-distract-from-the-grammar-definition" class="headerlink" title="Whitespace markers clutter and distract from the grammar definition."></a>Whitespace markers clutter and distract from the grammar definition.</h4><p>空白符等符号在我们处理字符串的时候有时候是无用的，上面的正则能处理<br><code>abd(1, 2, def, 5)</code>但是处理不了<code>abc(1, 2, def, 5)</code>，用正则的话需要加上空白处理<br><code>(\w+)\s*\(\s*(((\d+|\w+)(\s*,\s*(\d+|\w+))*)?)\s*\)</code>， 但是pyparsing版本不需要改动，会自动处理。<br>另外如果在参数里有代码注释我们可以这么处理:(用正则的话就很难实现了)</p><pre><code>cFunction = Word(alphas)+ &quot;(&quot; + \    Group( Optional(delimitedList(Word(nums)|Word(alphas)))  ) + &quot;)&quot;cFunction.ignore( cStyleComment  )</code></pre><h4 id="The-results-of-the-parsing-process-should-do-more-than-just-represent-a-nested-list-of-tokens-especially-when-grammars-get-complicated"><a href="#The-results-of-the-parsing-process-should-do-more-than-just-represent-a-nested-list-of-tokens-especially-when-grammars-get-complicated" class="headerlink" title="The results of the parsing process should do more than just represent a nested list of tokens, especially when grammars get complicated."></a>The results of the parsing process should do more than just represent a nested list of tokens, especially when grammars get complicated.</h4><p>对于复杂的语法，我们可以通过ParseResults对结果进行访问，返回的list我们可以通过下标也可以通过属性名来访问，给处理结果带来很大便利。</p><h4 id="Parse-time-is-a-good-time-for-additional-text-processing"><a href="#Parse-time-is-a-good-time-for-additional-text-processing" class="headerlink" title="Parse time is a good time for additional text processing."></a>Parse time is a good time for additional text processing.</h4><p>pyparsing支持在匹配的时候传入回调函数进行一些操作(parse-time callbacks，called parse actions)。下边这个例子匹配到引号括起来的字符串以后传入个lambda函数去除两头的引号。我们也可以在parse action里加入额外的字符串验证等。</p><pre><code>quotedString.setParseAction( lambda t: t[0][1:−1]  )</code></pre><h4 id="Grammars-must-tolerate-change-as-grammar-evolves-or-input-text-becomes-more-challenging"><a href="#Grammars-must-tolerate-change-as-grammar-evolves-or-input-text-becomes-more-challenging" class="headerlink" title="Grammars must tolerate change, as grammar evolves or input text becomes more challenging."></a>Grammars must tolerate change, as grammar evolves or input text becomes more challenging.</h4><p>当输入文本变化的时候，处理文本会变得复杂。pyparsing可以使得代码更容易修改和扩充，更易写出自解释的代码。</p><hr><h2 id="使用Parse-Actions-和-ParseResults-从表格中解析数据"><a href="#使用Parse-Actions-和-ParseResults-从表格中解析数据" class="headerlink" title="使用Parse Actions 和 ParseResults 从表格中解析数据"></a>使用Parse Actions 和 ParseResults 从表格中解析数据</h2><p>先来看一组简单的数据，学校球赛得分，每行数据是日期和学校名及对应分数。</p><pre><code>09/04/2004  Virginia         44   Temple             1409/04/2004  LSU              22   Oregon State       2109/09/2004  Troy State       24   Missouri           1401/02/2003  Florida State   103   University of Miami 2</code></pre><p>改数据的BNF定义:</p><pre><code>digit      ::= &apos;0&apos;..&apos;9&apos;alpha      ::= &apos;A&apos;..&apos;Z&apos; &apos;a&apos;..&apos;z&apos;date       ::= digit+ &apos;/&apos; digit+ &apos;/&apos; digit+schoolName ::= ( alpha+ )+score      ::= digit+schoolAndScore ::= schoolName scoregameResult ::= date schoolAndScore schoolAndScore</code></pre><p>我们把BNF翻译成pyparsing中的类</p><pre><code>num = Word(nums)date = num + &quot;/&quot; + num + &quot;/&quot; + numschoolName = OneOrMore(Word(alphas))# 结合上面定义更复杂的表达式score = Word(nums)schoolAndScore = schoolName + scoregameResult = date + schoolAndScore + schoolAndScore</code></pre><p>所有代码如下：</p><pre><code>tests = &quot;&quot;&quot;\09/04/2004  Virginia         44   Temple             1409/04/2004  LSU              22   Oregon State       2109/09/2004  Troy State       24   Missouri           1401/02/2003  Florida State   103   University of Miami 2&quot;&quot;&quot;num = Word(nums)date = num + &quot;/&quot; + num + &quot;/&quot; + numschoolName = OneOrMore(Word(alphas))# 结合上面定义更复杂的表达式score = Word(nums)schoolAndScore = schoolName + scoregameResult = date + schoolAndScore + schoolAndScorefor test in tests.splitlines():    stats = gameResult.parseString(test)    print(stats.asList())&quot;&quot;&quot;  输出的是无结构的字符串list[&apos;09&apos;, &apos;/&apos;, &apos;04&apos;, &apos;/&apos;, &apos;2004&apos;, &apos;Virginia&apos;, &apos;44&apos;, &apos;Temple&apos;, &apos;14&apos;][&apos;09&apos;, &apos;/&apos;, &apos;04&apos;, &apos;/&apos;, &apos;2004&apos;, &apos;LSU&apos;, &apos;22&apos;, &apos;Oregon&apos;, &apos;State&apos;, &apos;21&apos;][&apos;09&apos;, &apos;/&apos;, &apos;09&apos;, &apos;/&apos;, &apos;2004&apos;, &apos;Troy&apos;, &apos;State&apos;, &apos;24&apos;, &apos;Missouri&apos;, &apos;14&apos;][&apos;01&apos;, &apos;/&apos;, &apos;02&apos;, &apos;/&apos;, &apos;2003&apos;, &apos;Florida&apos;, &apos;State&apos;, &apos;103&apos;, &apos;University&apos;, &apos;of&apos;, &apos;Miami&apos;, &apos;2&apos;]&quot;&quot;&quot;# 我们把日期组合起来，修改date为date = Combine(num + &quot;/&quot; + num + &quot;/&quot; + num)gameResult = date + schoolAndScore + schoolAndScore&quot;&quot;&quot; 输出变成[&apos;09/04/2004&apos;, &apos;Virginia&apos;, &apos;44&apos;, &apos;Temple&apos;, &apos;14&apos;][&apos;09/04/2004&apos;, &apos;LSU&apos;, &apos;22&apos;, &apos;Oregon&apos;, &apos;State&apos;, &apos;21&apos;][&apos;09/09/2004&apos;, &apos;Troy&apos;, &apos;State&apos;, &apos;24&apos;, &apos;Missouri&apos;, &apos;14&apos;][&apos;01/02/2003&apos;, &apos;Florida&apos;, &apos;State&apos;, &apos;103&apos;, &apos;University&apos;, &apos;of&apos;, &apos;Miami&apos;, &apos;2&apos;]&quot;&quot;&quot;</code></pre><p>还有个问题，大学名称现在是分隔的，我们现在给schoolName加上action<br><code>schoolName.setParseAction( lambda tokens: &quot; &quot;.join(tokens) )</code></p><p>action一般还可以用来作为数据校验，比如我们想校验日期格式:</p><pre><code>def validateDateString(tokens):    try:        time.strptime(tokens[0], &quot;%m/%d/%Y&quot;)    except ValueError:        raise ParseException(&quot;Invalid date string (%s)&quot; % tokens[0])date.setParseAction(validateDateString)</code></pre><p>接下来看看Gropu类的用法，Group用来把解析后的token嵌套成一个sublist,我们修改下schoolAndScore定义: <code>schoolAndScore = Group( schoolName + score  )</code>, 输出结果如下，可以看到学校和分数被[]括成了一个list</p><pre><code>[&apos;09/04/2004&apos;, [&apos;Virginia&apos;, &apos;44&apos;], [&apos;Temple&apos;, &apos;14&apos;]][&apos;09/04/2004&apos;, [&apos;LSU&apos;, &apos;22&apos;], [&apos;Oregon State&apos;, &apos;21&apos;]][&apos;09/09/2004&apos;, [&apos;Troy State&apos;, &apos;24&apos;], [&apos;Missouri&apos;, &apos;14&apos;]][&apos;01/02/2003&apos;, [&apos;Florida State&apos;, &apos;103&apos;], [&apos;University of Miami&apos;, &apos;2&apos;]]</code></pre><p>另外还想把score转成int类型，而不是使用字符串，我们可以在解析过程中传入action</p><pre><code>score = Word(nums).setParseAction( lambda tokens : int(tokens[0])  )</code></pre><p>最后我们给结果添加label。之前的结果都是list，也就是说我们需要用下标访问，但是这样不够优雅，我们可以给每个定义的字段加上标签，这样就可以用标签访问结果，使得代码更加容易维护。就好比相比函数返回一个tuple，比如(res, err)，我们可以用namedtuple或者类封装下，这样函数返回的结果就可以用Result.res访问了。</p><pre><code>schoolAndScore = Group(    schoolName.setResultsName(&quot;school&quot;) +    score.setResultsName(&quot;score&quot;))gameResult = date.setResultsName(&quot;date&quot;) + \    schoolAndScore.setResultsName(&quot;team1&quot;) + \    schoolAndScore.setResultsName(&quot;team2&quot;)</code></pre><p>完整代码如下：</p><pre><code>from pyparsing import Word, Group, Combine, Suppress, OneOrMore, alphas, nums,\    alphanums, stringEnd, ParseExceptionimport timetests = &quot;&quot;&quot;\09/04/2004  Virginia         44   Temple             1409/04/2004  LSU              22   Oregon State       2109/09/2004  Troy State       24   Missouri           1401/02/2003  Florida State   103   University of Miami 2&quot;&quot;&quot;.splitlines()num = Word(nums)date = Combine(num + &quot;/&quot; + num + &quot;/&quot; + num)def validateDateString(tokens):    try:        time.strptime(tokens[0], &quot;%m/%d/%Y&quot;)    except ValueError:        raise ParseException(&quot;Invalid date string (%s)&quot; % tokens[0])date.setParseAction(validateDateString)schoolName = OneOrMore( Word(alphas) )schoolName.setParseAction( lambda tokens: &quot; &quot;.join(tokens) )score = Word(nums).setParseAction(lambda tokens: int(tokens[0]))schoolAndScore = Group( schoolName.setResultsName(&quot;school&quot;) + \        score.setResultsName(&quot;score&quot;) )gameResult = date.setResultsName(&quot;date&quot;) + schoolAndScore.setResultsName(&quot;team1&quot;) + \        schoolAndScore.setResultsName(&quot;team2&quot;)for test in tests:    stats = (gameResult + stringEnd).parseString(test)    if stats.team1.score != stats.team2.score:        if stats.team1.score &gt; stats.team2.score:            result = &quot;won by &quot; + stats.team1.school        else:            result = &quot;won by &quot; + stats.team2.school    else:        result = &quot;tied&quot;    print(&quot;%s %s(%d) %s(%d), %s&quot; % (stats.date, stats.team1.school, stats.team1.score, stats.team2.school, stats.team2.score, result))    # or print one of these alternative formats    #print &quot;%(date)s %(team1)s %(team2)s&quot; % stats    #print stats.asXML(&quot;GAME&quot;)</code></pre><hr><h2 id="从网页中抽取数据"><a href="#从网页中抽取数据" class="headerlink" title="从网页中抽取数据"></a>从网页中抽取数据</h2><p>从网页中抽取数据的库很多，比如lxml,BeautifulSoup,pyquery,内置的HTMLParser, htmllib等。不过我觉得还是用bs比较好，pyparsing要做的工作比较多。下边一个简单的例子，获取img标签的内容：</p><pre><code>from pyparsing import makeHTMLTagshtml = &quot;&quot;&quot;&lt;div class=&quot;content clearfix&quot;&gt;    &lt;dl class=&quot;&quot;&gt;        &lt;dt&gt;            &lt;a href=&quot;https://book.douban.com/subject/7564420/&quot; onclick=&quot;moreurl(this, {&apos;total&apos;: 10, &apos;clicked&apos;: &apos;7564420&apos;, &apos;pos&apos;: 0, &apos;identifier&apos;: &apos;book-rec-books&apos;})&quot;&gt;&lt;img class=&quot;m_sub_img&quot; src=&quot;https://img3.doubanio.com/spic/s8950064.jpg&quot;&gt;&lt;/a&gt;        &lt;/dt&gt;        &lt;dd&gt;        &lt;a href=&quot;https://book.douban.com/subject/7564420/&quot; onclick=&quot;moreurl(this, {&apos;total&apos;: 10, &apos;clicked&apos;: &apos;7564420&apos;, &apos;pos&apos;: 0, &apos;identifier&apos;: &apos;book-rec-books&apos;})&quot; class=&quot;&quot;&gt;            软件之道        &lt;/a&gt;        &lt;/dd&gt;    &lt;/dl&gt;    &lt;dl class=&quot;&quot;&gt;        &lt;dt&gt;            &lt;a href=&quot;https://book.douban.com/subject/7063664/&quot; onclick=&quot;moreurl(this, {&apos;total&apos;: 10, &apos;clicked&apos;: &apos;7063664&apos;, &apos;pos&apos;: 1, &apos;identifier&apos;: &apos;book-rec-books&apos;})&quot;&gt;&lt;img class=&quot;m_sub_img&quot; src=&quot;https://img3.doubanio.com/spic/s10180950.jpg&quot;&gt;&lt;/a&gt;        &lt;/dt&gt;        &lt;dd&gt;        &lt;a href=&quot;https://book.douban.com/subject/7063664/&quot; onclick=&quot;moreurl(this, {&apos;total&apos;: 10, &apos;clicked&apos;: &apos;7063664&apos;, &apos;pos&apos;: 1, &apos;identifier&apos;: &apos;book-rec-books&apos;})&quot; class=&quot;&quot;&gt;            程序设计中实用的数据结构        &lt;/a&gt;        &lt;/dd&gt;    &lt;/dl&gt;&lt;/div&gt;&quot;&quot;&quot;# define expression for &lt;img&gt; tagimgTag,endImgTag = makeHTMLTags(&quot;img&quot;)# search for matching tags, and# print key attributesfor img in imgTag.searchString(html):    print(&quot;&apos;%(class)s&apos; : %(src)s&quot; % img)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The grammar specification should be a natural-looking part of the Python program, easy-to-read, and familiar in style and format to Python programmers. - Zen of Pyparsing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上篇博客在讲设计模式解释器模式的时候提到了pyparsing库，当时用该库处理命令从而实现了很简单的DSL，这次详细介绍下该库。 &lt;a href=&quot;http://infohost.nmt.edu/tcc/help/pubs/pyparsing/web/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pyparsing&lt;/a&gt;是一个文本处理库，可以用来处理html，日志文件，复杂数据结构或者命令的解析等。比如去除源码中的注释，或者写个简单的DSL等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://ningning.today/tags/python/"/>
    
  </entry>
  
</feed>
